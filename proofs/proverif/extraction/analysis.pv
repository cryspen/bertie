(*****************************************)
(* Top-level process *)
(*****************************************)

(* server_dbs(server_name, db) *)
table server_dbs(bertie__tls13utils__t_Bytes, bertie__server__t_ServerDB, bertie__tls13crypto__t_Algorithms).

(* server_psks(server_name, session_ticket, PSK) *)
table server_psks(bertie__tls13utils__t_Bytes, bertie__tls13utils__t_Bytes, bertie__tls13utils__t_Bytes).

event CompromisedServerCertSK(bertie__tls13utils__t_Bytes).
event CompromisedServerPSK(bertie__tls13utils__t_Bytes).
event ClientFinished(bertie__tls13utils__t_Bytes,bertie__tls13record__t_DuplexCipherState1, bertie__tls13handshake__t_ClientPostClientFinished).
event ServerFinished(bertie__tls13utils__t_Bytes,bertie__tls13record__t_DuplexCipherState1, bertie__tls13handshake__t_ServerPostServerFinished).

(* Reachability queries. *)

(* Should fail: Client can finish handshake. *)
query server_name: bertie__tls13utils__t_Bytes,
      cipher: bertie__tls13record__t_DuplexCipherState1,
      st: bertie__tls13handshake__t_ClientPostClientFinished;

      event(ClientFinished(server_name,cipher,st)).

(* Should fail: Server can finish handshake. *)
query server_name: bertie__tls13utils__t_Bytes,
      cipher: bertie__tls13record__t_DuplexCipherState1,
      st: bertie__tls13handshake__t_ServerPostServerFinished;
      
      event(ServerFinished(server_name,cipher,st)).

(* Server authentication queries. *)

(* Should fail: Authentication is not guaranteed if either PSK or
                certificate signing key are leaked to attacker. *)
query server_name:bertie__tls13utils__t_Bytes,
      alg: bertie__tls13crypto__t_AeadAlgorithm,
      c2skiv: bertie__tls13crypto__t_AeadKeyIV,
      c2sctr:nat,
      s2ckiv:bertie__tls13crypto__t_AeadKeyIV,
      s2cctr:nat,
      ccipher:bertie__tls13record__t_DuplexCipherState1,
      cst:bertie__tls13handshake__t_ClientPostClientFinished,
      sst:bertie__tls13handshake__t_ServerPostServerFinished,
      kstk:bertie__tls13keyscheduler__key_schedule__t_TagKey;
      
      event(ClientFinished(server_name,
                           bertie__tls13record__DuplexCipherState1(alg,c2skiv,c2sctr,s2ckiv,s2cctr,kstk),
                           cst))
      ==> event(ServerFinished(server_name,
                               bertie__tls13record__DuplexCipherState1(alg,s2ckiv,s2cctr,c2skiv,c2sctr,kstk),
                               sst)).

(* Should fail: Authentication is not guaranteed if PSK is leaked to
                attacker. *)
query server_name:bertie__tls13utils__t_Bytes,
      alg: bertie__tls13crypto__t_AeadAlgorithm,
      c2skiv: bertie__tls13crypto__t_AeadKeyIV,
      c2sctr:nat,
      s2ckiv:bertie__tls13crypto__t_AeadKeyIV,
      s2cctr:nat,
      ccipher:bertie__tls13record__t_DuplexCipherState1,
      cst:bertie__tls13handshake__t_ClientPostClientFinished,
      sst:bertie__tls13handshake__t_ServerPostServerFinished,
      kstk:bertie__tls13keyscheduler__key_schedule__t_TagKey;

      event(ClientFinished(server_name,
                           bertie__tls13record__DuplexCipherState1(alg,c2skiv,c2sctr,s2ckiv,s2cctr,kstk),
                           cst))
      ==> event(ServerFinished(server_name,
                               bertie__tls13record__DuplexCipherState1(alg,s2ckiv,s2cctr,c2skiv,c2sctr,kstk),
                               sst))
          || event(CompromisedServerCertSK(server_name)).

(* Should fail: Authentication is not guaranteed if certificate
                signing key is leaked to attacker. *)
query server_name:bertie__tls13utils__t_Bytes,
      alg: bertie__tls13crypto__t_AeadAlgorithm,
      c2skiv: bertie__tls13crypto__t_AeadKeyIV,
      c2sctr:nat,
      s2ckiv:bertie__tls13crypto__t_AeadKeyIV,
      s2cctr:nat,
      ccipher:bertie__tls13record__t_DuplexCipherState1,
      cst:bertie__tls13handshake__t_ClientPostClientFinished,
      sst:bertie__tls13handshake__t_ServerPostServerFinished,
      kstk:bertie__tls13keyscheduler__key_schedule__t_TagKey;

      event(ClientFinished(server_name,
                           bertie__tls13record__DuplexCipherState1(alg,c2skiv,c2sctr,s2ckiv,s2cctr,kstk),
                           cst))
      ==> event(ServerFinished(server_name,
                           bertie__tls13record__DuplexCipherState1(alg,s2ckiv,s2cctr,c2skiv,c2sctr,kstk),
                           sst))
          || event(CompromisedServerPSK(server_name)).

(* Should succeed: Authentication guaranteed if neither PSK nor
                   certificate signing key are leaked to attacker. *)
query server_name:bertie__tls13utils__t_Bytes,
      alg: bertie__tls13crypto__t_AeadAlgorithm,
      c2skiv: bertie__tls13crypto__t_AeadKeyIV,
      c2sctr:nat,
      s2ckiv:bertie__tls13crypto__t_AeadKeyIV,
      s2cctr:nat,
      ccipher:bertie__tls13record__t_DuplexCipherState1,
      cst:bertie__tls13handshake__t_ClientPostClientFinished,
      sst:bertie__tls13handshake__t_ServerPostServerFinished,
      kstk:bertie__tls13keyscheduler__key_schedule__t_TagKey;

      event(ClientFinished(server_name,
                           bertie__tls13record__DuplexCipherState1(alg,c2skiv,c2sctr,s2ckiv,s2cctr,kstk),
                           cst))
      ==> event(ServerFinished(server_name,
                               bertie__tls13record__DuplexCipherState1(alg,s2ckiv,s2cctr,c2skiv,c2sctr,kstk),
                               sst))
          || event(CompromisedServerCertSK(server_name))
          || event(CompromisedServerPSK(server_name)).


(* Session key secrecy queries. *)
(* Should fail: Session key secrecy is not guaranteed if either PSK or
                certificate signing key are leaked to attacker. *)
query server_name:bertie__tls13utils__t_Bytes,
      alg: bertie__tls13crypto__t_AeadAlgorithm,
      c2skiv: bertie__tls13crypto__t_AeadKeyIV,
      c2sctr:nat,
      s2ckiv:bertie__tls13crypto__t_AeadKeyIV,
      s2cctr:nat,
      ccipher:bertie__tls13record__t_DuplexCipherState1,
      cst:bertie__tls13handshake__t_ClientPostClientFinished,
      kstk:bertie__tls13keyscheduler__key_schedule__t_TagKey;

      event(ClientFinished(server_name,
                           bertie__tls13record__DuplexCipherState1(alg,c2skiv,c2sctr,s2ckiv,s2cctr,kstk),
                           cst))
      && attacker(s2ckiv).

(* Should fail: Session key secrecy is not guaranteed if PSK is leaked
                to attacker. *)
query server_name:bertie__tls13utils__t_Bytes,
      alg: bertie__tls13crypto__t_AeadAlgorithm,
      c2skiv: bertie__tls13crypto__t_AeadKeyIV,
      c2sctr:nat,
      s2ckiv:bertie__tls13crypto__t_AeadKeyIV,
      s2cctr:nat,
      ccipher:bertie__tls13record__t_DuplexCipherState1,
      cst:bertie__tls13handshake__t_ClientPostClientFinished,
      kstk:bertie__tls13keyscheduler__key_schedule__t_TagKey;

      event(ClientFinished(server_name,
                           bertie__tls13record__DuplexCipherState1(alg,c2skiv,c2sctr,s2ckiv,s2cctr,kstk),
                           cst))
      && attacker(s2ckiv)
      ==> event(CompromisedServerCertSK(server_name)).

(* Should fail: Session key secrecy is not guaranteed if certificate
                signing key is leaked to attacker. *)
query server_name:bertie__tls13utils__t_Bytes,
      alg: bertie__tls13crypto__t_AeadAlgorithm,
      c2skiv: bertie__tls13crypto__t_AeadKeyIV,
      c2sctr:nat,
      s2ckiv:bertie__tls13crypto__t_AeadKeyIV,
      s2cctr:nat,
      ccipher:bertie__tls13record__t_DuplexCipherState1,
      cst:bertie__tls13handshake__t_ClientPostClientFinished,
      kstk:bertie__tls13keyscheduler__key_schedule__t_TagKey;

      event(ClientFinished(server_name,
                           bertie__tls13record__DuplexCipherState1(alg,c2skiv,c2sctr,s2ckiv,s2cctr,kstk),
                           cst))
      && attacker(s2ckiv)
      ==> event(CompromisedServerPSK(server_name)).

(* Should succeed: Session key secrecy is guaranteed if neither PSK
                   nor certificate signing key are leaked to attacker. *)
query server_name:bertie__tls13utils__t_Bytes,
      alg: bertie__tls13crypto__t_AeadAlgorithm,
      c2skiv: bertie__tls13crypto__t_AeadKeyIV,
      c2sctr:nat,
      s2ckiv:bertie__tls13crypto__t_AeadKeyIV,
      s2cctr:nat,
      ccipher:bertie__tls13record__t_DuplexCipherState1,
      cst:bertie__tls13handshake__t_ClientPostClientFinished,
      kstk:bertie__tls13keyscheduler__key_schedule__t_TagKey;

      event(ClientFinished(server_name,
                           bertie__tls13record__DuplexCipherState1(alg,c2skiv,c2sctr,s2ckiv,s2cctr,kstk),
                           cst))
      && attacker(s2ckiv)
      ==> event(CompromisedServerCertSK(server_name))
          || event(CompromisedServerPSK(server_name)).

fun extern__validate_cert(bertie__tls13utils__t_Bytes,bertie__tls13utils__t_Bytes): bool
reduc forall server_name: bertie__tls13utils__t_Bytes,
             alg: bertie__tls13crypto__t_SignatureScheme,
             vk: bertie__tls13crypto__t_PublicVerificationKey;
      extern__validate_cert(server_name, extern__certificate(server_name, alg, vk)) = true
otherwise forall server_name: bertie__tls13utils__t_Bytes,
                 invalid: bertie__tls13utils__t_Bytes;
      extern__validate_cert(server_name, invalid) = false.

letfun set_psk(server_name: bertie__tls13utils__t_Bytes, psk_mode: bool) =
       if psk_mode then
          new psk: bertie__tls13utils__t_Bytes;
          new ticket: bertie__tls13utils__t_Bytes;
          insert server_psks(server_name, ticket, psk);
          Some((ticket, psk))
        else
          None().

letfun get_psk(server_name: bertie__tls13utils__t_Bytes, psk_mode: bool) =
       if psk_mode then
        (get server_psks(=server_name, client_ticket, psk) in
          (Some(bertie__tls13utils__t_Bytes_to_bitstring(client_ticket)),
           Some(bertie__tls13utils__t_Bytes_to_bitstring(psk))))
        else
          (None(), None()).

(* Client and Server need to start from the same empty key schedule. *)
const KS_EMPTY: bertie__tls13keyscheduler__key_schedule__t_TLSkeyscheduler.

let Client(algs: bertie__tls13crypto__t_Algorithms, psk_mode: bool) =
    in(c, server_name: bertie__tls13utils__t_Bytes);
    new rng_client: impl_CryptoRng;
    let ks_client = KS_EMPTY in

    let (client_ticket_o: Option, psk_o: Option)
        = get_psk(server_name, psk_mode)
    in

    let (rng_client: impl_CryptoRng, ks_client: bertie__tls13keyscheduler__key_schedule__t_TLSkeyscheduler, client_init_out: bitstring)
        = bertie__tls13handshake__client_init(algs,
                                              server_name,
                                              client_ticket_o,
                                              psk_o,
                                              rng_client,
                                              ks_client)
    in

    let (nch: bertie__tls13formats__handshake_data__t_HandshakeData,
         cipher0: Option,
         client_state: bertie__tls13handshake__t_ClientPostClientHello)
        = client_init_out in
    out(c, nch);
    in(c, server_hello: bertie__tls13formats__handshake_data__t_HandshakeData);


    let (ks_client: bertie__tls13keyscheduler__key_schedule__t_TLSkeyscheduler,
         (duplex_cipher_state_h: bertie__tls13record__t_DuplexCipherStateH,
         client_state: bertie__tls13handshake__t_ClientPostServerHello))
        = bertie__tls13handshake__client_set_params(server_hello,
                                                    client_state,
                                                    ks_client)
    in

    in(c, flight_encrypted: bitstring);

    let flight = bertie__tls13record__decrypt_handshake(flight_encrypted, duplex_cipher_state_h) in

    let (ks_client: bertie__tls13keyscheduler__key_schedule__t_TLSkeyscheduler, (client_finished: bertie__tls13formats__handshake_data__t_HandshakeData,
         cipher: bertie__tls13record__t_DuplexCipherState1,
         client_state: bertie__tls13handshake__t_ClientPostClientFinished))
        = bertie__tls13handshake__client_finish(flight,
                                                client_state,
                                                ks_client)
    in

    (* This is what `get_server_info` does *)
    let server_pub_info = accessor_bertie__tls13handshake__t_ClientPostClientFinished_bertie__tls13handshake__3(client_state) in
    let certificate_opt = accessor_bertie__server__t_ServerPubInfo_bertie__server__f_certificate(server_pub_info) in
    let server_name_info = accessor_bertie__server__t_ServerPubInfo_bertie__server__f_server_name(
                          server_pub_info
                        ) in
    let Some(certificate_bitstring) = certificate_opt in
    let bertie__tls13utils__t_Bytes_to_bitstring(certificate) = certificate_bitstring in

    (* Verify that certificate is valid *)        
    if extern__validate_cert(server_name_info, certificate) = true then (
       event ClientFinished(server_name,cipher,client_state);
       let finish_encrypted = bertie__tls13record__encrypt_handshake(client_finished, 0, duplex_cipher_state_h) in
       out(c, finish_encrypted)
    ).

let Server() =
    in(c, server_name: bertie__tls13utils__t_Bytes);
    get server_dbs(=server_name, db, algs) in    

    new rng_server: impl_CryptoRng;
    let ks_server = KS_EMPTY in
    
    in(c, nch: bertie__tls13formats__handshake_data__t_HandshakeData);
    let (rng_server: impl_CryptoRng, ks_server: bertie__tls13keyscheduler__key_schedule__t_TLSkeyscheduler, server_init_output: bitstring)
        = bertie__tls13handshake__server_init(algs,
                                              nch,
                                              db,
                                              rng_server,
                                              ks_server)
    in

    let
      (server_hello: bertie__tls13formats__handshake_data__t_HandshakeData,
       flight: bertie__tls13formats__handshake_data__t_HandshakeData,
       cipher0: Option,
       cipher_hs: bertie__tls13record__t_DuplexCipherStateH,
       cipher1: bertie__tls13record__t_DuplexCipherState1,
       server_state: bertie__tls13handshake__t_ServerPostServerFinished)
    = server_init_output in

    event ServerFinished(server_name,cipher1,server_state);

    out(c, server_hello);
    
    let flight_encrypted = bertie__tls13record__encrypt_handshake(flight, 0, cipher_hs) in
    out(c, flight_encrypted);

    in(c, finish_encrypted: bitstring);
    let client_finished = bertie__tls13record__decrypt_handshake(finish_encrypted, cipher_hs) in

    let (ks_server: bertie__tls13keyscheduler__key_schedule__t_TLSkeyscheduler, server_state: bitstring)
        = bertie__tls13handshake__server_finish(client_finished,
                                                server_state,
                                                ks_server)
    in
    0.

let CreateServer(algs: bertie__tls13crypto__t_Algorithms, psk_mode: bool) =
    in(c, server_name: bertie__tls13utils__t_Bytes);
    new cert_sk: bertie__tls13utils__t_Bytes;

    let psk_opt = set_psk(server_name, psk_mode) in

    let bertie__tls13crypto__SignatureScheme_EcdsaSecp256r1Sha256()
        = bertie__tls13crypto__impl_Algorithms__signature(algs)
        in
        (let cert = extern__certificate(
                       server_name,
                       bertie__tls13crypto__SignatureScheme_EcdsaSecp256r1Sha256(),
                       extern__vk_from_sk(cert_sk)
                    )
        in
        let db = bertie__server__ServerDB(
            server_name,
            cert,
            cert_sk,
            psk_opt)
        in
        insert server_dbs(server_name, db, algs))
    else let bertie__tls13crypto__SignatureScheme_RsaPssRsaSha256()
             = bertie__tls13crypto__impl_Algorithms__signature(algs)
             in
             (let cert = extern__certificate(
                         server_name,
                         bertie__tls13crypto__SignatureScheme_RsaPssRsaSha256(),
                         extern__vk_from_sk(cert_sk))
             in
             let db = bertie__server__ServerDB(
                  server_name,
                  cert,
                  cert_sk,
                  psk_opt)
             in
             insert server_dbs(server_name, db, algs)).

let CompromiseServerCertSK() =
    in(c, server_name: bertie__tls13utils__t_Bytes);
    get server_dbs(=server_name, db, algs) in
    let bertie__server__ServerDB(
            server_name,
            cert,
            cert_sk,
            psk_opt
        ) = db in
    event CompromisedServerCertSK(server_name);
    out(c, cert_sk).

let CompromiseServerPSK() =
    in(c, server_name: bertie__tls13utils__t_Bytes);
    get server_psks(=server_name, client_ticket, psk) in
    event CompromisedServerPSK(server_name);
    out(c, psk).
    
process
    let psk_mode = false in
    let zero_rtt = false in
    
    (* SHA256_Chacha20Poly1305_RsaPssRsaSha256_X25519 *)
    let SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519 = 
        bertie__tls13crypto__Algorithms(bertie__tls13crypto__HashAlgorithm_SHA256(),
                                          bertie__tls13crypto__AeadAlgorithm_Chacha20Poly1305(),
                                          bertie__tls13crypto__SignatureScheme_EcdsaSecp256r1Sha256(),
                                          bertie__tls13crypto__KemScheme_X25519(),
                                          psk_mode,
                                          zero_rtt)
    in
    
    (* SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_X25519 *)
    let SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_X25519 =
     bertie__tls13crypto__Algorithms(bertie__tls13crypto__HashAlgorithm_SHA256(),
                                       bertie__tls13crypto__AeadAlgorithm_Aes128Gcm(),
                                       bertie__tls13crypto__SignatureScheme_EcdsaSecp256r1Sha256(),
                                       bertie__tls13crypto__KemScheme_X25519(),
                                       psk_mode,
                                       zero_rtt)
    in

    (* SHA256_Aes128Gcm_RsaPssRsaSha256_X25519 *)
    let SHA256_Aes128Gcm_RsaPssRsaSha256_X25519 =
     bertie__tls13crypto__Algorithms(bertie__tls13crypto__HashAlgorithm_SHA256(),
                                       bertie__tls13crypto__AeadAlgorithm_Aes128Gcm(),
                                       bertie__tls13crypto__SignatureScheme_RsaPssRsaSha256(),
                                       bertie__tls13crypto__KemScheme_X25519(),
                                       psk_mode,
                                       zero_rtt)
    in

    (* SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_X25519 *)
    let SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_X25519 =
     bertie__tls13crypto__Algorithms(bertie__tls13crypto__HashAlgorithm_SHA384(),
                                       bertie__tls13crypto__AeadAlgorithm_Aes256Gcm(),
                                       bertie__tls13crypto__SignatureScheme_EcdsaSecp256r1Sha256(),
                                       bertie__tls13crypto__KemScheme_X25519(),
                                       psk_mode,
                                       zero_rtt)
    in

    (* SHA384_Aes256Gcm_RsaPssRsaSha256_X25519 *)
    let SHA384_Aes256Gcm_RsaPssRsaSha256_X25519 =
     bertie__tls13crypto__Algorithms(bertie__tls13crypto__HashAlgorithm_SHA384(),
                                       bertie__tls13crypto__AeadAlgorithm_Aes256Gcm(),
                                       bertie__tls13crypto__SignatureScheme_RsaPssRsaSha256(),
                                       bertie__tls13crypto__KemScheme_X25519(),
                                       psk_mode,
                                       zero_rtt)
    in
      !CreateServer(SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519, psk_mode)
    | !CreateServer(SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_X25519, psk_mode)
    | !CreateServer(SHA256_Aes128Gcm_RsaPssRsaSha256_X25519, psk_mode)
    | !CreateServer(SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_X25519, psk_mode)
    | !CreateServer(SHA384_Aes256Gcm_RsaPssRsaSha256_X25519, psk_mode)
    | !Client(SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519, psk_mode)
    | !Client(SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_X25519, psk_mode)
    | !Client(SHA256_Aes128Gcm_RsaPssRsaSha256_X25519, psk_mode)
    | !Client(SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_X25519, psk_mode)
    | !Client(SHA384_Aes256Gcm_RsaPssRsaSha256_X25519, psk_mode)
    | !Server() | !CompromiseServerCertSK() | !CompromiseServerPSK()
