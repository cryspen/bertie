(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.


   Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

Require Import CryptoRng.
Export CryptoRng.

Require Import lookup_db.
Export lookup_db.

Require Import ServerDB.
Export ServerDB.

Require Import ServerInfo.
Export ServerInfo.

Require Import cert_public_key.
Export cert_public_key.

Require Import rsa_public_key.
Export rsa_public_key.

Require Import verification_key_from_cert.
Export verification_key_from_cert.

Require Import hmac_tag.
Export hmac_tag.

Require Import hmac_verify.
Export hmac_verify.

Require Import kem_decap.
Export kem_decap.

Require Import kem_encap.
Export kem_encap.

Require Import kem_keygen.
Export kem_keygen.

Require Import sign.
Export sign.

Require Import sign_rsa.
Export sign_rsa.

Require Import verify.
Export verify.

Require Import Algorithms.
Export Algorithms.

Require Import Digest.
Export Digest.

Require Import KemSk.
Export KemSk.

Require Import MacKey.
Export MacKey.

Require Import Psk.
Export Psk.

Require Import Random.
Export Random.

Require Import SignatureScheme.
Export SignatureScheme.

Require Import HandshakeData.
Export HandshakeData.

Require Import Crate_Tls13formats.
Export Crate_Tls13formats.

Require Import Crate_Tls13keyscheduler_Key_schedule_TLSnames.
Export Crate_Tls13keyscheduler_Key_schedule_TLSnames.

Require Import Crate_Tls13keyscheduler_Key_schedule.
Export Crate_Tls13keyscheduler_Key_schedule.

Require Import Crate_Tls13keyscheduler.
Export Crate_Tls13keyscheduler.

Require Import Crate_Tls13record.
Export Crate_Tls13record.

Require Import Crate_Tls13utils.
Export Crate_Tls13utils.

Definition t_ClientPostClientHello : choice_type :=
  (t_Bytes × t_Algorithms × t_Bytes × t_Option t_Bytes × t_Transcript).
Equations 0 (s : both t_ClientPostClientHello) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostClientHello) : both t_Algorithms :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostClientHello) : both t_Bytes :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostClientHello) : both (t_Option t_Bytes) :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : (t_Option t_Bytes))) : both (t_Option t_Bytes).
Fail Next Obligation.
Equations 4 (s : both t_ClientPostClientHello) : both t_Transcript :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostClientHello {0 : both t_Bytes} {1 : both t_Algorithms} {2 : both t_Bytes} {3 : both (t_Option t_Bytes)} {4 : both t_Transcript} : both (t_ClientPostClientHello) :=
  Build_t_ClientPostClientHello  :=
    bind_both 4 (fun 4 =>
      bind_both 3 (fun 3 =>
        bind_both 2 (fun 2 =>
          bind_both 1 (fun 1 =>
            bind_both 0 (fun 0 =>
              ret_both ((0,1,2,3,4) : (t_ClientPostClientHello))))))) : both (t_ClientPostClientHello).
Fail Next Obligation.
#[global] Program Instance t_ClientPostClientHello_Settable : Settable (both t_ClientPostClientHello) :=
  let mkT := fun x =>  (bind_both (4 x) (fun 4 =>
    bind_both (3 x) (fun 3 =>
      bind_both (2 x) (fun 2 =>
        bind_both (1 x) (fun 1 =>
          bind_both (0 x) (fun 0 =>
            ret_both ((0,1,2,3,4) : (t_ClientPostClientHello)))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Definition t_ClientPostServerHello : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_Handle × t_Bytes × t_Bytes × t_Transcript).
Equations 0 (s : both t_ClientPostServerHello) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostServerHello) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostServerHello) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostServerHello) : both t_Handle :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Handle)) : both t_Handle.
Fail Next Obligation.
Equations 4 (s : both t_ClientPostServerHello) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ClientPostServerHello) : both t_Bytes :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 6 (s : both t_ClientPostServerHello) : both t_Transcript :=
  6 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostServerHello {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_Handle} {4 : both t_Bytes} {5 : both t_Bytes} {6 : both t_Transcript} : both (t_ClientPostServerHello) :=
  Build_t_ClientPostServerHello  :=
    bind_both 6 (fun 6 =>
      bind_both 5 (fun 5 =>
        bind_both 4 (fun 4 =>
          bind_both 3 (fun 3 =>
            bind_both 2 (fun 2 =>
              bind_both 1 (fun 1 =>
                bind_both 0 (fun 0 =>
                  ret_both ((0,1,2,3,4,5,6) : (t_ClientPostServerHello))))))))) : both (t_ClientPostServerHello).
Fail Next Obligation.
#[global] Program Instance t_ClientPostServerHello_Settable : Settable (both t_ClientPostServerHello) :=
  let mkT := fun x =>  (bind_both (6 x) (fun 6 =>
    bind_both (5 x) (fun 5 =>
      bind_both (4 x) (fun 4 =>
        bind_both (3 x) (fun 3 =>
          bind_both (2 x) (fun 2 =>
            bind_both (1 x) (fun 1 =>
              bind_both (0 x) (fun 0 =>
                ret_both ((0,1,2,3,4,5,6) : (t_ClientPostServerHello)))))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Definition t_ClientPostCertificateVerify : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_Handle × t_Bytes × t_Bytes × t_Transcript).
Equations 0 (s : both t_ClientPostCertificateVerify) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostCertificateVerify) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostCertificateVerify) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostCertificateVerify) : both t_Handle :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Handle)) : both t_Handle.
Fail Next Obligation.
Equations 4 (s : both t_ClientPostCertificateVerify) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ClientPostCertificateVerify) : both t_Bytes :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 6 (s : both t_ClientPostCertificateVerify) : both t_Transcript :=
  6 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostCertificateVerify {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_Handle} {4 : both t_Bytes} {5 : both t_Bytes} {6 : both t_Transcript} : both (t_ClientPostCertificateVerify) :=
  Build_t_ClientPostCertificateVerify  :=
    bind_both 6 (fun 6 =>
      bind_both 5 (fun 5 =>
        bind_both 4 (fun 4 =>
          bind_both 3 (fun 3 =>
            bind_both 2 (fun 2 =>
              bind_both 1 (fun 1 =>
                bind_both 0 (fun 0 =>
                  ret_both ((0,1,2,3,4,5,6) : (t_ClientPostCertificateVerify))))))))) : both (t_ClientPostCertificateVerify).
Fail Next Obligation.
#[global] Program Instance t_ClientPostCertificateVerify_Settable : Settable (both t_ClientPostCertificateVerify) :=
  let mkT := fun x =>  (bind_both (6 x) (fun 6 =>
    bind_both (5 x) (fun 5 =>
      bind_both (4 x) (fun 4 =>
        bind_both (3 x) (fun 3 =>
          bind_both (2 x) (fun 2 =>
            bind_both (1 x) (fun 1 =>
              bind_both (0 x) (fun 0 =>
                ret_both ((0,1,2,3,4,5,6) : (t_ClientPostCertificateVerify)))))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Definition t_ClientPostServerFinished : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_Handle × t_Bytes × t_Transcript).
Equations 0 (s : both t_ClientPostServerFinished) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostServerFinished) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostServerFinished) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostServerFinished) : both t_Handle :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Handle)) : both t_Handle.
Fail Next Obligation.
Equations 4 (s : both t_ClientPostServerFinished) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ClientPostServerFinished) : both t_Transcript :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostServerFinished {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_Handle} {4 : both t_Bytes} {5 : both t_Transcript} : both (t_ClientPostServerFinished) :=
  Build_t_ClientPostServerFinished  :=
    bind_both 5 (fun 5 =>
      bind_both 4 (fun 4 =>
        bind_both 3 (fun 3 =>
          bind_both 2 (fun 2 =>
            bind_both 1 (fun 1 =>
              bind_both 0 (fun 0 =>
                ret_both ((0,1,2,3,4,5) : (t_ClientPostServerFinished)))))))) : both (t_ClientPostServerFinished).
Fail Next Obligation.
#[global] Program Instance t_ClientPostServerFinished_Settable : Settable (both t_ClientPostServerFinished) :=
  let mkT := fun x =>  (bind_both (5 x) (fun 5 =>
    bind_both (4 x) (fun 4 =>
      bind_both (3 x) (fun 3 =>
        bind_both (2 x) (fun 2 =>
          bind_both (1 x) (fun 1 =>
            bind_both (0 x) (fun 0 =>
              ret_both ((0,1,2,3,4,5) : (t_ClientPostServerFinished))))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Definition t_ClientPostClientFinished : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_Handle × t_Transcript).
Equations 0 (s : both t_ClientPostClientFinished) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostClientFinished) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostClientFinished) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostClientFinished) : both t_Handle :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Handle)) : both t_Handle.
Fail Next Obligation.
Equations 4 (s : both t_ClientPostClientFinished) : both t_Transcript :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostClientFinished {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_Handle} {4 : both t_Transcript} : both (t_ClientPostClientFinished) :=
  Build_t_ClientPostClientFinished  :=
    bind_both 4 (fun 4 =>
      bind_both 3 (fun 3 =>
        bind_both 2 (fun 2 =>
          bind_both 1 (fun 1 =>
            bind_both 0 (fun 0 =>
              ret_both ((0,1,2,3,4) : (t_ClientPostClientFinished))))))) : both (t_ClientPostClientFinished).
Fail Next Obligation.
#[global] Program Instance t_ClientPostClientFinished_Settable : Settable (both t_ClientPostClientFinished) :=
  let mkT := fun x =>  (bind_both (4 x) (fun 4 =>
    bind_both (3 x) (fun 3 =>
      bind_both (2 x) (fun 2 =>
        bind_both (1 x) (fun 1 =>
          bind_both (0 x) (fun 0 =>
            ret_both ((0,1,2,3,4) : (t_ClientPostClientFinished)))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Equations algs_post_client_hello (st : both t_ClientPostClientHello) : both t_Algorithms :=
  algs_post_client_hello st  :=
    1 st : both t_Algorithms.
Fail Next Obligation.

Equations algs_post_server_hello (st : both t_ClientPostServerHello) : both t_Algorithms :=
  algs_post_server_hello st  :=
    2 st : both t_Algorithms.
Fail Next Obligation.

Equations algs_post_client_finished (st : both t_ClientPostClientFinished) : both t_Algorithms :=
  algs_post_client_finished st  :=
    2 st : both t_Algorithms.
Fail Next Obligation.

Definition t_ServerPostClientHello : choice_type :=
  (t_Bytes × t_Algorithms × t_Bytes × t_Bytes × t_ServerInfo × t_Transcript).
Equations f_client_randomness (s : both t_ServerPostClientHello) : both t_Bytes :=
  f_client_randomness s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_ciphersuite (s : both t_ServerPostClientHello) : both t_Algorithms :=
  f_ciphersuite s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations f_session_id (s : both t_ServerPostClientHello) : both t_Bytes :=
  f_session_id s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_gx (s : both t_ServerPostClientHello) : both t_Bytes :=
  f_gx s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_server (s : both t_ServerPostClientHello) : both t_ServerInfo :=
  f_server s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_ServerInfo)) : both t_ServerInfo.
Fail Next Obligation.
Equations f_transcript (s : both t_ServerPostClientHello) : both t_Transcript :=
  f_transcript s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostClientHello {f_client_randomness : both t_Bytes} {f_ciphersuite : both t_Algorithms} {f_session_id : both t_Bytes} {f_gx : both t_Bytes} {f_server : both t_ServerInfo} {f_transcript : both t_Transcript} : both (t_ServerPostClientHello) :=
  Build_t_ServerPostClientHello  :=
    bind_both f_transcript (fun f_transcript =>
      bind_both f_server (fun f_server =>
        bind_both f_gx (fun f_gx =>
          bind_both f_session_id (fun f_session_id =>
            bind_both f_ciphersuite (fun f_ciphersuite =>
              bind_both f_client_randomness (fun f_client_randomness =>
                ret_both ((f_client_randomness,f_ciphersuite,f_session_id,f_gx,f_server,f_transcript) : (t_ServerPostClientHello)))))))) : both (t_ServerPostClientHello).
Fail Next Obligation.
#[global] Program Instance t_ServerPostClientHello_Settable : Settable (both t_ServerPostClientHello) :=
  let mkT := fun x =>  (bind_both (f_transcript x) (fun f_transcript =>
    bind_both (f_server x) (fun f_server =>
      bind_both (f_gx x) (fun f_gx =>
        bind_both (f_session_id x) (fun f_session_id =>
          bind_both (f_ciphersuite x) (fun f_ciphersuite =>
            bind_both (f_client_randomness x) (fun f_client_randomness =>
              ret_both ((f_client_randomness,f_ciphersuite,f_session_id,f_gx,f_server,f_transcript) : (t_ServerPostClientHello))))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Definition t_ServerPostServerHello : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_ServerInfo × t_Handle × t_Bytes × t_Bytes × t_Transcript).
Equations f_client_random (s : both t_ServerPostServerHello) : both t_Bytes :=
  f_client_random s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst (fst (fst x)))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_server_random (s : both t_ServerPostServerHello) : both t_Bytes :=
  f_server_random s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst (fst x)))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_ciphersuite (s : both t_ServerPostServerHello) : both t_Algorithms :=
  f_ciphersuite s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst x))))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations f_server (s : both t_ServerPostServerHello) : both t_ServerInfo :=
  f_server s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_ServerInfo)) : both t_ServerInfo.
Fail Next Obligation.
Equations f_master_secret (s : both t_ServerPostServerHello) : both t_Handle :=
  f_master_secret s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Handle)) : both t_Handle.
Fail Next Obligation.
Equations f_cfk (s : both t_ServerPostServerHello) : both t_Bytes :=
  f_cfk s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_sfk (s : both t_ServerPostServerHello) : both t_Bytes :=
  f_sfk s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_transcript (s : both t_ServerPostServerHello) : both t_Transcript :=
  f_transcript s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostServerHello {f_client_random : both t_Bytes} {f_server_random : both t_Bytes} {f_ciphersuite : both t_Algorithms} {f_server : both t_ServerInfo} {f_master_secret : both t_Handle} {f_cfk : both t_Bytes} {f_sfk : both t_Bytes} {f_transcript : both t_Transcript} : both (t_ServerPostServerHello) :=
  Build_t_ServerPostServerHello  :=
    bind_both f_transcript (fun f_transcript =>
      bind_both f_sfk (fun f_sfk =>
        bind_both f_cfk (fun f_cfk =>
          bind_both f_master_secret (fun f_master_secret =>
            bind_both f_server (fun f_server =>
              bind_both f_ciphersuite (fun f_ciphersuite =>
                bind_both f_server_random (fun f_server_random =>
                  bind_both f_client_random (fun f_client_random =>
                    ret_both ((f_client_random,f_server_random,f_ciphersuite,f_server,f_master_secret,f_cfk,f_sfk,f_transcript) : (t_ServerPostServerHello)))))))))) : both (t_ServerPostServerHello).
Fail Next Obligation.
#[global] Program Instance t_ServerPostServerHello_Settable : Settable (both t_ServerPostServerHello) :=
  let mkT := fun x =>  (bind_both (f_transcript x) (fun f_transcript =>
    bind_both (f_sfk x) (fun f_sfk =>
      bind_both (f_cfk x) (fun f_cfk =>
        bind_both (f_master_secret x) (fun f_master_secret =>
          bind_both (f_server x) (fun f_server =>
            bind_both (f_ciphersuite x) (fun f_ciphersuite =>
              bind_both (f_server_random x) (fun f_server_random =>
                bind_both (f_client_random x) (fun f_client_random =>
                  ret_both ((f_client_random,f_server_random,f_ciphersuite,f_server,f_master_secret,f_cfk,f_sfk,f_transcript) : (t_ServerPostServerHello))))))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Definition t_ServerPostCertificateVerify : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_Handle × t_Bytes × t_Bytes × t_Transcript).
Equations 0 (s : both t_ServerPostCertificateVerify) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ServerPostCertificateVerify) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ServerPostCertificateVerify) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ServerPostCertificateVerify) : both t_Handle :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Handle)) : both t_Handle.
Fail Next Obligation.
Equations 4 (s : both t_ServerPostCertificateVerify) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ServerPostCertificateVerify) : both t_Bytes :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 6 (s : both t_ServerPostCertificateVerify) : both t_Transcript :=
  6 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostCertificateVerify {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_Handle} {4 : both t_Bytes} {5 : both t_Bytes} {6 : both t_Transcript} : both (t_ServerPostCertificateVerify) :=
  Build_t_ServerPostCertificateVerify  :=
    bind_both 6 (fun 6 =>
      bind_both 5 (fun 5 =>
        bind_both 4 (fun 4 =>
          bind_both 3 (fun 3 =>
            bind_both 2 (fun 2 =>
              bind_both 1 (fun 1 =>
                bind_both 0 (fun 0 =>
                  ret_both ((0,1,2,3,4,5,6) : (t_ServerPostCertificateVerify))))))))) : both (t_ServerPostCertificateVerify).
Fail Next Obligation.
#[global] Program Instance t_ServerPostCertificateVerify_Settable : Settable (both t_ServerPostCertificateVerify) :=
  let mkT := fun x =>  (bind_both (6 x) (fun 6 =>
    bind_both (5 x) (fun 5 =>
      bind_both (4 x) (fun 4 =>
        bind_both (3 x) (fun 3 =>
          bind_both (2 x) (fun 2 =>
            bind_both (1 x) (fun 1 =>
              bind_both (0 x) (fun 0 =>
                ret_both ((0,1,2,3,4,5,6) : (t_ServerPostCertificateVerify)))))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Definition t_ServerPostServerFinished : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_Handle × t_Bytes × t_Transcript).
Equations 0 (s : both t_ServerPostServerFinished) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ServerPostServerFinished) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ServerPostServerFinished) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ServerPostServerFinished) : both t_Handle :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Handle)) : both t_Handle.
Fail Next Obligation.
Equations 4 (s : both t_ServerPostServerFinished) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ServerPostServerFinished) : both t_Transcript :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostServerFinished {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_Handle} {4 : both t_Bytes} {5 : both t_Transcript} : both (t_ServerPostServerFinished) :=
  Build_t_ServerPostServerFinished  :=
    bind_both 5 (fun 5 =>
      bind_both 4 (fun 4 =>
        bind_both 3 (fun 3 =>
          bind_both 2 (fun 2 =>
            bind_both 1 (fun 1 =>
              bind_both 0 (fun 0 =>
                ret_both ((0,1,2,3,4,5) : (t_ServerPostServerFinished)))))))) : both (t_ServerPostServerFinished).
Fail Next Obligation.
#[global] Program Instance t_ServerPostServerFinished_Settable : Settable (both t_ServerPostServerFinished) :=
  let mkT := fun x =>  (bind_both (5 x) (fun 5 =>
    bind_both (4 x) (fun 4 =>
      bind_both (3 x) (fun 3 =>
        bind_both (2 x) (fun 2 =>
          bind_both (1 x) (fun 1 =>
            bind_both (0 x) (fun 0 =>
              ret_both ((0,1,2,3,4,5) : (t_ServerPostServerFinished))))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Definition t_ServerPostClientFinished : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_Handle × t_Transcript).
Equations 0 (s : both t_ServerPostClientFinished) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ServerPostClientFinished) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ServerPostClientFinished) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ServerPostClientFinished) : both t_Handle :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Handle)) : both t_Handle.
Fail Next Obligation.
Equations 4 (s : both t_ServerPostClientFinished) : both t_Transcript :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostClientFinished {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_Handle} {4 : both t_Transcript} : both (t_ServerPostClientFinished) :=
  Build_t_ServerPostClientFinished  :=
    bind_both 4 (fun 4 =>
      bind_both 3 (fun 3 =>
        bind_both 2 (fun 2 =>
          bind_both 1 (fun 1 =>
            bind_both 0 (fun 0 =>
              ret_both ((0,1,2,3,4) : (t_ServerPostClientFinished))))))) : both (t_ServerPostClientFinished).
Fail Next Obligation.
#[global] Program Instance t_ServerPostClientFinished_Settable : Settable (both t_ServerPostClientFinished) :=
  let mkT := fun x =>  (bind_both (4 x) (fun 4 =>
    bind_both (3 x) (fun 3 =>
      bind_both (2 x) (fun 2 =>
        bind_both (1 x) (fun 1 =>
          bind_both (0 x) (fun 0 =>
            ret_both ((0,1,2,3,4) : (t_ServerPostClientFinished)))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

(*item error backend*)

Equations build_client_hello {iimpl_447424039_ : iimpl_447424039_} `{ t_Sized iimpl_447424039_} `{ t_CryptoRng iimpl_447424039_} (ciphersuite : both t_Algorithms) (sn : both t_Bytes) (tkt : both (t_Option t_Bytes)) (psk : both (t_Option t_Bytes)) (rng : both iimpl_447424039_) (ks : both t_TLSkeyscheduler) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8) :=
  build_client_hello ciphersuite sn tkt psk rng ks  :=
    run (letb tx := impl_Transcript__new (impl_Algorithms__hash ciphersuite) in
    letb client_random := repeat (ret_both (0 : int8)) (ret_both (32 : uint_size)) in
    letb '(tmp0,tmp1) := f_fill_bytes rng client_random in
    letb rng := tmp0 in
    letb client_random := tmp1 in
    letb _ := ret_both (tt : 'unit) in
    letb '(tmp0,out) := kem_keygen (impl_Algorithms__kem ciphersuite) rng in
    letb rng := tmp0 in
    letb hoist18 := out in
    letb hoist19 := f_branch hoist18 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] '(kem_sk,kem_pk) := matchb hoist19 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] hoist17 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist17)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes × t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] '(client_hello,trunc_len) := matchb f_branch (client_hello ciphersuite (bytes (unsize client_random)) kem_pk sn tkt) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] hoist20 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist20)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × uint_size)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := compute_psk_binder_zero_rtt ciphersuite client_hello trunc_len psk tx ks in
    letb ks := tmp0 in
    letb hoist22 := out in
    letb hoist23 := f_branch hoist22 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] '(nch,cipher0,tx_ch) := matchb hoist23 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] hoist21 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist21)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_Option t_ClientCipherState0 × t_Transcript)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (nch,cipher0,ClientPostClientHello (f_into client_random) ciphersuite kem_sk psk tx_ch)) in
    prod_b (rng,ks,hax_temp_output))) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8).
Fail Next Obligation.

Equations put_server_hello (handshake : both t_HandshakeData) (state : both t_ClientPostClientHello) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8) :=
  put_server_hello handshake state ks  :=
    run (letb ClientPostClientHello (client_random,ciphersuite,sk,psk,tx) := state in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] '(sr,ct) := matchb f_branch (parse_server_hello ciphersuite handshake) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] hoist39 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist39)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes × t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb tx := impl_Transcript__add tx handshake in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] shared_secret := matchb f_branch (kem_decap (f_kem ciphersuite) ct sk) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] hoist40 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist40)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] th := matchb f_branch (impl_Transcript__transcript_hash tx) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] hoist41 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist41)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb shared_secret_handle := Build_t_Handle (f_name := TLSnames_KEM) (f_alg := f_hash ciphersuite) (f_level := ret_both (0 : int8)) in
    letb ks := set_by_handle ks shared_secret_handle shared_secret in
    letb '(ks,psk_handle) := matchb psk with
    | Option_Some_case bytes =>
      letb bytes := ret_both ((bytes) : (t_Bytes)) in
      letb handle := Build_t_Handle (f_name := TLSnames_PSK) (f_alg := f_hash ciphersuite) (f_level := ret_both (0 : int8)) in
      letb ks := set_by_handle ks handle bytes in
      prod_b (ks,Option_Some handle)
    | Option_None_case  =>
      prod_b (ks,Option_None)
    end in
    letb '(tmp0,out) := derive_hk_handles (f_hash ciphersuite) shared_secret_handle psk_handle th ks in
    letb ks := tmp0 in
    letb hoist43 := out in
    letb hoist44 := f_branch hoist43 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] '(ch_handle,sh_handle,ms_handle) := matchb hoist44 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] hoist42 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist42)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle × t_Handle × t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := derive_hk_ms (f_hash ciphersuite) (f_aead ciphersuite) ch_handle sh_handle ks in
    letb ks := tmp0 in
    letb hoist46 := out in
    letb hoist47 := f_branch hoist46 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] '(chk,shk,cfk,sfk) := matchb hoist47 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8)] hoist45 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist45)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (impl_DuplexCipherStateH__new chk (ret_both (0 : int64)) shk (ret_both (0 : int64)),ClientPostServerHello client_random sr ciphersuite ms_handle cfk sfk tx)) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8).
Fail Next Obligation.

Equations put_server_signature (encrypted_extensions : both t_HandshakeData) (server_certificate : both t_HandshakeData) (server_certificate_verify : both t_HandshakeData) (handshake_state : both t_ClientPostServerHello) : both (t_Result t_ClientPostCertificateVerify int8) :=
  put_server_signature encrypted_extensions server_certificate server_certificate_verify handshake_state  :=
    run (letb ClientPostServerHello (client_random,server_random,algorithms,master_secret_handle,client_finished_key,server_finished_key,transcript) := handshake_state in
    ifb f_not (impl_Algorithms__psk_mode algorithms)
    then letm[choice_typeMonad.result_bind_code int8] _ := parse_encrypted_extensions algorithms encrypted_extensions in
    letb transcript := impl_Transcript__add transcript encrypted_extensions in
    letm[choice_typeMonad.result_bind_code int8] certificate := parse_server_certificate server_certificate in
    letb transcript := impl_Transcript__add transcript server_certificate in
    letm[choice_typeMonad.result_bind_code int8] transcript_hash_server_certificate := impl_Transcript__transcript_hash transcript in
    letm[choice_typeMonad.result_bind_code int8] spki := verification_key_from_cert certificate in
    letm[choice_typeMonad.result_bind_code int8] cert_pk := cert_public_key certificate spki in
    letm[choice_typeMonad.result_bind_code int8] cert_signature := parse_certificate_verify algorithms server_certificate_verify in
    letb sigval := impl_Bytes__concat (impl_Bytes__from_slice (unsize v_PREFIX_SERVER_SIGNATURE)) transcript_hash_server_certificate in
    letm[choice_typeMonad.result_bind_code int8] _ := verify (impl_Algorithms__signature algorithms) cert_pk sigval cert_signature in
    Result_Ok (letb transcript := impl_Transcript__add transcript server_certificate_verify in
    Result_Ok (ClientPostCertificateVerify client_random server_random algorithms master_secret_handle client_finished_key server_finished_key transcript))
    else Result_Ok (Result_Err v_PSK_MODE_MISMATCH)) : both (t_Result t_ClientPostCertificateVerify int8).
Fail Next Obligation.

Equations put_psk_skip_server_signature (encrypted_extensions : both t_HandshakeData) (handshake_state : both t_ClientPostServerHello) : both (t_Result t_ClientPostCertificateVerify int8) :=
  put_psk_skip_server_signature encrypted_extensions handshake_state  :=
    run (letb ClientPostServerHello (client_random,server_random,algorithms,master_secret_handle,client_finished_key,server_finished_key,transcript) := handshake_state in
    ifb impl_Algorithms__psk_mode algorithms
    then letm[choice_typeMonad.result_bind_code int8] _ := parse_encrypted_extensions algorithms encrypted_extensions in
    Result_Ok (letb transcript := impl_Transcript__add transcript encrypted_extensions in
    Result_Ok (ClientPostCertificateVerify client_random server_random algorithms master_secret_handle client_finished_key server_finished_key transcript))
    else Result_Ok (Result_Err v_PSK_MODE_MISMATCH)) : both (t_Result t_ClientPostCertificateVerify int8).
Fail Next Obligation.

(*item error backend*)

Equations get_client_finished (handshake_state : both t_ClientPostServerFinished) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8) :=
  get_client_finished handshake_state ks  :=
    run (letb ClientPostServerFinished (client_random,server_random,algorithms,master_secret_handle,client_finished_key,transcript) := handshake_state in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] transcript_hash := matchb f_branch (impl_Transcript__transcript_hash transcript) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] hoist59 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist59)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] verify_data := matchb f_branch (hmac_tag (impl_Algorithms__hash algorithms) client_finished_key transcript_hash) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] hoist60 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist60)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] client_finished := matchb f_branch (finished verify_data) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] hoist61 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist61)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    letb transcript := impl_Transcript__add transcript client_finished in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] transcript_hash := matchb f_branch (impl_Transcript__transcript_hash transcript) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] hoist62 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist62)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := derive_rms (impl_Algorithms__hash algorithms) master_secret_handle transcript_hash ks in
    letb ks := tmp0 in
    letb hoist64 := out in
    letb hoist65 := f_branch hoist64 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] resumption_master_secret := matchb hoist65 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8)] hoist63 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist63)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (client_finished,ClientPostClientFinished client_random server_random algorithms resumption_master_secret transcript)) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_ClientPostClientFinished) int8).
Fail Next Obligation.

Equations client_init {iimpl_447424039_ : iimpl_447424039_} `{ t_Sized iimpl_447424039_} `{ t_CryptoRng iimpl_447424039_} (algs : both t_Algorithms) (sn : both t_Bytes) (tkt : both (t_Option t_Bytes)) (psk : both (t_Option t_Bytes)) (rng : both iimpl_447424039_) (ks : both t_TLSkeyscheduler) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8) :=
  client_init algs sn tkt psk rng ks  :=
    letb '(tmp0,tmp1,out) := build_client_hello algs sn tkt psk rng ks in
    letb rng := tmp0 in
    letb ks := tmp1 in
    letb hax_temp_output := out in
    prod_b (rng,ks,hax_temp_output) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8).
Fail Next Obligation.

Equations client_set_params (payload : both t_HandshakeData) (st : both t_ClientPostClientHello) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8) :=
  client_set_params payload st ks  :=
    letb '(tmp0,out) := put_server_hello payload st ks in
    letb ks := tmp0 in
    letb hax_temp_output := out in
    prod_b (ks,hax_temp_output) : both (t_TLSkeyscheduler × t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8).
Fail Next Obligation.

Equations client_finish (payload : both t_HandshakeData) (handshake_state : both t_ClientPostServerHello) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8) :=
  client_finish payload handshake_state ks  :=
    run (letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] '(ks,hax_temp_output) := matchb impl_Algorithms__psk_mode (algs_post_server_hello handshake_state) with
    | false =>
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] '(encrypted_extensions,server_certificate,server_certificate_verify,server_finished) := matchb f_branch (impl_HandshakeData__to_four payload) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] hoist66 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist66)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_HandshakeData)) in
        ControlFlow_Continue val
      end in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] client_state_certificate_verify := matchb f_branch (put_server_signature encrypted_extensions server_certificate server_certificate_verify handshake_state) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] hoist67 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist67)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_ClientPostCertificateVerify)) in
        ControlFlow_Continue val
      end in
      letb '(tmp0,out) := put_server_finished server_finished client_state_certificate_verify ks in
      letb ks := tmp0 in
      letb hoist69 := out in
      letb hoist70 := f_branch hoist69 in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] '(cipher,client_state_server_finished) := matchb hoist70 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] hoist68 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist68)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_DuplexCipherState1 × t_ClientPostServerFinished)) in
        ControlFlow_Continue val
      end in
      letb '(tmp0,out) := get_client_finished client_state_server_finished ks in
      letb ks := tmp0 in
      letb hoist72 := out in
      letb hoist73 := f_branch hoist72 in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] '(client_finished,client_state) := matchb hoist73 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] hoist71 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist71)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_HandshakeData × t_ClientPostClientFinished)) in
        ControlFlow_Continue val
      end in
      ControlFlow_Continue (prod_b (ks,Result_Ok (prod_b (client_finished,cipher,client_state))))
    | true =>
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] '(encrypted_extensions,server_finished) := matchb f_branch (impl_HandshakeData__to_two payload) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] hoist74 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist74)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_HandshakeData × t_HandshakeData)) in
        ControlFlow_Continue val
      end in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] client_state_certificate_verify := matchb f_branch (put_psk_skip_server_signature encrypted_extensions handshake_state) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] hoist75 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist75)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_ClientPostCertificateVerify)) in
        ControlFlow_Continue val
      end in
      letb '(tmp0,out) := put_server_finished server_finished client_state_certificate_verify ks in
      letb ks := tmp0 in
      letb hoist77 := out in
      letb hoist78 := f_branch hoist77 in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] '(cipher,client_state_server_finished) := matchb hoist78 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] hoist76 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist76)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_DuplexCipherState1 × t_ClientPostServerFinished)) in
        ControlFlow_Continue val
      end in
      letb '(tmp0,out) := get_client_finished client_state_server_finished ks in
      letb ks := tmp0 in
      letb hoist80 := out in
      letb hoist81 := f_branch hoist80 in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] '(client_finished,client_state) := matchb hoist81 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8)] hoist79 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist79)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_HandshakeData × t_ClientPostClientFinished)) in
        ControlFlow_Continue val
      end in
      ControlFlow_Continue (prod_b (ks,Result_Ok (prod_b (client_finished,cipher,client_state))))
    end in
    ControlFlow_Continue (prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8).
Fail Next Obligation.

Equations process_psk_binder_zero_rtt (ciphersuite : both t_Algorithms) (th_trunc : both t_Bytes) (th : both t_Bytes) (psko : both (t_Option t_Bytes)) (bindero : both (t_Option t_Bytes)) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8) :=
  process_psk_binder_zero_rtt ciphersuite th_trunc th psko bindero ks  :=
    run (letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] '(ks,hax_temp_output) := matchb prod_b (f_psk_mode ciphersuite,psko,bindero) with
    | '(true,Option_Some k,Option_Some binder) =>
      letb psk_handle := Build_t_Handle (f_name := TLSnames_PSK) (f_alg := f_hash ciphersuite) (f_level := ret_both (0 : int8)) in
      letb ks := set_by_handle ks psk_handle (f_clone k) in
      letb '(tmp0,out) := derive_binder_key (f_hash ciphersuite) psk_handle ks in
      letb ks := tmp0 in
      letb hoist90 := out in
      letb hoist91 := f_branch hoist90 in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] mk_handle := matchb hoist91 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] hoist89 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist89)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_Handle)) in
        ControlFlow_Continue val
      end in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] hoist93 := matchb f_branch (tagkey_from_handle ks mk_handle) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] hoist92 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist92)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_TagKey)) in
        ControlFlow_Continue val
      end in
      letb mk := f_val hoist93 in
      letb '(tmp0,out) := v_XPD ks TLSnames_Binder (ret_both (0 : int8)) mk_handle (ret_both (true : 'bool)) th_trunc in
      letb ks := tmp0 in
      letb hoist95 := out in
      letb hoist96 := f_branch hoist95 in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] binder_handle := matchb hoist96 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] hoist94 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist94)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_Handle)) in
        ControlFlow_Continue val
      end in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] hoist98 := matchb f_branch (tagkey_from_handle ks binder_handle) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] hoist97 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist97)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_TagKey)) in
        ControlFlow_Continue val
      end in
      letb binder := f_val hoist98 in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] _ := matchb f_branch (hmac_verify (f_hash ciphersuite) mk th_trunc binder) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] hoist99 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist99)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : ('unit)) in
        ControlFlow_Continue val
      end in
      ifb f_zero_rtt ciphersuite
      then letb '(tmp0,out) := derive_0rtt_keys (f_hash ciphersuite) (f_aead ciphersuite) psk_handle th ks in
      letb ks := tmp0 in
      letb hoist101 := out in
      letb hoist102 := f_branch hoist101 in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] '(key_iv,early_exporter_ms_handle) := matchb hoist102 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] hoist100 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist100)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_AeadKeyIV × t_Handle)) in
        ControlFlow_Continue val
      end in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] early_exporter_ms := matchb f_branch (tagkey_from_handle ks early_exporter_ms_handle) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8)] hoist103 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist103)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_TagKey)) in
        ControlFlow_Continue val
      end in
      ControlFlow_Continue (prod_b (ks,Result_Ok (Option_Some (server_cipher_state0 key_iv (ret_both (0 : int64)) early_exporter_ms))))
      else ControlFlow_Continue (prod_b (ks,Result_Ok Option_None))
    | '(false,Option_None ,Option_None ) =>
      ControlFlow_Continue (prod_b (ks,Result_Ok Option_None))
    | _ =>
      ControlFlow_Continue (prod_b (ks,Result_Err v_PSK_MODE_MISMATCH))
    end in
    ControlFlow_Continue (prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0) int8).
Fail Next Obligation.

Equations put_client_hello (ciphersuite : both t_Algorithms) (ch : both t_HandshakeData) (db : both t_ServerDB) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8) :=
  put_client_hello ciphersuite ch db ks  :=
    run (letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] '(client_randomness,session_id,sni,gx,tkto,bindero,trunc_len) := matchb f_branch (parse_client_hello ciphersuite ch) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] hoist82 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist82)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes × t_Bytes × t_Bytes × t_Bytes × t_Option t_Bytes × t_Option t_Bytes × uint_size)) in
      ControlFlow_Continue val
    end in
    letb tx := impl_Transcript__new (impl_Algorithms__hash ciphersuite) in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] th_trunc := matchb f_branch (impl_Transcript__transcript_hash_without_client_hello tx ch trunc_len) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] hoist83 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist83)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb transcript := impl_Transcript__add tx ch in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] th := matchb f_branch (impl_Transcript__transcript_hash transcript) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] hoist84 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist84)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] server := matchb f_branch (lookup_db ciphersuite db sni tkto) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] hoist85 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist85)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_ServerInfo)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := process_psk_binder_zero_rtt ciphersuite th_trunc th (f_psk_opt server) bindero ks in
    letb ks := tmp0 in
    letb hoist87 := out in
    letb hoist88 := f_branch hoist87 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] cipher0 := matchb hoist88 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8)] hoist86 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist86)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Option t_ServerCipherState0)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (cipher0,Build_t_ServerPostClientHello (f_client_randomness := client_randomness) (f_ciphersuite := ciphersuite) (f_session_id := session_id) (f_gx := gx) (f_server := server) (f_transcript := transcript))) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8).
Fail Next Obligation.

Equations get_server_hello {iimpl_447424039_ : iimpl_447424039_} `{ t_Sized iimpl_447424039_} `{ t_CryptoRng iimpl_447424039_} (state : both t_ServerPostClientHello) (rng : both iimpl_447424039_) (ks : both t_TLSkeyscheduler) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8) :=
  get_server_hello state rng ks  :=
    run (letb server_random := repeat (ret_both (0 : int8)) (ret_both (32 : uint_size)) in
    letb '(tmp0,tmp1) := f_fill_bytes rng server_random in
    letb rng := tmp0 in
    letb server_random := tmp1 in
    letb _ := ret_both (tt : 'unit) in
    letb '(tmp0,out) := kem_encap (f_kem (f_ciphersuite state)) (f_gx state) rng in
    letb rng := tmp0 in
    letb hoist105 := out in
    letb hoist106 := f_branch hoist105 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] '(shared_secret,gy) := matchb hoist106 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] hoist104 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist104)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes × t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb shared_secret_handle := Build_t_Handle (f_name := TLSnames_KEM) (f_alg := f_hash (f_ciphersuite state)) (f_level := ret_both (0 : int8)) in
    letb ks := set_by_handle ks shared_secret_handle shared_secret in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] sh := matchb f_branch (server_hello (f_ciphersuite state) (bytes (unsize server_random)) (f_session_id state) gy) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] hoist107 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist107)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    letb transcript := impl_Transcript__add (f_transcript state) sh in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] transcript_hash := matchb f_branch (impl_Transcript__transcript_hash transcript) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] hoist108 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist108)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb psk_handle := f_clone (f_psk_opt (f_server state)) in
    letb '(ks,psk_handle) := matchb psk_handle with
    | Option_Some_case bytes =>
      letb bytes := ret_both ((bytes) : (t_Bytes)) in
      letb handle := Build_t_Handle (f_name := TLSnames_PSK) (f_alg := f_hash (f_ciphersuite state)) (f_level := ret_both (0 : int8)) in
      letb ks := set_by_handle ks handle bytes in
      prod_b (ks,Option_Some handle)
    | Option_None_case  =>
      prod_b (ks,Option_None)
    end in
    letb '(tmp0,out) := derive_hk_handles (f_hash (f_ciphersuite state)) shared_secret_handle psk_handle transcript_hash ks in
    letb ks := tmp0 in
    letb hoist110 := out in
    letb hoist111 := f_branch hoist110 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] '(ch_handle,sh_handle,ms_handle) := matchb hoist111 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] hoist109 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist109)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle × t_Handle × t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := derive_hk_ms (f_hash (f_ciphersuite state)) (f_aead (f_ciphersuite state)) ch_handle sh_handle ks in
    letb ks := tmp0 in
    letb hoist113 := out in
    letb hoist114 := f_branch hoist113 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] '(chk,shk,cfk,sfk) := matchb hoist114 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] hoist112 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist112)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (sh,impl_DuplexCipherStateH__new shk (ret_both (0 : int64)) chk (ret_both (0 : int64)),Build_t_ServerPostServerHello (f_client_random := f_client_randomness state) (f_server_random := f_into server_random) (f_ciphersuite := f_ciphersuite state) (f_server := f_server state) (f_master_secret := ms_handle) (f_cfk := cfk) (f_sfk := sfk) (f_transcript := transcript))) in
    prod_b (rng,ks,hax_temp_output))) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8).
Fail Next Obligation.

Equations get_rsa_signature {iimpl_447424039_ : iimpl_447424039_} `{ t_Sized iimpl_447424039_} `{ t_CryptoRng iimpl_447424039_} (cert : both t_Bytes) (sk : both t_Bytes) (sigval : both t_Bytes) (rng : both iimpl_447424039_) : both (iimpl_447424039_ × t_Result t_Bytes int8) :=
  get_rsa_signature cert sk sigval rng  :=
    run (letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result t_Bytes int8)] '(cert_scheme,cert_slice) := matchb f_branch (verification_key_from_cert cert) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result t_Bytes int8)] hoist115 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist115)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_SignatureScheme × t_CertificateKey)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result t_Bytes int8)] pk := matchb f_branch (rsa_public_key cert cert_slice) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result t_Bytes int8)] hoist116 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist116)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_RsaVerificationKey)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb '(tmp0,out) := sign_rsa sk (f_modulus pk) (f_exponent pk) cert_scheme sigval rng in
    letb rng := tmp0 in
    letb hax_temp_output := out in
    prod_b (rng,hax_temp_output))) : both (iimpl_447424039_ × t_Result t_Bytes int8).
Fail Next Obligation.

Equations get_server_signature_no_psk {iimpl_447424039_ : iimpl_447424039_} `{ t_Sized iimpl_447424039_} `{ t_CryptoRng iimpl_447424039_} (state : both t_ServerPostServerHello) (rng : both iimpl_447424039_) : both (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8) :=
  get_server_signature_no_psk state rng  :=
    run (letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] ee := matchb f_branch (encrypted_extensions (f_ciphersuite state)) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist117 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist117)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    letb transcript := impl_Transcript__add (f_transcript state) ee in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] sc := matchb f_branch (server_certificate (f_ciphersuite state) (f_cert (f_server state))) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist118 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist118)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    letb transcript := impl_Transcript__add transcript sc in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] transcript_hash := matchb f_branch (impl_Transcript__transcript_hash transcript) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist119 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist119)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb sigval := impl_Bytes__concat (impl_Bytes__from_slice (unsize v_PREFIX_SERVER_SIGNATURE)) transcript_hash in
    letb '(rng,hoist121) := matchb impl_Algorithms__signature (f_ciphersuite state) with
    | SignatureScheme_EcdsaSecp256r1Sha256_case  =>
      letb '(tmp0,out) := sign (impl_Algorithms__signature (f_ciphersuite state)) (f_sk (f_server state)) sigval rng in
      letb rng := tmp0 in
      prod_b (rng,out)
    | SignatureScheme_RsaPssRsaSha256_case  =>
      letb '(tmp0,out) := get_rsa_signature (f_cert (f_server state)) (f_sk (f_server state)) sigval rng in
      letb rng := tmp0 in
      prod_b (rng,out)
    | SignatureScheme_ED25519_case  =>
      prod_b (rng,Result_Err v_UNSUPPORTED_ALGORITHM)
    end in
    letb hoist122 := f_branch hoist121 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] sig := matchb hoist122 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist120 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist120)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] scv := matchb f_branch (certificate_verify (f_ciphersuite state) sig) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist123 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist123)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb transcript := impl_Transcript__add transcript scv in
    letb hax_temp_output := Result_Ok (prod_b (ee,sc,scv,ServerPostCertificateVerify (f_client_random state) (f_server_random state) (f_ciphersuite state) (f_master_secret state) (f_cfk state) (f_sfk state) transcript)) in
    prod_b (rng,hax_temp_output))) : both (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8).
Fail Next Obligation.

Equations get_server_signature {iimpl_447424039_ : iimpl_447424039_} `{ t_Sized iimpl_447424039_} `{ t_CryptoRng iimpl_447424039_} (state : both t_ServerPostServerHello) (rng : both iimpl_447424039_) : both (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8) :=
  get_server_signature state rng  :=
    letb '(rng,hax_temp_output) := ifb f_not (impl_Algorithms__psk_mode (f_ciphersuite state))
    then letb '(tmp0,out) := get_server_signature_no_psk state rng in
    letb rng := tmp0 in
    prod_b (rng,out)
    else prod_b (rng,Result_Err v_PSK_MODE_MISMATCH) in
    prod_b (rng,hax_temp_output) : both (iimpl_447424039_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8).
Fail Next Obligation.

(*item error backend*)

(*item error backend*)

(*item error backend*)

Equations put_client_finished (cfin : both t_HandshakeData) (st : both t_ServerPostServerFinished) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8) :=
  put_client_finished cfin st ks  :=
    run (letb ServerPostServerFinished (cr,sr,algs,ms,cfk,tx) := st in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] th := matchb f_branch (impl_Transcript__transcript_hash tx) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] hoist135 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist135)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] vd := matchb f_branch (parse_finished cfin) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] hoist136 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist136)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] _ := matchb f_branch (hmac_verify (impl_Algorithms__hash algs) cfk th vd) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] hoist137 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist137)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : ('unit)) in
      ControlFlow_Continue val
    end in
    letb tx := impl_Transcript__add tx cfin in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] th := matchb f_branch (impl_Transcript__transcript_hash tx) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] hoist138 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist138)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := derive_rms (impl_Algorithms__hash algs) ms th ks in
    letb ks := tmp0 in
    letb hoist140 := out in
    letb hoist141 := f_branch hoist140 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] rms := matchb hoist141 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8)] hoist139 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist139)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (ServerPostClientFinished cr sr algs rms tx) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8).
Fail Next Obligation.

Equations server_init_no_psk {iimpl_447424039_ : iimpl_447424039_} `{ t_Sized iimpl_447424039_} `{ t_CryptoRng iimpl_447424039_} (algs : both t_Algorithms) (ch : both t_HandshakeData) (db : both t_ServerDB) (rng : both iimpl_447424039_) (ks : both t_TLSkeyscheduler) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8) :=
  server_init_no_psk algs ch db rng ks  :=
    run (letb '(tmp0,out) := put_client_hello algs ch db ks in
    letb ks := tmp0 in
    letb hoist143 := out in
    letb hoist144 := f_branch hoist143 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(cipher0,st) := matchb hoist144 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist142 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist142)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Option t_ServerCipherState0 × t_ServerPostClientHello)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,tmp1,out) := get_server_hello st rng ks in
    letb rng := tmp0 in
    letb ks := tmp1 in
    letb hoist146 := out in
    letb hoist147 := f_branch hoist146 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(sh,cipher_hs,st) := matchb hoist147 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist145 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist145)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := get_server_signature st rng in
    letb rng := tmp0 in
    letb hoist149 := out in
    letb hoist150 := f_branch hoist149 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(ee,sc,scv,st) := matchb hoist150 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist148 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist148)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := get_server_finished st ks in
    letb ks := tmp0 in
    letb hoist152 := out in
    letb hoist153 := f_branch hoist152 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(sfin,cipher1,st) := matchb hoist153 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist151 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist151)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_DuplexCipherState1 × t_ServerPostServerFinished)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb flight := impl_HandshakeData__concat (impl_HandshakeData__concat (impl_HandshakeData__concat ee sc) scv) sfin in
    letb hax_temp_output := Result_Ok (prod_b (sh,flight,cipher0,cipher_hs,cipher1,st)) in
    prod_b (rng,ks,hax_temp_output))) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8).
Fail Next Obligation.

Equations server_init_psk {iimpl_447424039_ : iimpl_447424039_} `{ t_Sized iimpl_447424039_} `{ t_CryptoRng iimpl_447424039_} (algs : both t_Algorithms) (ch : both t_HandshakeData) (db : both t_ServerDB) (rng : both iimpl_447424039_) (ks : both t_TLSkeyscheduler) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8) :=
  server_init_psk algs ch db rng ks  :=
    run (letb '(tmp0,out) := put_client_hello algs ch db ks in
    letb ks := tmp0 in
    letb hoist155 := out in
    letb hoist156 := f_branch hoist155 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(cipher0,st) := matchb hoist156 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist154 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist154)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Option t_ServerCipherState0 × t_ServerPostClientHello)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,tmp1,out) := get_server_hello st rng ks in
    letb rng := tmp0 in
    letb ks := tmp1 in
    letb hoist158 := out in
    letb hoist159 := f_branch hoist158 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(sh,cipher_hs,st) := matchb hoist159 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist157 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist157)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(ee,st) := matchb f_branch (get_skip_server_signature st) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist160 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist160)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_ServerPostCertificateVerify)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := get_server_finished st ks in
    letb ks := tmp0 in
    letb hoist162 := out in
    letb hoist163 := f_branch hoist162 in
    letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(sfin,cipher1,st) := matchb hoist163 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist161 := ControlFlow_Break (prod_b (rng,ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist161)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_DuplexCipherState1 × t_ServerPostServerFinished)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb flight := impl_HandshakeData__concat ee sfin in
    letb hax_temp_output := Result_Ok (prod_b (sh,flight,cipher0,cipher_hs,cipher1,st)) in
    prod_b (rng,ks,hax_temp_output))) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8).
Fail Next Obligation.

Equations server_init {iimpl_447424039_ : iimpl_447424039_} `{ t_Sized iimpl_447424039_} `{ t_CryptoRng iimpl_447424039_} (algs : both t_Algorithms) (ch : both t_HandshakeData) (db : both t_ServerDB) (rng : both iimpl_447424039_) (ks : both t_TLSkeyscheduler) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8) :=
  server_init algs ch db rng ks  :=
    letb '((ks,rng),hax_temp_output) := matchb impl_Algorithms__psk_mode algs with
    | false =>
      letb '(tmp0,tmp1,out) := server_init_no_psk algs ch db rng ks in
      letb rng := tmp0 in
      letb ks := tmp1 in
      prod_b (prod_b (ks,rng),out)
    | true =>
      letb '(tmp0,tmp1,out) := server_init_psk algs ch db rng ks in
      letb rng := tmp0 in
      letb ks := tmp1 in
      prod_b (prod_b (ks,rng),out)
    end in
    prod_b (rng,ks,hax_temp_output) : both (iimpl_447424039_ × t_TLSkeyscheduler × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8).
Fail Next Obligation.

Equations server_finish (cf : both t_HandshakeData) (st : both t_ServerPostServerFinished) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8) :=
  server_finish cf st ks  :=
    letb '(tmp0,out) := put_client_finished cf st ks in
    letb ks := tmp0 in
    letb hax_temp_output := out in
    prod_b (ks,hax_temp_output) : both (t_TLSkeyscheduler × t_Result t_ServerPostClientFinished int8).
Fail Next Obligation.
