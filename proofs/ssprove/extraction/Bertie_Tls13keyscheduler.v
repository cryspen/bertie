(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

(* Require Import hash. *)
(* Export hash. *)

(* Require Import AeadAlgorithm. *)
(* Export AeadAlgorithm. *)

(* Require Import AeadKey. *)
(* Export AeadKey. *)

(* Require Import AeadKeyIV. *)
(* Export AeadKeyIV. *)

(* Require Import Digest. *)
(* Export Digest. *)

(* Require Import HashAlgorithm. *)
(* Export HashAlgorithm. *)

(* Require Import MacKey. *)
(* Export MacKey. *)

(* Require Import Crate_Tls13formats. *)
(* Export Crate_Tls13formats. *)

(* Require Import Crate_Tls13utils. *)
(* Export Crate_Tls13utils. *)

(* Require Import Key_schedule_TLSnames. *)
(* Export Key_schedule_TLSnames. *)

(* Require Import Key_schedule. *)
(* Export Key_schedule. *)

Equations hash_empty (algorithm : both t_HashAlgorithm) : both (t_Result t_Bytes int8) :=
  hash_empty algorithm  :=
    hash algorithm impl_Bytes__new : both (t_Result t_Bytes int8).
Fail Next Obligation.

Equations derive_binder_key (ha : both t_HashAlgorithm) (handle : both t_Handle) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result t_Handle int8) :=
  derive_binder_key ha handle ks  :=
    run (letb '(tmp0,out) := zero_salt ks ha in
    letb ks := tmp0 in
    letb zero_salt_handle := out in
    letb '(tmp0,out) := v_XTR ks (ret_both (0 : int8)) TLSnames_ES handle zero_salt_handle in
    letb ks := tmp0 in
    letb hoist184 := out in
    letb hoist185 := f_branch hoist184 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] early_secret := matchb hoist185 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist183 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist183)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist187 := matchb f_branch (hash_empty ha) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist186 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist186)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb '(tmp0,out) := v_XPD ks TLSnames_Bind (ret_both (0 : int8)) early_secret (ret_both (true : 'bool)) hoist187 in
    letb ks := tmp0 in
    letb hax_temp_output := out in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result t_Handle int8).
Fail Next Obligation.

Equations derive_aead_key_iv (hash_algorithm : both t_HashAlgorithm) (aead_algorithm : both t_AeadAlgorithm) (handle : both t_Handle) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result t_AeadKeyIV int8) :=
  derive_aead_key_iv hash_algorithm aead_algorithm handle ks  :=
    run (letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_AeadKeyIV int8)] hoist189 := matchb f_branch (tagkey_from_handle ks handle) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_AeadKeyIV int8)] hoist188 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist188)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_TagKey)) in
      ControlFlow_Continue val
    end in
    letb key := f_val hoist189 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_AeadKeyIV int8)] sender_write_key := matchb f_branch (hkdf_expand_label hash_algorithm key (bytes (unsize v_LABEL_KEY)) impl_Bytes__new (impl_AeadAlgorithm__key_len aead_algorithm)) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_AeadKeyIV int8)] hoist190 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist190)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_AeadKeyIV int8)] sender_write_iv := matchb f_branch (hkdf_expand_label hash_algorithm key (bytes (unsize v_LABEL_IV)) impl_Bytes__new (impl_AeadAlgorithm__iv_len aead_algorithm)) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_AeadKeyIV int8)] hoist191 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist191)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (impl_AeadKeyIV__new (impl_AeadKey__new sender_write_key aead_algorithm) sender_write_iv) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result t_AeadKeyIV int8).
Fail Next Obligation.

Equations next_keys_c_2_ (hash_algorithm : both t_HashAlgorithm) (handle : both t_Handle) (tx : both t_Bytes) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8) :=
  next_keys_c_2_ hash_algorithm handle tx ks  :=
    run (letb '(tmp0,out) := zero_salt ks hash_algorithm in
    letb ks := tmp0 in
    letb zero_salt_handle := out in
    letb '(tmp0,out) := v_XTR ks (ret_both (0 : int8)) TLSnames_ES handle zero_salt_handle in
    letb ks := tmp0 in
    letb hoist193 := out in
    letb hoist194 := f_branch hoist193 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] early_secret := matchb hoist194 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist192 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist192)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] digest_emp := matchb f_branch (hash_empty hash_algorithm) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist195 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist195)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XPD ks TLSnames_ESalt (ret_both (0 : int8)) early_secret (ret_both (true : 'bool)) digest_emp in
    letb ks := tmp0 in
    letb hoist197 := out in
    letb hoist198 := f_branch hoist197 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] derived_secret := matchb hoist198 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist196 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist196)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XPD ks TLSnames_CET (ret_both (0 : int8)) early_secret (ret_both (true : 'bool)) tx in
    letb ks := tmp0 in
    letb hoist200 := out in
    letb hoist201 := f_branch hoist200 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] client_early_traffic_secret := matchb hoist201 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist199 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist199)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XPD ks TLSnames_EEM (ret_both (0 : int8)) early_secret (ret_both (true : 'bool)) tx in
    letb ks := tmp0 in
    letb hoist203 := out in
    letb hoist204 := f_branch hoist203 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] early_exporter_master_secret := matchb hoist204 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist202 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist202)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (early_exporter_master_secret,client_early_traffic_secret,derived_secret)) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8).
Fail Next Obligation.

Equations derive_0rtt_keys (hash_algorithm : both t_HashAlgorithm) (aead_algorithm : both t_AeadAlgorithm) (handle : both t_Handle) (tx : both t_Bytes) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_Handle) int8) :=
  derive_0rtt_keys hash_algorithm aead_algorithm handle tx ks  :=
    run (letb '(tmp0,out) := next_keys_c_2_ hash_algorithm handle tx ks in
    letb ks := tmp0 in
    letb hoist206 := out in
    letb hoist207 := f_branch hoist206 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_Handle) int8)] '(early_exporter_master_secret,client_early_traffic_secret,derived_secret) := matchb hoist207 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_Handle) int8)] hoist205 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist205)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle × t_Handle × t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := derive_aead_key_iv hash_algorithm aead_algorithm client_early_traffic_secret ks in
    letb ks := tmp0 in
    letb hoist209 := out in
    letb hoist210 := f_branch hoist209 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_Handle) int8)] sender_write_key_iv := matchb hoist210 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_Handle) int8)] hoist208 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist208)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_AeadKeyIV)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (sender_write_key_iv,early_exporter_master_secret)) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_Handle) int8).
Fail Next Obligation.

Equations derive_finished_key (ha : both t_HashAlgorithm) (handle : both t_Handle) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result t_Bytes int8) :=
  derive_finished_key ha handle ks  :=
    run (letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Bytes int8)] k := matchb f_branch (tagkey_from_handle ks handle) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Bytes int8)] hoist211 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist211)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_TagKey)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := hkdf_expand_label ha (f_val k) (bytes (unsize v_LABEL_FINISHED)) impl_Bytes__new (impl_HashAlgorithm__hmac_tag_len ha) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result t_Bytes int8).
Fail Next Obligation.

Equations derive_hk_handles (ha : both t_HashAlgorithm) (shared_secret : both t_Handle) (psko : both (t_Option t_Handle)) (transcript_hash : both t_Bytes) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8) :=
  derive_hk_handles ha shared_secret psko transcript_hash ks  :=
    run (letb '(ks,psk_handle) := matchb psko with
    | Option_Some_case k =>
      letb k := ret_both ((k) : (t_Handle)) in
      prod_b (ks,f_clone k)
    | _ =>
      letb '(tmp0,out) := no_psk ks ha in
      letb ks := tmp0 in
      prod_b (ks,out)
    end in
    letb '(tmp0,out) := zero_salt ks ha in
    letb ks := tmp0 in
    letb zero_salt_handle := out in
    letb '(tmp0,out) := v_XTR ks (ret_both (0 : int8)) TLSnames_ES psk_handle zero_salt_handle in
    letb ks := tmp0 in
    letb hoist213 := out in
    letb hoist214 := f_branch hoist213 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] early_secret := matchb hoist214 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist212 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist212)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] digest_emp := matchb f_branch (hash_empty ha) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist215 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist215)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XPD ks TLSnames_ESalt (ret_both (0 : int8)) early_secret (ret_both (true : 'bool)) digest_emp in
    letb ks := tmp0 in
    letb hoist217 := out in
    letb hoist218 := f_branch hoist217 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] derived_secret := matchb hoist218 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist216 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist216)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XTR ks (ret_both (0 : int8)) TLSnames_HS shared_secret derived_secret in
    letb ks := tmp0 in
    letb hoist220 := out in
    letb hoist221 := f_branch hoist220 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] handshake_secret := matchb hoist221 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist219 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist219)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XPD ks TLSnames_CHT (ret_both (0 : int8)) handshake_secret (ret_both (true : 'bool)) transcript_hash in
    letb ks := tmp0 in
    letb hoist223 := out in
    letb hoist224 := f_branch hoist223 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] client_handshake_traffic_secret := matchb hoist224 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist222 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist222)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XPD ks TLSnames_SHT (ret_both (0 : int8)) handshake_secret (ret_both (true : 'bool)) transcript_hash in
    letb ks := tmp0 in
    letb hoist226 := out in
    letb hoist227 := f_branch hoist226 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] server_handshake_traffic_secret := matchb hoist227 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist225 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist225)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XPD ks TLSnames_HSalt (ret_both (0 : int8)) handshake_secret (ret_both (true : 'bool)) digest_emp in
    letb ks := tmp0 in
    letb hoist229 := out in
    letb hoist230 := f_branch hoist229 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] master_secret_ := matchb hoist230 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist228 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist228)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := zero_ikm ks ha in
    letb ks := tmp0 in
    letb zero_ikm_handle := out in
    letb '(tmp0,out) := v_XTR ks (ret_both (0 : int8)) TLSnames_AS zero_ikm_handle master_secret_ in
    letb ks := tmp0 in
    letb hoist232 := out in
    letb hoist233 := f_branch hoist232 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] master_secret := matchb hoist233 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist231 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist231)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (client_handshake_traffic_secret,server_handshake_traffic_secret,master_secret)) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8).
Fail Next Obligation.

Equations derive_hk_ms (ha : both t_HashAlgorithm) (ae : both t_AeadAlgorithm) (client_handshake_traffic_secret : both t_Handle) (server_handshake_traffic_secret : both t_Handle) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8) :=
  derive_hk_ms ha ae client_handshake_traffic_secret server_handshake_traffic_secret ks  :=
    run (letb '(tmp0,out) := derive_finished_key ha client_handshake_traffic_secret ks in
    letb ks := tmp0 in
    letb hoist235 := out in
    letb hoist236 := f_branch hoist235 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8)] client_finished_key := matchb hoist236 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8)] hoist234 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist234)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := derive_finished_key ha server_handshake_traffic_secret ks in
    letb ks := tmp0 in
    letb hoist238 := out in
    letb hoist239 := f_branch hoist238 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8)] server_finished_key := matchb hoist239 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8)] hoist237 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist237)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := derive_aead_key_iv ha ae client_handshake_traffic_secret ks in
    letb ks := tmp0 in
    letb hoist241 := out in
    letb hoist242 := f_branch hoist241 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8)] client_write_key_iv := matchb hoist242 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8)] hoist240 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist240)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_AeadKeyIV)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := derive_aead_key_iv ha ae server_handshake_traffic_secret ks in
    letb ks := tmp0 in
    letb hoist244 := out in
    letb hoist245 := f_branch hoist244 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8)] server_write_key_iv := matchb hoist245 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8)] hoist243 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist243)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_AeadKeyIV)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (client_write_key_iv,server_write_key_iv,client_finished_key,server_finished_key)) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes) int8).
Fail Next Obligation.

Equations derive_app_handles (ha : both t_HashAlgorithm) (master_secret : both t_Handle) (tx : both t_Bytes) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8) :=
  derive_app_handles ha master_secret tx ks  :=
    run (letb '(tmp0,out) := v_XPD ks TLSnames_CAT (ret_both (0 : int8)) master_secret (ret_both (true : 'bool)) tx in
    letb ks := tmp0 in
    letb hoist247 := out in
    letb hoist248 := f_branch hoist247 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] client_application_traffic_secret_0_ := matchb hoist248 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist246 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist246)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XPD ks TLSnames_SAT (ret_both (0 : int8)) master_secret (ret_both (true : 'bool)) tx in
    letb ks := tmp0 in
    letb hoist250 := out in
    letb hoist251 := f_branch hoist250 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] server_application_traffic_secret_0_ := matchb hoist251 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist249 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist249)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := v_XPD ks TLSnames_EAM (ret_both (0 : int8)) master_secret (ret_both (true : 'bool)) tx in
    letb ks := tmp0 in
    letb hoist253 := out in
    letb hoist254 := f_branch hoist253 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] exporter_master_secret := matchb hoist254 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8)] hoist252 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist252)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Handle)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (client_application_traffic_secret_0_,server_application_traffic_secret_0_,exporter_master_secret)) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_Handle × t_Handle × t_Handle) int8).
Fail Next Obligation.

Equations derive_app_keys (ha : both t_HashAlgorithm) (ae : both t_AeadAlgorithm) (client_application_traffic_secret_0_ : both t_Handle) (server_application_traffic_secret_0_ : both t_Handle) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV) int8) :=
  derive_app_keys ha ae client_application_traffic_secret_0_ server_application_traffic_secret_0_ ks  :=
    run (letb '(tmp0,out) := derive_aead_key_iv ha ae client_application_traffic_secret_0_ ks in
    letb ks := tmp0 in
    letb hoist256 := out in
    letb hoist257 := f_branch hoist256 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV) int8)] client_write_key_iv := matchb hoist257 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV) int8)] hoist255 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist255)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_AeadKeyIV)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := derive_aead_key_iv ha ae server_application_traffic_secret_0_ ks in
    letb ks := tmp0 in
    letb hoist259 := out in
    letb hoist260 := f_branch hoist259 in
    letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV) int8)] server_write_key_iv := matchb hoist260 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV) int8)] hoist258 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist258)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_AeadKeyIV)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (client_write_key_iv,server_write_key_iv)) in
    prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result (t_AeadKeyIV × t_AeadKeyIV) int8).
Fail Next Obligation.

Equations derive_rms (ha : both t_HashAlgorithm) (master_secret : both t_Handle) (tx : both t_Bytes) (ks : both t_TLSkeyscheduler) : both (t_TLSkeyscheduler × t_Result t_Handle int8) :=
  derive_rms ha master_secret tx ks  :=
    letb '(tmp0,out) := v_XPD ks TLSnames_RM (ret_both (0 : int8)) master_secret (ret_both (true : 'bool)) tx in
    letb ks := tmp0 in
    letb hax_temp_output := out in
    prod_b (ks,hax_temp_output) : both (t_TLSkeyscheduler × t_Result t_Handle int8).
Fail Next Obligation.
