(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

From BertieExtraction Require Import Fixes.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Equations v_UNSUPPORTED_ALGORITHM : both int8 :=
  v_UNSUPPORTED_ALGORITHM  :=
    ret_both (1 : int8) : both int8.
Fail Next Obligation.

Equations v_INCORRECT_STATE : both int8 :=
  v_INCORRECT_STATE  :=
    ret_both (128 : int8) : both int8.
Fail Next Obligation.

Equations v_PAYLOAD_TOO_LONG : both int8 :=
  v_PAYLOAD_TOO_LONG  :=
    ret_both (130 : int8) : both int8.
Fail Next Obligation.

Equations v_PSK_MODE_MISMATCH : both int8 :=
  v_PSK_MODE_MISMATCH  :=
    ret_both (131 : int8) : both int8.
Fail Next Obligation.

Equations v_PARSE_FAILED : both int8 :=
  v_PARSE_FAILED  :=
    ret_both (133 : int8) : both int8.
Fail Next Obligation.

Equations parse_failed (_ : both 'unit) : both int8 :=
  parse_failed _  :=
    v_PARSE_FAILED : both int8.
Fail Next Obligation.

Equations v_U16 (x : both int16) : both int16 :=
  v_U16 x  :=
    x : both int16.
Fail Next Obligation.

Definition t_Bytes : choice_type :=
  (t_Vec int8 t_Global).
Equations t_Bytes0 (s : both t_Bytes) : both (t_Vec int8 t_Global) :=
  t_Bytes0 s  :=
    bind_both s (fun x =>
      ret_both (x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_Bytes {t_Bytes0 : both (t_Vec int8 t_Global)} : both (t_Bytes) :=
  Build_t_Bytes  :=
    bind_both t_Bytes0 (fun t_Bytes0 =>
      ret_both ((t_Bytes0) : (t_Bytes))) : both (t_Bytes).
Fail Next Obligation.
#[global] Program Instance t_Bytes_Settable : Settable (both t_Bytes) :=
  let mkT := fun x =>  (bind_both (t_Bytes0 x) (fun t_Bytes0 =>
    ret_both ((t_Bytes0) : (t_Bytes)))) : _ in
  {| mkT := (@mkT)|}.
Admit Obligations.
Fail Next Obligation.

#[global] Program Instance t_Bytes_t_Clone : t_Clone t_Bytes :=
  _.
Fail Next Obligation.
Hint Unfold t_Bytes_t_Clone.

#[global] Program Instance t_Bytes_t_From : t_From (both t_Bytes) (both (t_Vec int8 t_Global)) :=
  let f_from := fun  (x : both (t_Vec int8 t_Global)) => Build_t_Bytes (t_Bytes0 := x) : both t_Bytes in
  {| f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Bytes_t_From.

(* Equations impl_Bytes__declassify (self : both t_Bytes) : both (t_Vec int8 t_Global) := *)
(*   impl_Bytes__declassify self  := *)
(*     f_collect (f_map (impl__iter (f_deref (0 self))) (fun x => *)
(*       f_declassify x)) : both (t_Vec int8 t_Global). *)
(* Fail Next Obligation. *)

(* Equations impl_Bytes__prefix (self : both t_Bytes) (prefix : both (seq int8)) : both t_Bytes := *)
(*   impl_Bytes__prefix self prefix  := *)
(*     letb out := impl__with_capacity ((impl__len prefix) .+ (impl_Bytes__len self)) in *)
(*     letb out := impl_2__extend_from_slice out prefix in *)
(*     letb out := impl_2__extend_from_slice out (f_deref (0 self)) in *)
(*     Bytes out : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations impl_Bytes__as_raw (self : both t_Bytes) : both (seq int8) := *)
(*   impl_Bytes__as_raw self  := *)
(*     f_deref (t_Bytes0 self) : both (seq int8). *)
(* Fail Next Obligation. *)

(* #[global] Program Instance t_Bytes_t_From {v_C : both uint_size} : t_From t_Bytes (nseq int8 (is_pure (v_C))) := *)
(*   let f_from := fun  (x : both (nseq int8 (is_pure (v_C)))) => f_into (impl__to_vec (unsize x)) : both t_Bytes in *)
(*   {| f_from := (@f_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Bytes_t_From. *)

Equations bytes (x : both (seq int8)) : both t_Bytes :=
  bytes x  :=
    f_into x : both t_Bytes.
Fail Next Obligation.

Equations impl_Bytes__new (_ : both 'unit) : both t_Bytes :=
  impl_Bytes__new _  :=
    Build_t_Bytes (t_Bytes0 := impl__new) : both t_Bytes.
Fail Next Obligation.

Equations impl_Bytes__from_slice (s : both (seq int8)) : both t_Bytes :=
  impl_Bytes__from_slice s  :=
    f_into s : both t_Bytes.
Fail Next Obligation.

Definition v_U8 : both uint8 -> both uint8 := id.

Equations impl_Bytes__zeroes (len : both uint_size) : both t_Bytes :=
  impl_Bytes__zeroes len  :=
    Build_t_Bytes (t_Bytes0 := from_elem (v_U8 (ret_both (0 : int8))) len) : both t_Bytes.
Fail Next Obligation.

(* Equations impl_Bytes__concat (self : both t_Bytes) (other : both t_Bytes) : both t_Bytes := *)
(*   impl_Bytes__concat self other  := *)
(*     concat_inner self other : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations eq (b1 : both t_Bytes) (b2 : both t_Bytes) : both 'bool := *)
(*   eq b1 b2  := *)
(*     eq_inner b1 b2 : both 'bool. *)
(* Fail Next Obligation. *)

(* Equations check_eq (b1 : both t_Bytes) (b2 : both t_Bytes) : both (t_Result 'unit int8) := *)
(*   check_eq b1 b2  := *)
(*     check_eq_inner b1 b2 : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations encode_length_u8 (bytes : both (seq int8)) : both (t_Result t_Bytes int8) := *)
(*   encode_length_u8 bytes  := *)
(*     letb len := impl__len bytes in *)
(*     ifb len >=.? (ret_both (256 : uint_size)) *)
(*     then Result_Err v_PAYLOAD_TOO_LONG *)
(*     else letb lenb := impl_Bytes__new_alloc ((ret_both (1 : uint_size)) .+ (impl__len bytes)) in *)
(*     letb lenb := impl_Bytes__push lenb (v_U8 (cast_int (WS2 := _) len)) in *)
(*     letb lenb := Build_t_Bytes[lenb] (0 := impl_2__extend_from_slice (0 lenb) bytes) in *)
(*     Result_Ok lenb : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)
