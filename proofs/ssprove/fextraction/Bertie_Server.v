(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Definition t_ServerDB : choice_type :=
  (t_Bytes × t_Bytes × t_Bytes × t_Option (t_Bytes × t_Bytes)).
Equations f_server_name (s : both t_ServerDB) : both t_Bytes :=
  f_server_name s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_cert (s : both t_ServerDB) : both t_Bytes :=
  f_cert s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_sk (s : both t_ServerDB) : both t_Bytes :=
  f_sk s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_psk_opt (s : both t_ServerDB) : both (t_Option (t_Bytes × t_Bytes)) :=
  f_psk_opt s  :=
    bind_both s (fun x =>
      ret_both (snd x : (t_Option (t_Bytes × t_Bytes)))) : both (t_Option (t_Bytes × t_Bytes)).
Fail Next Obligation.
Equations Build_t_ServerDB {f_server_name : both t_Bytes} {f_cert : both t_Bytes} {f_sk : both t_Bytes} {f_psk_opt : both (t_Option (t_Bytes × t_Bytes))} : both (t_ServerDB) :=
  Build_t_ServerDB  :=
    bind_both f_psk_opt (fun f_psk_opt =>
      bind_both f_sk (fun f_sk =>
        bind_both f_cert (fun f_cert =>
          bind_both f_server_name (fun f_server_name =>
            ret_both ((f_server_name,f_cert,f_sk,f_psk_opt) : (t_ServerDB)))))) : both (t_ServerDB).
Fail Next Obligation.
#[global] Program Instance t_ServerDB_Settable : Settable (both t_ServerDB) :=
  let mkT := fun x =>  (bind_both (f_psk_opt x) (fun f_psk_opt =>
    bind_both (f_sk x) (fun f_sk =>
      bind_both (f_cert x) (fun f_cert =>
        bind_both (f_server_name x) (fun f_server_name =>
          ret_both ((f_server_name,f_cert,f_sk,f_psk_opt) : (t_ServerDB))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Definition t_ServerInfo : choice_type :=
  (t_Bytes × t_Bytes × t_Option t_Bytes).
Equations f_cert (s : both t_ServerInfo) : both t_Bytes :=
  f_cert s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_sk (s : both t_ServerInfo) : both t_Bytes :=
  f_sk s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_psk_opt (s : both t_ServerInfo) : both (t_Option t_Bytes) :=
  f_psk_opt s  :=
    bind_both s (fun x =>
      ret_both (snd x : (t_Option t_Bytes))) : both (t_Option t_Bytes).
Fail Next Obligation.
Equations Build_t_ServerInfo {f_cert : both t_Bytes} {f_sk : both t_Bytes} {f_psk_opt : both (t_Option t_Bytes)} : both (t_ServerInfo) :=
  Build_t_ServerInfo  :=
    bind_both f_psk_opt (fun f_psk_opt =>
      bind_both f_sk (fun f_sk =>
        bind_both f_cert (fun f_cert =>
          ret_both ((f_cert,f_sk,f_psk_opt) : (t_ServerInfo))))) : both (t_ServerInfo).
Fail Next Obligation.
#[global] Program Instance t_ServerInfo_Settable : Settable (both t_ServerInfo) :=
  let mkT := fun x =>  (bind_both (f_psk_opt x) (fun f_psk_opt =>
    bind_both (f_sk x) (fun f_sk =>
      bind_both (f_cert x) (fun f_cert =>
        ret_both ((f_cert,f_sk,f_psk_opt) : (t_ServerInfo)))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Equations lookup_db (ciphersuite : both t_Algorithms) (db : both t_ServerDB) (sni : both t_Bytes) (tkt : both (t_Option t_Bytes)) : both (t_Result t_ServerInfo int8) :=
  lookup_db ciphersuite db sni tkt  :=
    run (ifb orb (eq sni impl_Bytes__new) (eq sni (f_server_name db))
    then matchb prod_b (impl_Algorithms__psk_mode ciphersuite,tkt,f_psk_opt db) with
    | '(true,Option_Some ctkt,Option_Some (stkt,psk)) =>
      letm[choice_typeMonad.result_bind_code int8] _ := check_eq ctkt stkt in
      Result_Ok (letb server := Build_t_ServerInfo (f_cert := f_clone (f_cert db)) (f_sk := f_clone (f_sk db)) (f_psk_opt := Option_Some (f_clone psk)) in
      Result_Ok server)
    | '(false,_,_) =>
      Result_Ok (letb server := Build_t_ServerInfo (f_cert := f_clone (f_cert db)) (f_sk := f_clone (f_sk db)) (f_psk_opt := Option_None) in
      Result_Ok server)
    | _ =>
      Result_Ok (Result_Err v_PSK_MODE_MISMATCH)
    end
    else Result_Ok (Result_Err parse_failed)) : both (t_Result t_ServerInfo int8).
Fail Next Obligation.
