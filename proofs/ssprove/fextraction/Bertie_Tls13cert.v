(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.


   Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Definition t_CertificateKey : choice_type :=
  (uint_size Ã— uint_size).
Equations 0 (s : both t_CertificateKey) : both uint_size :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations 1 (s : both t_CertificateKey) : both uint_size :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_CertificateKey {0 : both uint_size} {1 : both uint_size} : both (t_CertificateKey) :=
  Build_t_CertificateKey  :=
    bind_both 1 (fun 1 =>
      bind_both 0 (fun 0 =>
        ret_both ((0,1) : (t_CertificateKey)))) : both (t_CertificateKey).
Fail Next Obligation.
#[global] Program Instance t_CertificateKey_Settable : Settable (both t_CertificateKey) :=
  let mkT := fun x =>  (bind_both (1 x) (fun 1 =>
    bind_both (0 x) (fun 0 =>
      ret_both ((0,1) : (t_CertificateKey))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Equations rsa_public_key (cert : both t_Bytes) (indices : both t_CertificateKey) : both (t_Result t_RsaVerificationKey int8) :=
  rsa_public_key cert indices  :=
    run (letb CertificateKey (offset,e_len) := indices in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (48 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,e_seq_len) := length cert offset in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (2 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,int_len) := length cert offset in
    letb n := impl_Bytes__slice cert offset int_len in
    letb offset := offset .+ int_len in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (2 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,int_len) := length cert offset in
    Result_Ok (letb e := impl_Bytes__slice cert offset int_len in
    Result_Ok (Build_t_RsaVerificationKey (f_modulus := n) (f_exponent := e)))) : both (t_Result t_RsaVerificationKey int8).
Fail Next Obligation.
