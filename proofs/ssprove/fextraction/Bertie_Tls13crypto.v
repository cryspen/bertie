(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From SSProve Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Require Import Fixes.

Require Import Bertie_Tls13utils.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Definition t_HashAlgorithm : choice_type :=
  ('unit ∐ 'unit ∐ 'unit).
Notation "'HashAlgorithm_SHA256_case'" := (inl (inl tt)) (at level 100).
Equations HashAlgorithm_SHA256 : both t_HashAlgorithm :=
  HashAlgorithm_SHA256  :=
    ret_both (inl (inl (tt : 'unit)) : t_HashAlgorithm) : both t_HashAlgorithm.
Fail Next Obligation.
Notation "'HashAlgorithm_SHA384_case'" := (inl (inr tt)) (at level 100).
Equations HashAlgorithm_SHA384 : both t_HashAlgorithm :=
  HashAlgorithm_SHA384  :=
    ret_both (inl (inr (tt : 'unit)) : t_HashAlgorithm) : both t_HashAlgorithm.
Fail Next Obligation.
Notation "'HashAlgorithm_SHA512_case'" := (inr tt) (at level 100).
Equations HashAlgorithm_SHA512 : both t_HashAlgorithm :=
  HashAlgorithm_SHA512  :=
    ret_both (inr (tt : 'unit) : t_HashAlgorithm) : both t_HashAlgorithm.
Fail Next Obligation.

#[global] Program Instance t_HashAlgorithm_t_Clone : t_Clone t_HashAlgorithm :=
  _.
Fail Next Obligation.
Hint Unfold t_HashAlgorithm_t_Clone.

#[global] Program Instance t_HashAlgorithm_t_PartialEq : t_PartialEq t_HashAlgorithm t_HashAlgorithm :=
  _.
Fail Next Obligation.
Hint Unfold t_HashAlgorithm_t_PartialEq.

#[global] Program Instance t_HashAlgorithm_t_Eq : t_Eq t_HashAlgorithm :=
  _.
Fail Next Obligation.
Hint Unfold t_HashAlgorithm_t_Eq.

(* #[global] Program Instance t_HashAlgorithm_t_Hash : t_Hash t_HashAlgorithm := *)
(*   _. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_HashAlgorithm_t_Hash. *)

Equations impl_Algorithm__hash_len (h : both t_HashAlgorithm) : both uint_size :=
  impl_Algorithm__hash_len h :=
    matchb h with
    | HashAlgorithm_SHA256_case => ret_both 32
    | HashAlgorithm_SHA384_case => ret_both 48
    | HashAlgorithm_SHA512_case => ret_both 64
    end.

Equations impl_HashAlgorithm__hash_len (self : both t_HashAlgorithm) : both uint_size :=
  impl_HashAlgorithm__hash_len self  :=
    matchb self with
    | HashAlgorithm_SHA256_case  =>
      impl_Algorithm__hash_len HashAlgorithm_SHA256
    | HashAlgorithm_SHA384_case  =>
      impl_Algorithm__hash_len HashAlgorithm_SHA384
    | HashAlgorithm_SHA512_case  =>
      impl_Algorithm__hash_len HashAlgorithm_SHA512
    end : both uint_size.
Fail Next Obligation.

(* Equations hmac_tag (alg : both t_HashAlgorithm) (mk : both t_Bytes) (input : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   hmac_tag alg mk input  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist20 := impl_HashAlgorithm__hmac_algorithm alg in *)
(*     Result_Ok (letb hoist21 := hmac hoist20 (f_deref (impl_Bytes__declassify mk)) (f_deref (impl_Bytes__declassify input)) Option_None in *)
(*     letb hoist22 := f_into hoist21 in *)
(*     Result_Ok hoist22)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations hkdf_extract (alg : both t_HashAlgorithm) (ikm : both t_Bytes) (salt : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   hkdf_extract alg ikm salt  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist23 := hkdf_algorithm alg in *)
(*     Result_Ok (letb hoist24 := extract hoist23 (impl_Bytes__declassify salt) (impl_Bytes__declassify ikm) in *)
(*     letb hoist25 := impl__map hoist24 (fun bytes => *)
(*       f_into bytes) in *)
(*     impl__map_err hoist25 (fun _ => *)
(*       v_CRYPTO_ERROR))) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations hkdf_expand (alg : both t_HashAlgorithm) (prk : both t_Bytes) (info : both t_Bytes) (len : both uint_size) : both (t_Result t_Bytes int8) := *)
(*   hkdf_expand alg prk info len  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist26 := hkdf_algorithm alg in *)
(*     Result_Ok (letb hoist27 := expand hoist26 (impl_Bytes__declassify prk) (impl_Bytes__declassify info) len in *)
(*     matchb hoist27 with *)
(*     | Result_Ok_case x => *)
(*       letb x := ret_both ((x) : (t_Vec int8 t_Global)) in *)
(*       Result_Ok (f_into x) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (t_Error)) in *)
(*       tlserr v_CRYPTO_ERROR *)
(*     end)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)
