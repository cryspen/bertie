(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Require Import Bertie_Tls13formats_Handshake_data.
Require Import Bertie_Tls13crypto.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Equations v_LABEL_IV : both (nseq int8 2) :=
  v_LABEL_IV  :=
    array_from_list [ret_both (105 : int8);
      ret_both (118 : int8)] : both (nseq int8 2).
Fail Next Obligation.

Equations v_LABEL_KEY : both (nseq int8 3) :=
  v_LABEL_KEY  :=
    array_from_list [ret_both (107 : int8);
      ret_both (101 : int8);
      ret_both (121 : int8)] : both (nseq int8 3).
Fail Next Obligation.

Equations v_LABEL_TLS13 : both (nseq int8 6) :=
  v_LABEL_TLS13  :=
    array_from_list [ret_both (116 : int8);
      ret_both (108 : int8);
      ret_both (115 : int8);
      ret_both (49 : int8);
      ret_both (51 : int8);
      ret_both (32 : int8)] : both (nseq int8 6).
Fail Next Obligation.

Equations v_LABEL_FINISHED : both (nseq int8 8) :=
  v_LABEL_FINISHED  :=
    array_from_list [ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (110 : int8);
      ret_both (105 : int8);
      ret_both (115 : int8);
      ret_both (104 : int8);
      ret_both (101 : int8);
      ret_both (100 : int8)] : both (nseq int8 8).
Fail Next Obligation.

Equations v_PREFIX_SERVER_SIGNATURE : both (nseq int8 98) :=
  v_PREFIX_SERVER_SIGNATURE  :=
    array_from_list [ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (84 : int8);
      ret_both (76 : int8);
      ret_both (83 : int8);
      ret_both (32 : int8);
      ret_both (49 : int8);
      ret_both (46 : int8);
      ret_both (51 : int8);
      ret_both (44 : int8);
      ret_both (32 : int8);
      ret_both (115 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (118 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (32 : int8);
      ret_both (67 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (116 : int8);
      ret_both (105 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8);
      ret_both (97 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (86 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (105 : int8);
      ret_both (102 : int8);
      ret_both (121 : int8);
      ret_both (0 : int8)] : both (nseq int8 98).
Fail Next Obligation.

(* Equations client_hello (algorithms : both t_Algorithms) (client_random : both t_Bytes) (kem_pk : both t_Bytes) (server_name : both t_Bytes) (session_ticket : both (t_Option t_Bytes)) : both (t_Result (t_HandshakeData × uint_size) int8) := *)
(*   client_hello algorithms client_random kem_pk server_name session_ticket  := *)
(*     run (letb version := bytes2 (ret_both (3 : int8)) (ret_both (3 : int8)) in *)
(*     letb compression_methods := bytes2 (ret_both (1 : int8)) (ret_both (0 : int8)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] legacy_session_id := encode_length_u8 (unsize (repeat (v_U8 (ret_both (0 : int8))) (ret_both (32 : uint_size)))) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist1 := impl_Algorithms__ciphersuite algorithms in *)
(*     letb hoist2 := encode_length_u16 hoist1 in *)
(*     letm[choice_typeMonad.result_bind_code int8] cipher_suites := hoist2 in *)
(*     letm[choice_typeMonad.result_bind_code int8] server_name := build_server_name server_name in *)
(*     letm[choice_typeMonad.result_bind_code int8] supported_versions := supported_versions in *)
(*     letm[choice_typeMonad.result_bind_code int8] supported_groups := supported_groups algorithms in *)
(*     letm[choice_typeMonad.result_bind_code int8] signature_algorithms := signature_algorithms algorithms in *)
(*     letm[choice_typeMonad.result_bind_code int8] key_shares := key_shares algorithms (f_clone kem_pk) in *)
(*     letb len := (impl_Bytes__len server_name) .+ (impl_Bytes__len supported_versions) in *)
(*     letb len := len .+ (impl_Bytes__len supported_groups) in *)
(*     letb len := len .+ (impl_Bytes__len signature_algorithms) in *)
(*     letb len := len .+ (impl_Bytes__len key_shares) in *)
(*     letb out := impl_Bytes__new_alloc len in *)
(*     letb out := impl_Bytes__append out server_name in *)
(*     letb out := impl_Bytes__append out supported_versions in *)
(*     letb out := impl_Bytes__append out supported_groups in *)
(*     letb out := impl_Bytes__append out signature_algorithms in *)
(*     letb out := impl_Bytes__append out key_shares in *)
(*     letb extensions := out in *)
(*     letm[choice_typeMonad.result_bind_code int8] '(trunc_len,extensions) := matchb prod_b (impl_Algorithms__psk_mode algorithms,session_ticket) with *)
(*     | '(true,Option_Some session_ticket) => *)
(*       get_psk_extensions algorithms session_ticket extensions *)
(*     | '(false,Option_None ) => *)
(*       Result_Ok (prod_b (ret_both (0 : uint_size),extensions)) *)
(*     | _ => *)
(*       tlserr v_PSK_MODE_MISMATCH *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code int8] encoded_extensions := encode_length_u16 extensions in *)
(*     letb len := (impl_Bytes__len version) .+ (impl_Bytes__len client_random) in *)
(*     letb len := len .+ (impl_Bytes__len legacy_session_id) in *)
(*     letb len := len .+ (impl_Bytes__len cipher_suites) in *)
(*     letb len := len .+ (impl_Bytes__len compression_methods) in *)
(*     letb len := len .+ (impl_Bytes__len encoded_extensions) in *)
(*     letb out := impl_Bytes__new_alloc len in *)
(*     letb out := impl_Bytes__append out version in *)
(*     letb out := impl_Bytes__append out client_random in *)
(*     letb out := impl_Bytes__append out legacy_session_id in *)
(*     letb out := impl_Bytes__append out cipher_suites in *)
(*     letb out := impl_Bytes__append out compression_methods in *)
(*     letb out := impl_Bytes__append out encoded_extensions in *)
(*     letb handshake_bytes := out in *)
(*     letm[choice_typeMonad.result_bind_code int8] client_hello := impl_HandshakeData__from_bytes HandshakeType_ClientHello handshake_bytes in *)
(*     Result_Ok (Result_Ok (prod_b (client_hello,trunc_len)))) : both (t_Result (t_HandshakeData × uint_size) int8). *)
(* Fail Next Obligation. *)

(* Equations set_client_hello_binder (ciphersuite : both t_Algorithms) (binder : both (t_Option t_Bytes)) (client_hello : both t_HandshakeData) (trunc_len : both (t_Option uint_size)) : both (t_Result t_HandshakeData int8) := *)
(*   set_client_hello_binder ciphersuite binder client_hello trunc_len  := *)
(*     letb HandshakeData ch := client_hello in *)
(*     letb chlen := impl_Bytes__len ch in *)
(*     letb hlen := impl_HashAlgorithm__hash_len (impl_Algorithms__hash ciphersuite) in *)
(*     matchb prod_b (binder,trunc_len) with *)
(*     | '(Option_Some m,Option_Some trunc_len) => *)
(*       ifb (chlen .- trunc_len) =.? hlen *)
(*       then Result_Ok (HandshakeData (impl_Bytes__update_slice ch trunc_len m (ret_both (0 : uint_size)) hlen)) *)
(*       else tlserr parse_failed *)
(*     | '(Option_None ,Option_None ) => *)
(*       Result_Ok (HandshakeData ch) *)
(*     | '(_,_) => *)
(*       tlserr parse_failed *)
(*     end : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations server_hello (algs : both t_Algorithms) (server_random : both t_Bytes) (sid : both t_Bytes) (gy : both t_Bytes) : both (t_Result t_HandshakeData int8) := *)
(*   server_hello algs server_random sid gy  := *)
(*     run (letb ver := bytes2 (ret_both (3 : int8)) (ret_both (3 : int8)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] sid := encode_length_u8 (impl_Bytes__as_raw sid) in *)
(*     letm[choice_typeMonad.result_bind_code int8] cip := impl_Algorithms__ciphersuite algs in *)
(*     letb comp := bytes1 (ret_both (0 : int8)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] ks := server_key_shares algs (f_clone gy) in *)
(*     letm[choice_typeMonad.result_bind_code int8] sv := server_supported_version algs in *)
(*     letb exts := impl_Bytes__concat ks sv in *)
(*     letm[choice_typeMonad.result_bind_code int8] exts := ifb impl_Algorithms__psk_mode algs *)
(*     then letm[choice_typeMonad.result_bind_code int8] hoist3 := server_pre_shared_key algs in *)
(*     Result_Ok (letb hoist4 := impl_Bytes__concat exts hoist3 in *)
(*     letb exts := hoist4 in *)
(*     exts) *)
(*     else Result_Ok exts in *)
(*     letm[choice_typeMonad.result_bind_code int8] encoded_extensions := encode_length_u16 exts in *)
(*     letb len := (impl_Bytes__len ver) .+ (impl_Bytes__len server_random) in *)
(*     letb len := len .+ (impl_Bytes__len sid) in *)
(*     letb len := len .+ (impl_Bytes__len cip) in *)
(*     letb len := len .+ (impl_Bytes__len comp) in *)
(*     letb len := len .+ (impl_Bytes__len encoded_extensions) in *)
(*     letb out := impl_Bytes__new_alloc len in *)
(*     letb out := impl_Bytes__append out ver in *)
(*     letb out := impl_Bytes__append out server_random in *)
(*     letb out := impl_Bytes__append out sid in *)
(*     letb out := impl_Bytes__append out cip in *)
(*     letb out := impl_Bytes__append out comp in *)
(*     letb out := impl_Bytes__append out encoded_extensions in *)
(*     letb hoist5 := out in *)
(*     letb hoist6 := impl_HandshakeData__from_bytes HandshakeType_ServerHello hoist5 in *)
(*     letm[choice_typeMonad.result_bind_code int8] sh := hoist6 in *)
(*     Result_Ok (Result_Ok sh)) : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations encrypted_extensions (e_algs : both t_Algorithms) : both (t_Result t_HandshakeData int8) := *)
(*   encrypted_extensions e_algs  := *)
(*     run (letb handshake_type := bytes1 (cast_int (WS2 := _) (anon_const_HandshakeType_EncryptedExtensions__anon_const_0 .+ (ret_both (0 : int8)))) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist7 := encode_length_u16 impl_Bytes__new in *)
(*     letb hoist8 := encode_length_u24 hoist7 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist9 := hoist8 in *)
(*     Result_Ok (letb hoist10 := impl_Bytes__concat handshake_type hoist9 in *)
(*     letb hoist11 := HandshakeData hoist10 in *)
(*     Result_Ok hoist11)) : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations server_certificate (e_algs : both t_Algorithms) (cert : both t_Bytes) : both (t_Result t_HandshakeData int8) := *)
(*   server_certificate e_algs cert  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] creq := encode_length_u8 (unsize !TODO empty array!) in *)
(*     letm[choice_typeMonad.result_bind_code int8] crt := encode_length_u24 cert in *)
(*     letm[choice_typeMonad.result_bind_code int8] ext := encode_length_u16 impl_Bytes__new in *)
(*     letm[choice_typeMonad.result_bind_code int8] crts := encode_length_u24 (impl_Bytes__concat crt ext) in *)
(*     Result_Ok (impl_HandshakeData__from_bytes HandshakeType_Certificate (impl_Bytes__concat creq crts))) : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations certificate_verify (algs : both t_Algorithms) (cv : both t_Bytes) : both (t_Result t_HandshakeData int8) := *)
(*   certificate_verify algs cv  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] sv := matchb f_signature algs with *)
(*     | SignatureScheme_RsaPssRsaSha256_case  => *)
(*       Result_Ok (f_clone cv) *)
(*     | SignatureScheme_EcdsaSecp256r1Sha256_case  => *)
(*       ifb (impl_Bytes__len cv) <> (ret_both (64 : uint_size)) *)
(*       then Result_Err parse_failed *)
(*       else ecdsa_signature cv *)
(*     | SignatureScheme_ED25519_case  => *)
(*       Result_Err v_UNSUPPORTED_ALGORITHM *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist13 := impl_Algorithms__signature_algorithm algs in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist12 := encode_length_u16 sv in *)
(*     Result_Ok (letb sig := impl_Bytes__concat hoist13 hoist12 in *)
(*     impl_HandshakeData__from_bytes HandshakeType_CertificateVerify sig)) : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations finished (vd : both t_Bytes) : both (t_Result t_HandshakeData int8) := *)
(*   finished vd  := *)
(*     impl_HandshakeData__from_bytes HandshakeType_Finished vd : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

Definition t_Transcript : choice_type :=
  (t_HashAlgorithm × t_HandshakeData).
Equations f_hash_algorithm (s : both t_Transcript) : both t_HashAlgorithm :=
  f_hash_algorithm s  :=
    bind_both s (fun x =>
      ret_both (fst x : t_HashAlgorithm)) : both t_HashAlgorithm.
Fail Next Obligation.
Equations f_transcript (s : both t_Transcript) : both t_HandshakeData :=
  f_transcript s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_HandshakeData)) : both t_HandshakeData.
Fail Next Obligation.
Equations Build_t_Transcript {f_hash_algorithm : both t_HashAlgorithm} {f_transcript : both t_HandshakeData} : both (t_Transcript) :=
  Build_t_Transcript  :=
    bind_both f_transcript (fun f_transcript =>
      bind_both f_hash_algorithm (fun f_hash_algorithm =>
        ret_both ((f_hash_algorithm,f_transcript) : (t_Transcript)))) : both (t_Transcript).
Fail Next Obligation.
#[global] Program Instance t_Transcript_Settable : Settable (both t_Transcript) :=
  let mkT := fun x =>  (bind_both (f_transcript x) (fun f_transcript =>
    bind_both (f_hash_algorithm x) (fun f_hash_algorithm =>
      ret_both ((f_hash_algorithm,f_transcript) : (t_Transcript))))) : _ in
  {| mkT := (@mkT)|}.
Admit Obligations.
Fail Next Obligation.

(* Equations impl_Transcript__new (hash_algorithm : both t_HashAlgorithm) : both t_Transcript := *)
(*   impl_Transcript__new hash_algorithm  := *)
(*     Build_t_Transcript (f_hash_algorithm := hash_algorithm) (f_transcript := Build_t_HandshakeData (t_HandshakeData0 := impl_Bytes__new)) : both t_Transcript. *)
(* Fail Next Obligation. *)

(* Equations impl_Transcript__add (self : both t_Transcript) (msg : both t_HandshakeData) : both t_Transcript := *)
(*   impl_Transcript__add self msg  := *)
(*     letb self := Build_t_Transcript[self] (f_transcript := impl_HandshakeData__concat (f_transcript self) msg) in *)
(*     self : both t_Transcript. *)
(* Fail Next Obligation. *)

(* Equations impl_Transcript__transcript_hash (self : both t_Transcript) : both (t_Result t_Bytes int8) := *)
(*   impl_Transcript__transcript_hash self  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] th := hash (f_hash_algorithm self) (0 (f_transcript self)) in *)
(*     Result_Ok (Result_Ok th)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations impl_Transcript__transcript_hash_without_client_hello (self : both t_Transcript) (client_hello : both t_HandshakeData) (trunc_len : both uint_size) : both (t_Result t_Bytes int8) := *)
(*   impl_Transcript__transcript_hash_without_client_hello self client_hello trunc_len  := *)
(*     letb HandshakeData ch := client_hello in *)
(*     hash (f_hash_algorithm self) (impl_Bytes__concat (f_clone (0 (f_transcript self))) (impl_Bytes__slice_range (0 client_hello) (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := trunc_len)))) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)
