(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(*Not implemented yet? todo(item)*)

(* Require Import hkdf_expand. *)
(* Export hkdf_expand. *)

(* Require Import hkdf_extract. *)
(* Export hkdf_extract. *)

(* Require Import hmac_tag. *)
(* Export hmac_tag. *)

(* Require Import Digest. *)
(* Export Digest. *)

(* Require Import HashAlgorithm. *)
(* Export HashAlgorithm. *)

(* Require Import Key. *)
(* Export Key. *)

Require Import Bertie_Tls13formats.
Export Bertie_Tls13formats.

Require Import Bertie_Tls13utils.
Export Bertie_Tls13utils.

(* Require Import HashMap. *)
(* Export HashMap. *)

(* Require Import vec. *)
(* Export vec. *)

Require Import Bertie_Tls13crypto.
Export Bertie_Tls13crypto.

Require Import Fixes.

(* Equations hkdf_expand_label (hash_algorithm : both t_HashAlgorithm) (key : both t_Bytes) (label : both t_Bytes) (context : both t_Bytes) (len : both uint_size) : both (t_Result t_Bytes int8) := *)
(*   hkdf_expand_label hash_algorithm key label context len  := *)
(*     run (ifb len >=.? (ret_both (65536 : uint_size)) *)
(*     then Result_Ok (Result_Err v_PAYLOAD_TOO_LONG) *)
(*     else letb lenb := u16_as_be_bytes (v_U16 (cast_int (WS2 := _) len)) in *)
(*     letb tls13_label := impl_Bytes__concat (impl_Bytes__from_slice (unsize v_LABEL_TLS13)) label in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist2 := encode_length_u8 (impl_Bytes__as_raw tls13_label) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist1 := encode_length_u8 (impl_Bytes__as_raw context) in *)
(*     Result_Ok (letb hoist3 := impl_Bytes__concat hoist2 hoist1 in *)
(*     letb info := impl_Bytes__prefix hoist3 (unsize lenb) in *)
(*     hkdf_expand hash_algorithm key info len)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

Class t_KeySchedule (Self : choice_type) (v_Self : choice_type) {v_N : choice_type} (* `{ t_Sized v_N} *) := {
  f_labels : (both v_N -> both 'bool -> both (t_Result t_Bytes int8)) ;
  f_prnt_n : (both v_N -> both (t_Option v_N × t_Option v_N)) ;
  f_get : (both v_Self -> both v_N -> both int8 -> both (v_N × t_HashAlgorithm × int8) -> both (t_Option t_Bytes)) ;
  f_set : (both v_Self -> both v_N -> both int8 -> both (v_N × t_HashAlgorithm × int8) -> both t_Bytes -> both v_Self) ;
  f_hash : (both t_Bytes -> both t_Bytes) ;
}.

Definition t_TLSnames : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'TLSnames_ES_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl tt)))))))))))))))))) (at level 100).
Equations TLSnames_ES : both t_TLSnames :=
  TLSnames_ES  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (tt : 'unit)))))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_EEM_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))))) (at level 100).
Equations TLSnames_EEM : both t_TLSnames :=
  TLSnames_EEM  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_CET_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))))) (at level 100).
Equations TLSnames_CET : both t_TLSnames :=
  TLSnames_CET  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_Bind_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))) (at level 100).
Equations TLSnames_Bind : both t_TLSnames :=
  TLSnames_Bind  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_Binder_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))) (at level 100).
Equations TLSnames_Binder : both t_TLSnames :=
  TLSnames_Binder  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_HS_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))) (at level 100).
Equations TLSnames_HS : both t_TLSnames :=
  TLSnames_HS  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_SHT_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))) (at level 100).
Equations TLSnames_SHT : both t_TLSnames :=
  TLSnames_SHT  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_CHT_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))) (at level 100).
Equations TLSnames_CHT : both t_TLSnames :=
  TLSnames_CHT  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_HSalt_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))) (at level 100).
Equations TLSnames_HSalt : both t_TLSnames :=
  TLSnames_HSalt  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_AS_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))) (at level 100).
Equations TLSnames_AS : both t_TLSnames :=
  TLSnames_AS  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_RM_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))) (at level 100).
Equations TLSnames_RM : both t_TLSnames :=
  TLSnames_RM  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_CAT_case'" := (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))) (at level 100).
Equations TLSnames_CAT : both t_TLSnames :=
  TLSnames_CAT  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_SAT_case'" := (inl (inl (inl (inl (inl (inl (inr tt))))))) (at level 100).
Equations TLSnames_SAT : both t_TLSnames :=
  TLSnames_SAT  :=
    ret_both (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_EAM_case'" := (inl (inl (inl (inl (inl (inr tt)))))) (at level 100).
Equations TLSnames_EAM : both t_TLSnames :=
  TLSnames_EAM  :=
    ret_both (inl (inl (inl (inl (inl (inr (tt : 'unit)))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_PSK_case'" := (inl (inl (inl (inl (inr tt))))) (at level 100).
Equations TLSnames_PSK : both t_TLSnames :=
  TLSnames_PSK  :=
    ret_both (inl (inl (inl (inl (inr (tt : 'unit))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_ZeroSalt_case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations TLSnames_ZeroSalt : both t_TLSnames :=
  TLSnames_ZeroSalt  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_ESalt_case'" := (inl (inl (inr tt))) (at level 100).
Equations TLSnames_ESalt : both t_TLSnames :=
  TLSnames_ESalt  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_KEM_case'" := (inl (inr tt)) (at level 100).
Equations TLSnames_KEM : both t_TLSnames :=
  TLSnames_KEM  :=
    ret_both (inl (inr (tt : 'unit)) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_ZeroIKM_case'" := (inr tt) (at level 100).
Equations TLSnames_ZeroIKM : both t_TLSnames :=
  TLSnames_ZeroIKM  :=
    ret_both (inr (tt : 'unit) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.

Definition t_TLSkeyscheduler : choice_type :=
  (t_HashMap (t_TLSnames × t_HashAlgorithm × int8) t_Bytes t_RandomState).
Timeout 1 Equations f_keys (s : both t_TLSkeyscheduler) : both (t_HashMap (t_TLSnames × t_HashAlgorithm × int8) t_Bytes t_RandomState) :=
  f_keys s  :=
    bind_both s (fun x =>
      ret_both (x : (t_HashMap (t_TLSnames × t_HashAlgorithm × int8) t_Bytes t_RandomState))) : both (t_HashMap (t_TLSnames × t_HashAlgorithm × int8) t_Bytes t_RandomState).
Fail Next Obligation.
Timeout 1 Equations Build_t_TLSkeyscheduler {f_keys : both (t_HashMap (t_TLSnames × t_HashAlgorithm × int8) t_Bytes t_RandomState)} : both (t_TLSkeyscheduler) :=
  Build_t_TLSkeyscheduler  :=
    bind_both f_keys (fun f_keys =>
      ret_both ((f_keys) : (t_TLSkeyscheduler))) : both (t_TLSkeyscheduler).
Fail Next Obligation.
Notation "'Build_t_TLSkeyscheduler' '[' x ']' '(' 'f_keys' ':=' y ')'" := (Build_t_TLSkeyscheduler (f_keys := y)).

Equations t_TLSnames_cast_to_repr (x : both t_TLSnames) : both uint_size :=
  t_TLSnames_cast_to_repr x  :=
    matchb x with
    | TLSnames_ES_case  =>
      ret_both (0 : uint_size)
    | TLSnames_EEM_case  =>
      ret_both (1 : uint_size)
    | TLSnames_CET_case  =>
      ret_both (2 : uint_size)
    | TLSnames_Bind_case  =>
      ret_both (3 : uint_size)
    | TLSnames_Binder_case  =>
      ret_both (4 : uint_size)
    | TLSnames_HS_case  =>
      ret_both (5 : uint_size)
    | TLSnames_SHT_case  =>
      ret_both (6 : uint_size)
    | TLSnames_CHT_case  =>
      ret_both (7 : uint_size)
    | TLSnames_HSalt_case  =>
      ret_both (8 : uint_size)
    | TLSnames_AS_case  =>
      ret_both (9 : uint_size)
    | TLSnames_RM_case  =>
      ret_both (10 : uint_size)
    | TLSnames_CAT_case  =>
      ret_both (11 : uint_size)
    | TLSnames_SAT_case  =>
      ret_both (12 : uint_size)
    | TLSnames_EAM_case  =>
      ret_both (13 : uint_size)
    | TLSnames_PSK_case  =>
      ret_both (14 : uint_size)
    | TLSnames_ZeroSalt_case  =>
      ret_both (15 : uint_size)
    | TLSnames_ESalt_case  =>
      ret_both (16 : uint_size)
    | TLSnames_KEM_case  =>
      ret_both (17 : uint_size)
    | TLSnames_ZeroIKM_case  =>
      ret_both (18 : uint_size)
    end : both uint_size.
Fail Next Obligation.

#[global] Program Instance t_TLSnames_t_Clone : t_Clone t_TLSnames :=
  _.
Fail Next Obligation.
Hint Unfold t_TLSnames_t_Clone.

#[global] Program Instance t_TLSnames_t_Copy : t_Copy t_TLSnames :=
  _.
Fail Next Obligation.
Hint Unfold t_TLSnames_t_Copy.

(* #[global] Program Instance t_TLSnames_t_StructuralPartialEq : t_StructuralPartialEq t_TLSnames := *)
(*   _. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_TLSnames_t_StructuralPartialEq. *)

#[global] Program Instance t_TLSnames_t_PartialEq : t_PartialEq t_TLSnames t_TLSnames :=
  _.
Fail Next Obligation.
Hint Unfold t_TLSnames_t_PartialEq.

#[global] Program Instance t_TLSnames_t_Eq : t_Eq t_TLSnames :=
  _.
Fail Next Obligation.
Hint Unfold t_TLSnames_t_Eq.

(* #[global] Program Instance t_TLSnames_t_Hash : t_Hash t_TLSnames := *)
(*   _. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_TLSnames_t_Hash. *)

(* #[global] Program Instance t_TLSnames_t_Debug : t_Debug t_TLSnames := *)
(*   _. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_TLSnames_t_Debug. *)

(* Require Import TLSnames. *)
(* Export TLSnames. *)

Definition t_Label : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'Label_e__e__e__e__e__e___case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl tt)))))))))))) (at level 100).
Equations Label_e__e__e__e__e__e__ : both t_Label :=
  Label_e__e__e__e__e__e__  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (tt : 'unit)))))))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_RES_BINDER_e__case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))) (at level 100).
Equations Label_RES_BINDER_e_ : both t_Label :=
  Label_RES_BINDER_e_  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_EXT_BINDER_e__case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))) (at level 100).
Equations Label_EXT_BINDER_e_ : both t_Label :=
  Label_EXT_BINDER_e_  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_C_E_TRAFFIC__case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))) (at level 100).
Equations Label_C_E_TRAFFIC_ : both t_Label :=
  Label_C_E_TRAFFIC_  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_E_EXP_MASTER_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))) (at level 100).
Equations Label_E_EXP_MASTER : both t_Label :=
  Label_E_EXP_MASTER  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_EXP_MASTER_e__case'" := (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))) (at level 100).
Equations Label_EXP_MASTER_e_ : both t_Label :=
  Label_EXP_MASTER_e_  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_RES_MASTER_e__case'" := (inl (inl (inl (inl (inl (inl (inr tt))))))) (at level 100).
Equations Label_RES_MASTER_e_ : both t_Label :=
  Label_RES_MASTER_e_  :=
    ret_both (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_C_HS_TRAFFIC_case'" := (inl (inl (inl (inl (inl (inr tt)))))) (at level 100).
Equations Label_C_HS_TRAFFIC : both t_Label :=
  Label_C_HS_TRAFFIC  :=
    ret_both (inl (inl (inl (inl (inl (inr (tt : 'unit)))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_S_HS_TRAFFIC_case'" := (inl (inl (inl (inl (inr tt))))) (at level 100).
Equations Label_S_HS_TRAFFIC : both t_Label :=
  Label_S_HS_TRAFFIC  :=
    ret_both (inl (inl (inl (inl (inr (tt : 'unit))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_DERIVED_e__e___case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations Label_DERIVED_e__e__ : both t_Label :=
  Label_DERIVED_e__e__  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_C_AP_TRAFFIC_case'" := (inl (inl (inr tt))) (at level 100).
Equations Label_C_AP_TRAFFIC : both t_Label :=
  Label_C_AP_TRAFFIC  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_S_AP_TRAFFIC_case'" := (inl (inr tt)) (at level 100).
Equations Label_S_AP_TRAFFIC : both t_Label :=
  Label_S_AP_TRAFFIC  :=
    ret_both (inl (inr (tt : 'unit)) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_RESUMPTION_e__case'" := (inr tt) (at level 100).
Equations Label_RESUMPTION_e_ : both t_Label :=
  Label_RESUMPTION_e_  :=
    ret_both (inr (tt : 'unit) : t_Label) : both t_Label.
Fail Next Obligation.

Equations t_Label_cast_to_repr (x : both t_Label) : both uint_size :=
  t_Label_cast_to_repr x  :=
    matchb x with
    | Label_e__e__e__e__e__e___case  =>
      ret_both (0 : uint_size)
    | Label_RES_BINDER_e__case  =>
      ret_both (1 : uint_size)
    | Label_EXT_BINDER_e__case  =>
      ret_both (2 : uint_size)
    | Label_C_E_TRAFFIC__case  =>
      ret_both (3 : uint_size)
    | Label_E_EXP_MASTER_case  =>
      ret_both (4 : uint_size)
    | Label_EXP_MASTER_e__case  =>
      ret_both (5 : uint_size)
    | Label_RES_MASTER_e__case  =>
      ret_both (6 : uint_size)
    | Label_C_HS_TRAFFIC_case  =>
      ret_both (7 : uint_size)
    | Label_S_HS_TRAFFIC_case  =>
      ret_both (8 : uint_size)
    | Label_DERIVED_e__e___case  =>
      ret_both (9 : uint_size)
    | Label_C_AP_TRAFFIC_case  =>
      ret_both (10 : uint_size)
    | Label_S_AP_TRAFFIC_case  =>
      ret_both (11 : uint_size)
    | Label_RESUMPTION_e__case  =>
      ret_both (12 : uint_size)
    end : both uint_size.
Fail Next Obligation.

(* #[global] Program Instance t_Label_t_Debug : t_Debug t_Label := *)
(*   _. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Label_t_Debug. *)

(* #[global] Program Instance t_Label_t_StructuralPartialEq : t_StructuralPartialEq t_Label := *)
(*   _. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Label_t_StructuralPartialEq. *)

#[global] Program Instance t_Label_t_PartialEq : t_PartialEq t_Label t_Label :=
  _.
Fail Next Obligation.
Hint Unfold t_Label_t_PartialEq.

#[global] Program Instance t_Label_t_Eq : t_Eq t_Label :=
  _.
Fail Next Obligation.
Hint Unfold t_Label_t_Eq.

(* Require Import Label. *)
(* Export Label. *)

Equations convert_label (label : both t_Bytes) : both (t_Option t_Label) :=
  convert_label label  :=
    letb l := (impl_Bytes__declassify label)(* .a[RangeFull] *) in
    ifb l =.? array_to_list (array_from_list [ret_both (101 : int8);
      ret_both (120 : int8);
      ret_both (116 : int8);
      ret_both (32 : int8);
      ret_both (98 : int8);
      ret_both (105 : int8);
      ret_both (110 : int8);
      ret_both (100 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_EXT_BINDER_e_
    else ifb l =.? array_to_list (array_from_list [ret_both (114 : int8);
      ret_both (101 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (98 : int8);
      ret_both (105 : int8);
      ret_both (110 : int8);
      ret_both (100 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_RES_BINDER_e_
    else ifb l =.? array_to_list (array_from_list [ret_both (99 : int8);
      ret_both (32 : int8);
      ret_both (101 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_C_E_TRAFFIC_
    else ifb l =.? array_to_list (array_from_list [ret_both (101 : int8);
      ret_both (32 : int8);
      ret_both (101 : int8);
      ret_both (120 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (109 : int8);
      ret_both (97 : int8);
      ret_both (115 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_E_EXP_MASTER
    else ifb l =.? array_to_list (array_from_list [ret_both (99 : int8);
      ret_both (32 : int8);
      ret_both (97 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_C_AP_TRAFFIC
    else ifb l =.? array_to_list (array_from_list [ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (97 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_S_AP_TRAFFIC
    else ifb l =.? array_to_list (array_from_list [ret_both (101 : int8);
      ret_both (120 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (109 : int8);
      ret_both (97 : int8);
      ret_both (115 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_EXP_MASTER_e_
    else ifb l =.? array_to_list (array_from_list [ret_both (114 : int8);
      ret_both (101 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (109 : int8);
      ret_both (97 : int8);
      ret_both (115 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_RES_MASTER_e_
    else ifb l =.? array_to_list (array_from_list [ret_both (100 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (105 : int8);
      ret_both (118 : int8);
      ret_both (101 : int8);
      ret_both (100 : int8)])
    then Option_Some Label_DERIVED_e__e__
    else ifb l =.? array_to_list (array_from_list [ret_both (99 : int8);
      ret_both (32 : int8);
      ret_both (104 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_C_HS_TRAFFIC
    else ifb l =.? array_to_list (array_from_list [ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (104 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_S_HS_TRAFFIC
    else ifb l =.? array_to_list (array_from_list [ret_both (82 : int8);
      ret_both (69 : int8);
      ret_both (83 : int8);
      ret_both (85 : int8);
      ret_both (77 : int8);
      ret_both (80 : int8);
      ret_both (84 : int8);
      ret_both (73 : int8);
      ret_both (79 : int8);
      ret_both (78 : int8)])
    then Option_Some Label_RESUMPTION_e_
    else ifb impl__is_empty l
    then Option_Some Label_e__e__e__e__e__e__
    else Option_None : both (t_Option t_Label).
Fail Next Obligation.

Equations label_to_bytes (label : both t_Label) : both t_Bytes :=
  label_to_bytes label  :=
    matchb label with
    | Label_EXT_BINDER_e__case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (101 : int8);
        ret_both (120 : int8);
        ret_both (116 : int8);
        ret_both (32 : int8);
        ret_both (98 : int8);
        ret_both (105 : int8);
        ret_both (110 : int8);
        ret_both (100 : int8);
        ret_both (101 : int8);
        ret_both (114 : int8)]))))
    | Label_RES_BINDER_e__case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (114 : int8);
        ret_both (101 : int8);
        ret_both (115 : int8);
        ret_both (32 : int8);
        ret_both (98 : int8);
        ret_both (105 : int8);
        ret_both (110 : int8);
        ret_both (100 : int8);
        ret_both (101 : int8);
        ret_both (114 : int8)]))))
    | Label_C_E_TRAFFIC__case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (99 : int8);
        ret_both (32 : int8);
        ret_both (101 : int8);
        ret_both (32 : int8);
        ret_both (116 : int8);
        ret_both (114 : int8);
        ret_both (97 : int8);
        ret_both (102 : int8);
        ret_both (102 : int8);
        ret_both (105 : int8);
        ret_both (99 : int8)]))))
    | Label_E_EXP_MASTER_case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (101 : int8);
        ret_both (32 : int8);
        ret_both (101 : int8);
        ret_both (120 : int8);
        ret_both (112 : int8);
        ret_both (32 : int8);
        ret_both (109 : int8);
        ret_both (97 : int8);
        ret_both (115 : int8);
        ret_both (116 : int8);
        ret_both (101 : int8);
        ret_both (114 : int8)]))))
    | Label_C_AP_TRAFFIC_case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (99 : int8);
        ret_both (32 : int8);
        ret_both (97 : int8);
        ret_both (112 : int8);
        ret_both (32 : int8);
        ret_both (116 : int8);
        ret_both (114 : int8);
        ret_both (97 : int8);
        ret_both (102 : int8);
        ret_both (102 : int8);
        ret_both (105 : int8);
        ret_both (99 : int8)]))))
    | Label_S_AP_TRAFFIC_case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (115 : int8);
        ret_both (32 : int8);
        ret_both (97 : int8);
        ret_both (112 : int8);
        ret_both (32 : int8);
        ret_both (116 : int8);
        ret_both (114 : int8);
        ret_both (97 : int8);
        ret_both (102 : int8);
        ret_both (102 : int8);
        ret_both (105 : int8);
        ret_both (99 : int8)]))))
    | Label_EXP_MASTER_e__case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (101 : int8);
        ret_both (120 : int8);
        ret_both (112 : int8);
        ret_both (32 : int8);
        ret_both (109 : int8);
        ret_both (97 : int8);
        ret_both (115 : int8);
        ret_both (116 : int8);
        ret_both (101 : int8);
        ret_both (114 : int8)]))))
    | Label_RES_MASTER_e__case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (114 : int8);
        ret_both (101 : int8);
        ret_both (115 : int8);
        ret_both (32 : int8);
        ret_both (109 : int8);
        ret_both (97 : int8);
        ret_both (115 : int8);
        ret_both (116 : int8);
        ret_both (101 : int8);
        ret_both (114 : int8)]))))
    | Label_DERIVED_e__e___case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (100 : int8);
        ret_both (101 : int8);
        ret_both (114 : int8);
        ret_both (105 : int8);
        ret_both (118 : int8);
        ret_both (101 : int8);
        ret_both (100 : int8)]))))
    | Label_C_HS_TRAFFIC_case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (99 : int8);
        ret_both (32 : int8);
        ret_both (104 : int8);
        ret_both (115 : int8);
        ret_both (32 : int8);
        ret_both (116 : int8);
        ret_both (114 : int8);
        ret_both (97 : int8);
        ret_both (102 : int8);
        ret_both (102 : int8);
        ret_both (105 : int8);
        ret_both (99 : int8)]))))
    | Label_S_HS_TRAFFIC_case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (115 : int8);
        ret_both (32 : int8);
        ret_both (104 : int8);
        ret_both (115 : int8);
        ret_both (32 : int8);
        ret_both (116 : int8);
        ret_both (114 : int8);
        ret_both (97 : int8);
        ret_both (102 : int8);
        ret_both (102 : int8);
        ret_both (105 : int8);
        ret_both (99 : int8)]))))
    | Label_RESUMPTION_e__case  =>
      f_into (impl__into_vec (unsize (box_new (array_from_list [ret_both (82 : int8);
        ret_both (69 : int8);
        ret_both (83 : int8);
        ret_both (85 : int8);
        ret_both (77 : int8);
        ret_both (80 : int8);
        ret_both (84 : int8);
        ret_both (73 : int8);
        ret_both (79 : int8);
        ret_both (78 : int8)]))))
    | Label_e__e__e__e__e__e___case  =>
      f_into impl__new
end : both t_Bytes.
Next Obligation.
  refine 'nat.
Defined.
Fail Next Obligation.

Axiom hmac_tag : forall (x : both t_HashAlgorithm) (y z : both t_Bytes), both (t_Result t_Bytes uint8).
Axiom hkdf_expand_label : forall (x : both t_HashAlgorithm) (y z w : both t_Bytes) (a : both uint_size), both (t_Result t_Bytes uint8).
Axiom hkdf_extract : forall (x : both t_HashAlgorithm) (y z : both t_Bytes), both (t_Result t_Bytes uint8).
Notation "'impl_2__cloned'" := id.
Axiom impl_2__get : forall {A B : choice_type} (x : both (chMap A B)) (z : both A), both B. (* := *)
  (* bind_both x (fun (y : chMap A B) => *)
(* bind_both z (fun (w : A) => ret_both (fmap.getm y w))). *)
Axiom impl_2__insert : forall {A B : choice_type} (x : both (chMap A B)) (z : both A) (w : both B), both (chProd A (chMap A B)). (* := *)
(* fmap.setm. *)

#[global] Program Instance t_TLSkeyscheduler_t_KeySchedule : t_KeySchedule t_TLSkeyscheduler t_TLSnames :=
  let f_prnt_n := fun  (a : both t_TLSnames) => matchb a with
  | TLSnames_ES_case  =>
    prod_b (Option_Some TLSnames_ZeroSalt,Option_Some TLSnames_PSK)
  | TLSnames_EEM_case =>
    prod_b (Option_Some TLSnames_ES,Option_None)
  | TLSnames_CET_case =>
    prod_b (Option_Some TLSnames_ES,Option_None)
  | TLSnames_Bind_case =>
    prod_b (Option_Some TLSnames_ES,Option_None)
  | TLSnames_Binder_case  =>
    prod_b (Option_Some TLSnames_Bind,Option_None)
  | TLSnames_HS_case  =>
    prod_b (Option_Some TLSnames_ESalt,Option_Some TLSnames_KEM)
  | TLSnames_SHT_case =>
    prod_b (Option_Some TLSnames_HS,Option_None)
  | TLSnames_CHT_case =>
    prod_b (Option_Some TLSnames_HS,Option_None)
  | TLSnames_HSalt_case =>
    prod_b (Option_Some TLSnames_HS,Option_None)
  | TLSnames_AS_case  =>
    prod_b (Option_Some TLSnames_HSalt,Option_Some TLSnames_ZeroIKM)
  | TLSnames_RM_case =>
    prod_b (Option_Some TLSnames_AS,Option_None)
  | TLSnames_CAT_case =>
    prod_b (Option_Some TLSnames_AS,Option_None)
  | TLSnames_SAT_case =>
    prod_b (Option_Some TLSnames_AS,Option_None)
  | TLSnames_EAM_case =>
    prod_b (Option_Some TLSnames_AS,Option_None)
  | TLSnames_PSK_case  =>
    prod_b (Option_Some TLSnames_RM,Option_None)
  | TLSnames_ZeroSalt_case =>
    prod_b (Option_None, Option_None)
  | TLSnames_KEM_case =>
    prod_b (Option_None,Option_None)
  | TLSnames_ZeroIKM_case =>
    prod_b (Option_None,Option_None)
  | TLSnames_ESalt_case  =>
    prod_b (Option_Some TLSnames_ES,Option_None)
  end : both (t_Option t_TLSnames × t_Option t_TLSnames) in
  let f_labels := fun  (a : both t_TLSnames) (b : both 'bool) => run (letm[choice_typeMonad.result_bind_code int8] hoist4 := matchb a with
  | TLSnames_Bind_case  =>
    Result_Ok (ifb b
    then Label_RES_BINDER_e_
    else Label_EXT_BINDER_e_)
  | TLSnames_RM_case  =>
    Result_Ok Label_RES_MASTER_e_
  | TLSnames_ESalt_case  =>
    Result_Ok Label_DERIVED_e__e__
  | TLSnames_HSalt_case  =>
    Result_Ok Label_DERIVED_e__e__
  | TLSnames_EEM_case  =>
    Result_Ok Label_E_EXP_MASTER
  | TLSnames_EAM_case  =>
    Result_Ok Label_E_EXP_MASTER
  | TLSnames_CET_case  =>
    Result_Ok Label_C_E_TRAFFIC_
  | TLSnames_Binder_case  =>
    Result_Ok Label_e__e__e__e__e__e__
  | TLSnames_SHT_case  =>
    Result_Ok Label_S_HS_TRAFFIC
  | TLSnames_CHT_case  =>
    Result_Ok Label_C_HS_TRAFFIC
  | TLSnames_CAT_case  =>
    Result_Ok Label_C_AP_TRAFFIC
  | TLSnames_SAT_case  =>
    Result_Ok Label_S_AP_TRAFFIC
  | _ =>
    Result_Err v_INCORRECT_STATE
  end in
  Result_Ok (letb hoist5 := label_to_bytes hoist4 in
  Result_Ok hoist5)) : both (t_Result t_Bytes int8) in
  let f_get := fun  (self : both t_TLSkeyscheduler) (name : both t_TLSnames) (level : both int8) (h : both (t_TLSnames × t_HashAlgorithm × int8)) => impl_2__cloned (impl_2__get (f_keys self) h) : both (t_Option t_Bytes) in
  let f_set := fun  (self : both t_TLSkeyscheduler) (name : both t_TLSnames) (level : both int8) (h : both (t_TLSnames × t_HashAlgorithm × int8)) (k : both t_Bytes) => letb '(tmp0,out) := impl_2__insert (f_keys self) h k in
  letb self := Build_t_TLSkeyscheduler[self] (f_keys := tmp0) in
  letb _ := out in
  self : both t_TLSkeyscheduler in
  let f_hash := fun  (d : both t_Bytes) => f_clone d : both t_Bytes in
  {| f_prnt_n := (@f_prnt_n);
  f_labels := (@f_labels);
  f_get := (@f_get);
  f_set := (@f_set);
  f_hash := (@f_hash)|}.
Next Obligation.
  refine uint8.
Defined.
Next Obligation.
  unfold t_TLSkeyscheduler_t_KeySchedule_obligation_8.
  unfold t_Result.
  admit.
Admitted.
Next Obligation.
  admit.
Admitted.
Next Obligation.
  admit.
Admitted.
Next Obligation.
  admit.
Admitted.
Next Obligation.
  admit.
Admitted.
Next Obligation.
  admit.
Admitted.
Fail Next Obligation.
Hint Unfold t_TLSkeyscheduler_t_KeySchedule.

Definition t_TagKey : choice_type :=
  (t_HashAlgorithm × t_TLSnames × t_Bytes).
Equations f_TagKey_alg (s : both t_TagKey) : both t_HashAlgorithm :=
  f_TagKey_alg s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : t_HashAlgorithm)) : both t_HashAlgorithm.
Fail Next Obligation.
Equations f_tag (s : both t_TagKey) : both t_TLSnames :=
  f_tag s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_TLSnames)) : both t_TLSnames.
Fail Next Obligation.
Equations f_val (s : both t_TagKey) : both t_Bytes :=
  f_val s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations Build_t_TagKey {f_alg : both t_HashAlgorithm} {f_tag : both t_TLSnames} {f_val : both t_Bytes} : both (t_TagKey) :=
  Build_t_TagKey  :=
    bind_both f_val (fun f_val =>
      bind_both f_tag (fun f_tag =>
        bind_both f_alg (fun f_alg =>
          ret_both ((f_alg,f_tag,f_val) : (t_TagKey))))) : both (t_TagKey).
Fail Next Obligation.
Notation "'Build_t_TagKey' '[' x ']' '(' 'f_alg' ':=' y ')'" := (Build_t_TagKey (f_alg := y) (f_tag := f_tag x) (f_val := f_val x)).
Notation "'Build_t_TagKey' '[' x ']' '(' 'f_tag' ':=' y ')'" := (Build_t_TagKey (f_alg := f_TagKey_alg x) (f_tag := y) (f_val := f_val x)).
Notation "'Build_t_TagKey' '[' x ']' '(' 'f_val' ':=' y ')'" := (Build_t_TagKey (f_alg := f_TagKey_alg x) (f_tag := f_tag x) (f_val := y)).

#[global] Program Instance t_TagKey_t_Clone : t_Clone t_TagKey :=
  _.
Fail Next Obligation.
Hint Unfold t_TagKey_t_Clone.

Equations xtr_alg (alg : both t_HashAlgorithm) (k1 : both t_Bytes) (k2 : both t_Bytes) : both (t_Result t_Bytes int8) :=
  xtr_alg alg k1 k2  :=
    hkdf_extract alg k1 k2 : both (t_Result t_Bytes int8).
Fail Next Obligation.

Equations xpd_alg (alg : both t_HashAlgorithm) (k1 : both t_Bytes) (label : both t_Bytes) (d : both t_Bytes) : both (t_Result t_Bytes int8) :=
  xpd_alg alg k1 label d  :=
    letb kvt := convert_label (f_clone label) in
    ifb kvt =.? (Option_Some Label_e__e__e__e__e__e__)
    then hmac_tag alg k1 d
    else hkdf_expand_label alg k1 label d (impl_HashAlgorithm__hash_len alg) : both (t_Result t_Bytes int8).
Fail Next Obligation.

Equations xtr (k1 : both t_TagKey) (k2 : both t_TagKey) : both (t_Result t_TagKey int8) :=
  xtr k1 k2  :=
    (* run *) (letm[choice_typeMonad.result_bind_code int8] val := xtr_alg (f_TagKey_alg k1) (f_val k1) (f_val k2) in
    (* Result_Ok *) (Result_Ok (Build_t_TagKey (f_alg := f_TagKey_alg k1) (f_tag := f_tag k1) (f_val := val)))) : both (t_Result t_TagKey int8).
Fail Next Obligation.

Equations xpd (k1 : both t_TagKey) (label : both t_Bytes) (d : both t_Bytes) : both (t_Result t_TagKey int8) :=
  xpd k1 label d  :=
    (* run *) (letb alg := f_TagKey_alg (f_clone k1) in
    letb v := f_val (f_clone k1) in
    letm[choice_typeMonad.result_bind_code int8] val := xpd_alg alg v label d in
    (* Result_Ok *) (Result_Ok (Build_t_TagKey (f_tag := f_tag k1) (f_alg := alg) (f_val := val)))) : both (t_Result t_TagKey int8).
Fail Next Obligation.

Definition t_Handle : choice_type :=
  (t_TLSnames × t_HashAlgorithm × int8).
Equations f_name (s : both t_Handle) : both t_TLSnames :=
  f_name s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : t_TLSnames)) : both t_TLSnames.
Fail Next Obligation.
Equations f_Handle_alg (s : both t_Handle) : both t_HashAlgorithm :=
  f_Handle_alg s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_HashAlgorithm)) : both t_HashAlgorithm.
Fail Next Obligation.
Equations f_level (s : both t_Handle) : both int8 :=
  f_level s  :=
    bind_both s (fun x =>
      ret_both (snd x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_Handle {f_name : both t_TLSnames} {f_alg : both t_HashAlgorithm} {f_level : both int8} : both (t_Handle) :=
  Build_t_Handle  :=
    bind_both f_level (fun f_level =>
      bind_both f_alg (fun f_alg =>
        bind_both f_name (fun f_name =>
          ret_both ((f_name,f_alg,f_level) : (t_Handle))))) : both (t_Handle).
Fail Next Obligation.
Notation "'Build_t_Handle' '[' x ']' '(' 'f_name' ':=' y ')'" := (Build_t_Handle (f_name := y) (f_alg := f_Handle_alg x) (f_level := f_level x)).
Notation "'Build_t_Handle' '[' x ']' '(' 'f_alg' ':=' y ')'" := (Build_t_Handle (f_name := f_name x) (f_alg := y) (f_level := f_level x)).
Notation "'Build_t_Handle' '[' x ']' '(' 'f_level' ':=' y ')'" := (Build_t_Handle (f_name := f_name x) (f_alg := f_Handle_alg x) (f_level := y)).

#[global] Program Instance t_Handle_t_Clone : t_Clone t_Handle :=
  _.
Fail Next Obligation.
Hint Unfold t_Handle_t_Clone.

(* #[global] Program Instance t_Handle_t_Debug : t_Debug t_Handle := *)
(*   _. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Handle_t_Debug. *)

Equations xpd_angle (name : both t_TLSnames) (label : both t_Bytes) (parrent_handle : both t_Handle) (args : both t_Bytes) : both (t_Result t_Handle int8) :=
  xpd_angle name label parrent_handle args  :=
    Result_Ok (Build_t_Handle (f_name := name) (f_alg := f_Handle_alg parrent_handle) (f_level := f_level parrent_handle)) : both (t_Result t_Handle int8).
Fail Next Obligation.

(* Equations set_by_handle (ks : both t_TLSkeyscheduler) (handle : both t_Handle) (key : both t_Bytes) : both t_TLSkeyscheduler := *)
(*   set_by_handle ks handle key  := *)
(*     letb ks := f_set ks (f_name handle) (f_level handle) (prod_b (f_name handle,f_Handle_alg handle,f_level handle)) key in *)
(*     ks : both t_TLSkeyscheduler. *)
(* Fail Next Obligation. *)

(* Equations zero_salt (ks : both t_TLSkeyscheduler) (alg : both t_HashAlgorithm) : both (t_TLSkeyscheduler × t_Handle) := *)
(*   zero_salt ks alg  := *)
(*     letb handle := Build_t_Handle (f_alg := alg) (f_name := TLSnames_ZeroSalt) (f_level := ret_both (0 : int8)) in *)
(*     letb ks := set_by_handle ks handle (impl_Bytes__zeroes (ret_both (1 : uint_size))) in *)
(*     letb hax_temp_output := handle in *)
(*     prod_b (ks,hax_temp_output) : both (t_TLSkeyscheduler × t_Handle). *)
(* Fail Next Obligation. *)

(* Equations no_psk (ks : both t_TLSkeyscheduler) (alg : both t_HashAlgorithm) : both (t_TLSkeyscheduler × t_Handle) := *)
(*   no_psk ks alg  := *)
(*     letb handle := Build_t_Handle (f_alg := alg) (f_name := TLSnames_PSK) (f_level := ret_both (0 : int8)) in *)
(*     letb ks := set_by_handle ks handle (impl_Bytes__zeroes (impl_HashAlgorithm__hash_len alg)) in *)
(*     letb hax_temp_output := handle in *)
(*     prod_b (ks,hax_temp_output) : both (t_TLSkeyscheduler × t_Handle). *)
(* Fail Next Obligation. *)

(* Equations zero_ikm (ks : both t_TLSkeyscheduler) (alg : both t_HashAlgorithm) : both (t_TLSkeyscheduler × t_Handle) := *)
(*   zero_ikm ks alg  := *)
(*     letb handle := Build_t_Handle (f_alg := alg) (f_name := TLSnames_ZeroIKM) (f_level := ret_both (0 : int8)) in *)
(*     letb ks := set_by_handle ks handle (impl_Bytes__zeroes (impl_HashAlgorithm__hash_len alg)) in *)
(*     letb hax_temp_output := handle in *)
(*     prod_b (ks,hax_temp_output) : both (t_TLSkeyscheduler × t_Handle). *)
(* Fail Next Obligation. *)

(* Equations get_by_handle (ks : both t_TLSkeyscheduler) (handle : both t_Handle) : both (t_Option t_Bytes) := *)
(*   get_by_handle ks handle  := *)
(*     f_get ks (f_name handle) (f_level handle) (prod_b (f_name handle,f_alg handle,f_level handle)) : both (t_Option t_Bytes). *)
(* Fail Next Obligation. *)

(* Equations tagkey_from_handle (ks : both t_TLSkeyscheduler) (handle : both t_Handle) : both (t_Result t_TagKey int8) := *)
(*   tagkey_from_handle ks handle  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist6 := impl__ok_or (get_by_handle ks handle) v_INCORRECT_STATE in *)
(*     Result_Ok (letb hoist7 := Build_t_TagKey (f_alg := f_alg handle) (f_tag := f_name handle) (f_val := hoist6) in *)
(*     Result_Ok hoist7)) : both (t_Result t_TagKey int8). *)
(* Fail Next Obligation. *)

(* Equations v_XPD (ks : both t_TLSkeyscheduler) (n : both t_TLSnames) (l : both int8) (h1 : both t_Handle) (r : both 'bool) (args : both t_Bytes) : both (t_TLSkeyscheduler × t_Result t_Handle int8) := *)
(*   v_XPD ks n l h1 r args  := *)
(*     run (letb '(n1,_) := f_prnt_n n in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] label := matchb f_branch (f_labels n r) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist8 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist8) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_Bytes)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] h := matchb f_branch (xpd_angle n (f_clone label) h1 args) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist9 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist9) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_Handle)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] n1_unwrap := matchb f_branch (impl__ok_or n1 v_INCORRECT_STATE) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist10 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist10) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_TLSnames)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] k1 := matchb f_branch (impl__ok_or (f_get ks n1_unwrap l (prod_b (f_name h1,f_alg h1,f_level h1))) v_INCORRECT_STATE) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist11 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist11) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_Bytes)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] '(l,(k : t_TagKey)) := ifb n =.? TLSnames_PSK *)
(*     then letb l := l .+ (ret_both (1 : int8)) in *)
(*     matchb f_branch (xpd (Build_t_TagKey (f_alg := f_alg h1) (f_tag := f_name h1) (f_val := k1)) label args) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist12 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (prod_b (l,never_to_any hoist12)) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_TagKey)) in *)
(*       ControlFlow_Continue (prod_b (l,val)) *)
(*     end *)
(*     else letb d := f_hash args in *)
(*     matchb f_branch (xpd (Build_t_TagKey (f_alg := f_alg h1) (f_tag := f_name h1) (f_val := k1)) label d) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist13 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (prod_b (l,never_to_any hoist13)) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_TagKey)) in *)
(*       ControlFlow_Continue (prod_b (l,val)) *)
(*     end in *)
(*     ControlFlow_Continue (letb ks := f_set ks n l (prod_b (f_name h,f_alg h,f_level h)) (f_val k) in *)
(*     letb hax_temp_output := Result_Ok h in *)
(*     prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result t_Handle int8). *)
(* Fail Next Obligation. *)

Equations xtr_angle (name : both t_TLSnames) (left : both t_Handle) (right : both t_Handle) : both (t_Result t_Handle int8) :=
  xtr_angle name left_ right_  :=
    Result_Ok (Build_t_Handle (f_alg := f_Handle_alg left_) (f_name := name) (f_level := f_level left_)) : both (t_Result t_Handle int8).
Fail Next Obligation.

(* Equations v_XTR (ks : both t_TLSkeyscheduler) (level : both int8) (name : both t_TLSnames) (h1 : both t_Handle) (h2 : both t_Handle) : both (t_TLSkeyscheduler × t_Result t_Handle int8) := *)
(*   v_XTR ks level name h1 h2  := *)
(*     run (letb '(n1,n2) := f_prnt_n name in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] h := matchb f_branch (xtr_angle name (f_clone h1) (f_clone h2)) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist14 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist14) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_Handle)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] n1_unwrap := matchb f_branch (impl__ok_or n1 v_INCORRECT_STATE) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist15 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist15) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_TLSnames)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] n2_unwrap := matchb f_branch (impl__ok_or n2 v_INCORRECT_STATE) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist16 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist16) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_TLSnames)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] k1 := matchb f_branch (impl__ok_or (f_get ks n1_unwrap level (prod_b (f_name h1,f_alg h1,f_level h1))) v_INCORRECT_STATE) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist17 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist17) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_Bytes)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] k2 := matchb f_branch (impl__ok_or (f_get ks n2_unwrap level (prod_b (f_name h2,f_alg h2,f_level h2))) v_INCORRECT_STATE) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist18 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist18) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_Bytes)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] k := matchb f_branch (xtr (Build_t_TagKey (f_alg := f_alg h1) (f_tag := f_name h1) (f_val := k1)) (Build_t_TagKey (f_alg := f_alg h2) (f_tag := f_name h2) (f_val := k2))) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (t_TLSkeyscheduler × t_Result t_Handle int8)] hoist19 := ControlFlow_Break (prod_b (ks,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist19) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_TagKey)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     ControlFlow_Continue (letb ks := f_set ks name level (prod_b (f_name h,f_alg h,f_level h)) (f_val k) in *)
(*     letb hax_temp_output := Result_Ok h in *)
(*     prod_b (ks,hax_temp_output))) : both (t_TLSkeyscheduler × t_Result t_Handle int8). *)
(* Fail Next Obligation. *)
