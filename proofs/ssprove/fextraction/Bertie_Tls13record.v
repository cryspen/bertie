(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.


   Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Definition t_ClientCipherState0 : choice_type :=
  (t_AeadAlgorithm × t_AeadKeyIV × int64 × t_TagKey).
Equations 0 (s : both t_ClientCipherState0) : both t_AeadAlgorithm :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst x)) : t_AeadAlgorithm)) : both t_AeadAlgorithm.
Fail Next Obligation.
Equations 1 (s : both t_ClientCipherState0) : both t_AeadKeyIV :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations 2 (s : both t_ClientCipherState0) : both int64 :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : int64)) : both int64.
Fail Next Obligation.
Equations 3 (s : both t_ClientCipherState0) : both t_TagKey :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations Build_t_ClientCipherState0 {0 : both t_AeadAlgorithm} {1 : both t_AeadKeyIV} {2 : both int64} {3 : both t_TagKey} : both (t_ClientCipherState0) :=
  Build_t_ClientCipherState0  :=
    bind_both 3 (fun 3 =>
      bind_both 2 (fun 2 =>
        bind_both 1 (fun 1 =>
          bind_both 0 (fun 0 =>
            ret_both ((0,1,2,3) : (t_ClientCipherState0)))))) : both (t_ClientCipherState0).
Fail Next Obligation.
#[global] Program Instance t_ClientCipherState0_Settable : Settable (both t_ClientCipherState0) :=
  let mkT := fun x =>  (bind_both (3 x) (fun 3 =>
    bind_both (2 x) (fun 2 =>
      bind_both (1 x) (fun 1 =>
        bind_both (0 x) (fun 0 =>
          ret_both ((0,1,2,3) : (t_ClientCipherState0))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Equations client_cipher_state0 (ae : both t_AeadAlgorithm) (kiv : both t_AeadKeyIV) (c : both int64) (k : both t_TagKey) : both t_ClientCipherState0 :=
  client_cipher_state0 ae kiv c k  :=
    ClientCipherState0 ae kiv c k : both t_ClientCipherState0.
Fail Next Obligation.

Definition t_ServerCipherState0 : choice_type :=
  (t_AeadKeyIV × int64 × t_TagKey).
Equations f_key_iv (s : both t_ServerCipherState0) : both t_AeadKeyIV :=
  f_key_iv s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations f_counter (s : both t_ServerCipherState0) : both int64 :=
  f_counter s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : int64)) : both int64.
Fail Next Obligation.
Equations f_early_exporter_ms (s : both t_ServerCipherState0) : both t_TagKey :=
  f_early_exporter_ms s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations Build_t_ServerCipherState0 {f_key_iv : both t_AeadKeyIV} {f_counter : both int64} {f_early_exporter_ms : both t_TagKey} : both (t_ServerCipherState0) :=
  Build_t_ServerCipherState0  :=
    bind_both f_early_exporter_ms (fun f_early_exporter_ms =>
      bind_both f_counter (fun f_counter =>
        bind_both f_key_iv (fun f_key_iv =>
          ret_both ((f_key_iv,f_counter,f_early_exporter_ms) : (t_ServerCipherState0))))) : both (t_ServerCipherState0).
Fail Next Obligation.
#[global] Program Instance t_ServerCipherState0_Settable : Settable (both t_ServerCipherState0) :=
  let mkT := fun x =>  (bind_both (f_early_exporter_ms x) (fun f_early_exporter_ms =>
    bind_both (f_counter x) (fun f_counter =>
      bind_both (f_key_iv x) (fun f_key_iv =>
        ret_both ((f_key_iv,f_counter,f_early_exporter_ms) : (t_ServerCipherState0)))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Equations server_cipher_state0 (key_iv : both t_AeadKeyIV) (counter : both int64) (early_exporter_ms : both t_TagKey) : both t_ServerCipherState0 :=
  server_cipher_state0 key_iv counter early_exporter_ms  :=
    Build_t_ServerCipherState0 (f_key_iv := key_iv) (f_counter := counter) (f_early_exporter_ms := early_exporter_ms) : both t_ServerCipherState0.
Fail Next Obligation.

Definition t_DuplexCipherStateH : choice_type :=
  (t_AeadKeyIV × int64 × t_AeadKeyIV × int64).
Equations f_sender_key_iv (s : both t_DuplexCipherStateH) : both t_AeadKeyIV :=
  f_sender_key_iv s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst x)) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations f_sender_counter (s : both t_DuplexCipherStateH) : both int64 :=
  f_sender_counter s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : int64)) : both int64.
Fail Next Obligation.
Equations f_receiver_key_iv (s : both t_DuplexCipherStateH) : both t_AeadKeyIV :=
  f_receiver_key_iv s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations f_receiver_counter (s : both t_DuplexCipherStateH) : both int64 :=
  f_receiver_counter s  :=
    bind_both s (fun x =>
      ret_both (snd x : int64)) : both int64.
Fail Next Obligation.
Equations Build_t_DuplexCipherStateH {f_sender_key_iv : both t_AeadKeyIV} {f_sender_counter : both int64} {f_receiver_key_iv : both t_AeadKeyIV} {f_receiver_counter : both int64} : both (t_DuplexCipherStateH) :=
  Build_t_DuplexCipherStateH  :=
    bind_both f_receiver_counter (fun f_receiver_counter =>
      bind_both f_receiver_key_iv (fun f_receiver_key_iv =>
        bind_both f_sender_counter (fun f_sender_counter =>
          bind_both f_sender_key_iv (fun f_sender_key_iv =>
            ret_both ((f_sender_key_iv,f_sender_counter,f_receiver_key_iv,f_receiver_counter) : (t_DuplexCipherStateH)))))) : both (t_DuplexCipherStateH).
Fail Next Obligation.
#[global] Program Instance t_DuplexCipherStateH_Settable : Settable (both t_DuplexCipherStateH) :=
  let mkT := fun x =>  (bind_both (f_receiver_counter x) (fun f_receiver_counter =>
    bind_both (f_receiver_key_iv x) (fun f_receiver_key_iv =>
      bind_both (f_sender_counter x) (fun f_sender_counter =>
        bind_both (f_sender_key_iv x) (fun f_sender_key_iv =>
          ret_both ((f_sender_key_iv,f_sender_counter,f_receiver_key_iv,f_receiver_counter) : (t_DuplexCipherStateH))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Equations impl_DuplexCipherStateH__new (sender_key_iv : both t_AeadKeyIV) (sender_counter : both int64) (receiver_key_iv : both t_AeadKeyIV) (receiver_counter : both int64) : both t_DuplexCipherStateH :=
  impl_DuplexCipherStateH__new sender_key_iv sender_counter receiver_key_iv receiver_counter  :=
    Build_t_DuplexCipherStateH (f_sender_key_iv := sender_key_iv) (f_sender_counter := sender_counter) (f_receiver_key_iv := receiver_key_iv) (f_receiver_counter := receiver_counter) : both t_DuplexCipherStateH.
Fail Next Obligation.

Definition t_DuplexCipherState1 : choice_type :=
  (t_AeadAlgorithm × t_AeadKeyIV × int64 × t_AeadKeyIV × int64 × t_TagKey).
Equations 0 (s : both t_DuplexCipherState1) : both t_AeadAlgorithm :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst x)))) : t_AeadAlgorithm)) : both t_AeadAlgorithm.
Fail Next Obligation.
Equations 1 (s : both t_DuplexCipherState1) : both t_AeadKeyIV :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations 2 (s : both t_DuplexCipherState1) : both int64 :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : int64)) : both int64.
Fail Next Obligation.
Equations 3 (s : both t_DuplexCipherState1) : both t_AeadKeyIV :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations 4 (s : both t_DuplexCipherState1) : both int64 :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : int64)) : both int64.
Fail Next Obligation.
Equations 5 (s : both t_DuplexCipherState1) : both t_TagKey :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations Build_t_DuplexCipherState1 {0 : both t_AeadAlgorithm} {1 : both t_AeadKeyIV} {2 : both int64} {3 : both t_AeadKeyIV} {4 : both int64} {5 : both t_TagKey} : both (t_DuplexCipherState1) :=
  Build_t_DuplexCipherState1  :=
    bind_both 5 (fun 5 =>
      bind_both 4 (fun 4 =>
        bind_both 3 (fun 3 =>
          bind_both 2 (fun 2 =>
            bind_both 1 (fun 1 =>
              bind_both 0 (fun 0 =>
                ret_both ((0,1,2,3,4,5) : (t_DuplexCipherState1)))))))) : both (t_DuplexCipherState1).
Fail Next Obligation.
#[global] Program Instance t_DuplexCipherState1_Settable : Settable (both t_DuplexCipherState1) :=
  let mkT := fun x =>  (bind_both (5 x) (fun 5 =>
    bind_both (4 x) (fun 4 =>
      bind_both (3 x) (fun 3 =>
        bind_both (2 x) (fun 2 =>
          bind_both (1 x) (fun 1 =>
            bind_both (0 x) (fun 0 =>
              ret_both ((0,1,2,3,4,5) : (t_DuplexCipherState1))))))))) : _ in
  {| mkT := (@mkT)|}.
Fail Next Obligation.

Equations duplex_cipher_state1 (ae : both t_AeadAlgorithm) (kiv1 : both t_AeadKeyIV) (c1 : both int64) (kiv2 : both t_AeadKeyIV) (c2 : both int64) (k : both t_TagKey) : both t_DuplexCipherState1 :=
  duplex_cipher_state1 ae kiv1 c1 kiv2 c2 k  :=
    DuplexCipherState1 ae kiv1 c1 kiv2 c2 k : both t_DuplexCipherState1.
Fail Next Obligation.
