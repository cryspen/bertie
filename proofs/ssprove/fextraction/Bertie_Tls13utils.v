(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Require Import Fixes.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Equations v_CRYPTO_ERROR : both int8 :=
  v_CRYPTO_ERROR  :=
    ret_both (2 : int8) : both int8.
Fail Next Obligation.

Equations v_INCORRECT_STATE : both int8 :=
  v_INCORRECT_STATE  :=
    ret_both (128 : int8) : both int8.
Fail Next Obligation.

Equations v_PAYLOAD_TOO_LONG : both int8 :=
  v_PAYLOAD_TOO_LONG  :=
    ret_both (130 : int8) : both int8.
Fail Next Obligation.

Equations tlserr {v_T : choice_type} `{ t_Sized v_T} (err : both int8) : both (t_Result v_T int8) :=
  tlserr err  :=
    Result_Err err : both (t_Result v_T int8).
Fail Next Obligation.

Equations v_U16 (x : both int16) : both int16 :=
  v_U16 x  :=
    x : both int16.
Fail Next Obligation.

Definition t_Bytes : choice_type :=
  (t_Vec int8 t_Global).
Equations t_Bytes0 (s : both t_Bytes) : both (t_Vec int8 t_Global) :=
  t_Bytes0 s  :=
    bind_both s (fun x =>
      ret_both (x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_Bytes {t_Bytes0 : both (t_Vec int8 t_Global)} : both (t_Bytes) :=
  Build_t_Bytes  :=
    bind_both t_Bytes0 (fun t_Bytes0 =>
      ret_both ((t_Bytes0) : (t_Bytes))) : both (t_Bytes).
Fail Next Obligation.
Notation "'Build_t_Bytes' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_Bytes (t_Bytes0 := y)).

#[global] Program Instance t_Bytes_t_Clone : t_Clone t_Bytes :=
  _.
Fail Next Obligation.
Hint Unfold t_Bytes_t_Clone.

#[global] Program Instance t_Bytes_t_From : t_From (both t_Bytes) (both (t_Vec int8 t_Global)) :=
  let f_from := fun  (x : both (t_Vec int8 t_Global)) => t_Bytes0 x : both t_Bytes in
  {| f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_Bytes_t_From.

(* Equations impl_Bytes__declassify (self : both t_Bytes) : both (t_Vec int8 t_Global) := *)
(*   impl_Bytes__declassify self  := *)
(*     f_collect (f_map (impl__iter (f_deref (0 self))) (fun x => *)
(*       f_declassify x)) : both (t_Vec int8 t_Global). *)
(* Fail Next Obligation. *)

(* Equations impl_Bytes__prefix (self : both t_Bytes) (prefix : both (seq int8)) : both t_Bytes := *)
(*   impl_Bytes__prefix self prefix  := *)
(*     letb out := impl__with_capacity ((impl__len prefix) .+ (impl_Bytes__len self)) in *)
(*     letb out := impl_2__extend_from_slice out prefix in *)
(*     letb out := impl_2__extend_from_slice out (f_deref (0 self)) in *)
(*     Bytes out : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations impl_Bytes__as_raw (self : both t_Bytes) : both (seq int8) := *)
(*   impl_Bytes__as_raw self  := *)
(*     f_deref (0 self) : both (seq int8). *)
(* Fail Next Obligation. *)

(* Equations u16_as_be_bytes (val : both int16) : both (nseq int8 2) := *)
(*   u16_as_be_bytes val  := *)
(*     letb val := impl_u16__to_be_bytes val in *)
(*     array_from_list [v_U8 (val.a[(ret_both (0 : uint_size))]); *)
(*       v_U8 (val.a[(ret_both (1 : uint_size))])] : both (nseq int8 2). *)
(* Fail Next Obligation. *)

Equations impl_Bytes__from_slice (s : both (seq int8)) : both t_Bytes :=
  impl_Bytes__from_slice s  :=
    f_into s : both t_Bytes.
Fail Next Obligation.

Equations impl_Bytes__zeroes (len : both uint_size) : both t_Bytes :=
  impl_Bytes__zeroes len  :=
    Build_t_Bytes (t_Bytes0 := from_elem ((* v_U8 *) (ret_both (0 : int8))) len) : both t_Bytes.
Fail Next Obligation.

(* Equations impl_Bytes__concat (self : both t_Bytes) (other : both t_Bytes) : both t_Bytes := *)
(*   impl_Bytes__concat self other  := *)
(*     concat_inner self other : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations eq (b1 : both t_Bytes) (b2 : both t_Bytes) : both 'bool := *)
(*   eq b1 b2  := *)
(*     eq_inner b1 b2 : both 'bool. *)
(* Fail Next Obligation. *)

(* Equations encode_length_u8 (bytes : both (seq int8)) : both (t_Result t_Bytes int8) := *)
(*   encode_length_u8 bytes  := *)
(*     letb len := impl__len bytes in *)
(*     ifb len >=.? (ret_both (256 : uint_size)) *)
(*     then Result_Err v_PAYLOAD_TOO_LONG *)
(*     else letb lenb := impl_Bytes__new_alloc ((ret_both (1 : uint_size)) .+ (impl__len bytes)) in *)
(*     letb lenb := impl_Bytes__push lenb (v_U8 (cast_int (WS2 := _) len)) in *)
(*     letb lenb := Build_t_Bytes[lenb] (0 := impl_2__extend_from_slice (0 lenb) bytes) in *)
(*     Result_Ok lenb : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)
