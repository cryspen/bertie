(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Axiom t_String : choice_type.
Class t_From (A B : Type) := {
    f_from : B -> A ;
  }.

Instance sized_int8 : t_Sized int8 := { Sized := id }.
Instance sized_int32 : t_Sized int32 := { Sized := id }.
Instance sized_any {A} : t_Sized A := { Sized := id }.

Axiom string_from_int : both int8 -> both t_String.

Definition impl__u32__from_be_bytes val := bind_both val uint32_from_be_bytes.
Definition impl__u32__to_be_bytes val := bind_both val uint32_to_be_bytes.

(* Definition Pre_uint16_to_be_bytes : int16 -> (nseq_ int8 2) := @Hacspec_Lib_Pre.to_be_bytes jasmin_wsize.U16. *)
(* Definition uint16_to_be_bytes (n : int16) : both ((nseq_ int8 2)) := ret_both (Pre_uint16_to_be_bytes n). *)

Definition impl__u16__to_be_bytes val := bind_both val uint16_to_be_bytes.

(* Definition len {A l} (x : array_or_seq A l) : both uint_size := ret_both l. *)

(* Definition t_Bytes : choice_type := *)
(*   (t_Vec int8 t_Global). *)

Axiom impl__Bytes__declassify : both (t_Vec int8 t_Global) -> both (t_Vec int8 t_Global).
Notation f_deref := id.

Axiom from_elem : forall {A : choice_type} (x : both A) (n : both uint_size), both (t_Vec uint8 t_Global).
(* Axiom from_elem : forall {A : choice_type} (x : both A) (n : both uint_size), both (nseq_ A (is_pure n)). *)

Notation impl__len := len.

Definition impl__new {A : choice_type} : both (t_Vec A t_Global) :=
  ret_both ([] : chList A).

Definition impl__with_capacity {A : choice_type} (n : both uint_size) := @impl__new A.

Module Digest.
Definition t_Algorithm : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).

Notation "'Algorithm_Sha1_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl tt)))))))))) (at level 100).
Equations Algorithm_Sha1 : both t_Algorithm :=
  Algorithm_Sha1  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (tt : 'unit)))))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha224_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))) (at level 100).
Equations Algorithm_Sha224 : both t_Algorithm :=
  Algorithm_Sha224  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha256_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))) (at level 100).
Equations Algorithm_Sha256 : both t_Algorithm :=
  Algorithm_Sha256  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha384_case'" := (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))) (at level 100).
Equations Algorithm_Sha384 : both t_Algorithm :=
  Algorithm_Sha384  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha512_case'" := (inl (inl (inl (inl (inl (inl (inr tt))))))) (at level 100).
Equations Algorithm_Sha512 : both t_Algorithm :=
  Algorithm_Sha512  :=
    ret_both (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Blake2s_case'" := (inl (inl (inl (inl (inl (inr tt)))))) (at level 100).
Equations Algorithm_Blake2s : both t_Algorithm :=
  Algorithm_Blake2s  :=
    ret_both (inl (inl (inl (inl (inl (inr (tt : 'unit)))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Blake2b_case'" := (inl (inl (inl (inl (inr tt))))) (at level 100).
Equations Algorithm_Blake2b : both t_Algorithm :=
  Algorithm_Blake2b  :=
    ret_both (inl (inl (inl (inl (inr (tt : 'unit))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha3_224_case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations Algorithm_Sha3_224 : both t_Algorithm :=
  Algorithm_Sha3_224  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha3_256_case'" := (inl (inl (inr tt))) (at level 100).
Equations Algorithm_Sha3_256 : both t_Algorithm :=
  Algorithm_Sha3_256  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha3_384_case'" := (inl (inr tt)) (at level 100).
Equations Algorithm_Sha3_384 : both t_Algorithm :=
  Algorithm_Sha3_384  :=
    ret_both (inl (inr (tt : 'unit)) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha3_512_case'" := (inr tt) (at level 100).
Equations Algorithm_Sha3_512 : both t_Algorithm :=
  Algorithm_Sha3_512  :=
    ret_both (inr (tt : 'unit) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.

Definition digest_size(mode : both t_Algorithm) : both uint_size :=
  matchb mode with
  | Algorithm_Sha1_case => ret_both 20
  | Algorithm_Sha224_case => ret_both 28
  | Algorithm_Sha256_case => ret_both 32
  | Algorithm_Sha384_case => ret_both 48
  | Algorithm_Sha512_case => ret_both 64
  | Algorithm_Blake2s_case => ret_both 32
  | Algorithm_Blake2b_case => ret_both 64
  | Algorithm_Sha3_224_case => ret_both 28
  | Algorithm_Sha3_256_case => ret_both 32
  | Algorithm_Sha3_384_case => ret_both 48
  | Algorithm_Sha3_512_case => ret_both 64
  end.

Axiom hash : forall (alg: both t_Algorithm) (payload: both (t_Vec int8 t_Global)), both (t_Vec int8 t_Global).

(* // Error?? *)
(*         (* Algorithm::Sha1 => todo!(), *) *)

(* /// Create the digest for the given `data` and mode `alg`. *)
(* /// The output has length [`digest_size(alg)`], i.e. blake2 returns a full-sized *)
(* /// digest. *)
(* /// *)
(* /// Note that this will return a vector on the heap. Use functions like [`sha2_256`] *)
(* /// if you want an array. *)
(* pub fn hash(alg: Algorithm, payload: &[u8]) -> Vec<u8> { *)
(*     // Note that one-shot hacl functions are slower than streaming. *)
(*     // So we only use streaming. *)
(*     match alg { *)
(*         Algorithm::Sha1 => todo!(), *)
(*         Algorithm::Sha224 => sha2::sha224(payload).into(), *)
(*         Algorithm::Sha256 => sha2::sha256(payload).into(), *)
(*         Algorithm::Sha384 => sha2::sha384(payload).into(), *)
(*         Algorithm::Sha512 => sha2::sha512(payload).into(), *)
(*         Algorithm::Blake2s => blake2s(payload, &[]), *)
(*         Algorithm::Blake2b => blake2b(payload, &[]), *)
(*         Algorithm::Sha3_224 => sha3_224(payload).into(), *)
(*         Algorithm::Sha3_256 => sha3_256(payload).into(), *)
(*         Algorithm::Sha3_384 => sha3_384(payload).into(), *)
(*         Algorithm::Sha3_512 => sha3_512(payload).into(), *)
(*     } *)
(* } *)

End Digest.

Module Hkdf.
Definition t_Algorithm : choice_type :=
  ('unit ∐ 'unit ∐ 'unit).

Notation "'Algorithm_Sha256_case'" := (inl (inl tt)) (at level 100).
Equations Algorithm_Sha256 : both t_Algorithm :=
  Algorithm_Sha256  :=
    ret_both (inl (inl (tt : 'unit)) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha384_case'" := (inl (inr tt)) (at level 100).
Equations Algorithm_Sha384 : both t_Algorithm :=
  Algorithm_Sha384  :=
    ret_both (inl (inr (tt : 'unit)) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Sha512_case'" := (inr tt) (at level 100).
Equations Algorithm_Sha512 : both t_Algorithm :=
  Algorithm_Sha512  :=
    ret_both (inr (tt : 'unit) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.

Definition t_Error : choice_type := 'unit.
Notation "'Error_OkmLengthTooLarge_case'" := (inl (inl tt)) (at level 100).
Equations Error_OkmLengthTooLarge : both t_Error :=
  Error_OkmLengthTooLarge  :=
    ret_both ((tt : 'unit) : t_Error) : both t_Error.
Fail Next Obligation.

Axiom expand : forall (alg : both t_Algorithm) (prk : both (t_Vec int8 t_Global)) (info : both (t_Vec int8 t_Global)) (okm_len : both uint_size), both (t_Result (t_Vec int8 t_Global) (t_Error)).
(* /// HKDF expand using hash function `mode`, pre-key material `prk`, `info`, and output length `okm_len`. *)
(* /// Returns the key material in a vector of length `okm_len` or [`Error::OkmLengthTooLarge`] *)
(* /// if the requested output length is too large. *)
(* pub fn expand( *)
(*     alg: Algorithm, *)
(*     prk: impl AsRef<[u8]>, *)
(*     info: impl AsRef<[u8]>, *)
(*     okm_len: usize, *)
(* ) -> Result<Vec<u8>, Error> { *)
(*     match alg { *)
(*         Algorithm::Sha256 => { *)
(*             crate::hacl::hkdf::sha2_256::vec::expand(prk.as_ref(), info.as_ref(), okm_len) *)
(*                 .map_err(|_| Error::OkmLengthTooLarge) *)
(*         } *)
(*         Algorithm::Sha384 => { *)
(*             crate::hacl::hkdf::sha2_384::vec::expand(prk.as_ref(), info.as_ref(), okm_len) *)
(*                 .map_err(|_| Error::OkmLengthTooLarge) *)
(*         } *)
(*         Algorithm::Sha512 => { *)
(*             crate::hacl::hkdf::sha2_512::vec::expand(prk.as_ref(), info.as_ref(), okm_len) *)
(*                 .map_err(|_| Error::OkmLengthTooLarge) *)
(*         } *)
(*     } *)
(* } *)

Axiom extract : forall (alg : both t_Algorithm) (salt : both (t_Vec int8 t_Global)) (ikm : both (t_Vec int8 t_Global)), both (t_Result (t_Vec int8 t_Global) (t_Error)).
(* /// HKDF extract using hash function `mode`, `salt`, and the input key material `ikm`. *)
(* /// Returns the pre-key material in a vector of tag length. *)
(* pub fn extract(alg: Algorithm, salt: impl AsRef<[u8]>, ikm: impl AsRef<[u8]>) -> Vec<u8> { *)
(*     match alg { *)
(*         Algorithm::Sha256 => { *)
(*             crate::hacl::hkdf::sha2_256::extract(salt.as_ref(), ikm.as_ref()).into() *)
(*         } *)
(*         Algorithm::Sha384 => { *)
(*             crate::hacl::hkdf::sha2_384::extract(salt.as_ref(), ikm.as_ref()).into() *)
(*         } *)
(*         Algorithm::Sha512 => { *)
(*             crate::hacl::hkdf::sha2_512::extract(salt.as_ref(), ikm.as_ref()).into() *)
(*         } *)
(*     } *)
(* } *)

End Hkdf.


Module Signature.
Definition t_DigestAlgorithm : choice_type :=
  ('unit ∐ 'unit ∐ 'unit).
Notation "'DigestAlgorithm_Sha256_case'" := (inl (inl tt)) (at level 100).
Equations DigestAlgorithm_Sha256 : both t_DigestAlgorithm :=
  DigestAlgorithm_Sha256  :=
    ret_both (inl (inl (tt : 'unit)) : t_DigestAlgorithm) : both t_DigestAlgorithm.
Fail Next Obligation.
Notation "'DigestAlgorithm_Sha384_case'" := (inl (inr tt)) (at level 100).
Equations DigestAlgorithm_Sha384 : both t_DigestAlgorithm :=
  DigestAlgorithm_Sha384  :=
    ret_both (inl (inr (tt : 'unit)) : t_DigestAlgorithm) : both t_DigestAlgorithm.
Fail Next Obligation.
Notation "'DigestAlgorithm_Sha512_case'" := (inr tt) (at level 100).
Equations DigestAlgorithm_Sha512 : both t_DigestAlgorithm :=
  DigestAlgorithm_Sha512  :=
    ret_both (inr (tt : 'unit) : t_DigestAlgorithm) : both t_DigestAlgorithm.
Fail Next Obligation.


Definition t_Algorithm : choice_type :=
  (t_DigestAlgorithm ∐ 'unit ∐ t_DigestAlgorithm).
Notation "'Algorithm_EcDsaP256_case' x" := (inl (inl x)) (at level 100).
Equations Algorithm_EcDsaP256 (x : both t_DigestAlgorithm) : both t_Algorithm :=
  Algorithm_EcDsaP256 x :=
    bind_both x (fun x =>
    ret_both (inl (inl x) : t_Algorithm)) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_RsaPss_case'" := (inl (inr tt)) (at level 100).
Equations Algorithm_Ed25519 : both t_Algorithm :=
  Algorithm_Ed25519 :=
    ret_both (inl (inr (tt : 'unit)) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_RsaPss_case' x" := (inr x) (at level 100).
Equations Algorithm_RsaPss (x : both t_DigestAlgorithm) : both t_Algorithm :=
  Algorithm_RsaPss x :=
    bind_both x (fun x =>
    ret_both (inr x : t_Algorithm)) : both t_Algorithm.
Fail Next Obligation.
End Signature.

Module Libcrux_kem.
Definition t_Algorithm : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).

Notation "'Algorithm_X25519_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl tt))))))))))) (at level 100).
Equations Algorithm_X25519 : both t_Algorithm :=
  Algorithm_X25519  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (tt : 'unit))))))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_X448_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))) (at level 100).
Equations Algorithm_X448 : both t_Algorithm :=
  Algorithm_X448  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Secp256r1_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))) (at level 100).
Equations Algorithm_Secp256r1 : both t_Algorithm :=
  Algorithm_Secp256r1  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Secp384r1_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))) (at level 100).
Equations Algorithm_Secp384r1 : both t_Algorithm :=
  Algorithm_Secp384r1  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_Secp521r1_case'" := (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))) (at level 100).
Equations Algorithm_Secp521r1 : both t_Algorithm :=
  Algorithm_Secp521r1  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_MlKem512_case'" := (inl (inl (inl (inl (inl (inl (inr tt))))))) (at level 100).
Equations Algorithm_MlKem512 : both t_Algorithm :=
  Algorithm_MlKem512  :=
    ret_both (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_MlKem768_case'" := (inl (inl (inl (inl (inl (inr tt)))))) (at level 100).
Equations Algorithm_MlKem768 : both t_Algorithm :=
  Algorithm_MlKem768  :=
    ret_both (inl (inl (inl (inl (inl (inr (tt : 'unit)))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_X25519MlKem768Draft00_case'" := (inl (inl (inl (inl (inr tt))))) (at level 100).
Equations Algorithm_X25519MlKem768Draft00 : both t_Algorithm :=
  Algorithm_X25519MlKem768Draft00  :=
    ret_both (inl (inl (inl (inl (inr (tt : 'unit))))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_XWingKemDraft02_case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations Algorithm_XWingKemDraft02 : both t_Algorithm :=
  Algorithm_XWingKemDraft02  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_X25519Kyber768Draft00_case'" := (inl (inl (inr tt))) (at level 100).
Equations Algorithm_X25519Kyber768Draft00 : both t_Algorithm :=
  Algorithm_X25519Kyber768Draft00  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_XWingKyberDraft02_case'" := (inl (inr tt)) (at level 100).
Equations Algorithm_XWingKyberDraft02 : both t_Algorithm :=
  Algorithm_XWingKyberDraft02  :=
    ret_both (inl (inr (tt : 'unit)) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.
Notation "'Algorithm_MlKem1024_case'" := (inr tt) (at level 100).
Equations Algorithm_MlKem1024 : both t_Algorithm :=
  Algorithm_MlKem1024  :=
    ret_both (inr (tt : 'unit) : t_Algorithm) : both t_Algorithm.
Fail Next Obligation.

End Libcrux_kem.

Class t_TryFrom (A B : choice_type) :=
  { f_Error : choice_type ;
    f_try_from : both B -> both (t_Result A B) }.

Class Into A B := f_into : both A -> both B.
Instance into_any {A B} : Into A B. Admitted.

Definition Option_Some {A} := lift1_both (fun x => (Some x : 'option A)).
Definition Option_None {A} := ret_both (None : 'option A).

Definition impl_1__append {A} (a : both (t_Vec A t_Global)) (b : both (t_Vec A t_Global)) : both (t_Vec A t_Global × t_Vec A t_Global) :=
  lift2_both (fun (x y : t_Vec A t_Global) => (([], app x y) : t_Vec A t_Global × t_Vec A t_Global)) a b.

Definition impl_1__push {A} (a : both (t_Vec A t_Global)) (x : both A) : both (t_Vec A t_Global) :=
  lift2_both (fun (x : t_Vec A t_Global) (y : A) => ((cons y x) : t_Vec A t_Global)) a x.

Definition impl_2__extend_from_slice {A} (a : both (t_Vec A t_Global)) (b : both (t_Seq A)) : both (t_Vec A t_Global) :=
  lift2_both (fun (x y : t_Vec A t_Global) => ((app x y) : t_Vec A t_Global)) a (seq_to_list b).

#[global] Notation "'t_RandomState'" := (tt).
#[global] Notation "'t_HashMap'" := (fun x y _ => chMap x y) (at level 100).

#[global] Notation "'impl_Bytes__declassify'" := id.

Definition impl__is_empty {A} (l : both (chList A)) := (l =.? array_to_list (array_from_list [])).
