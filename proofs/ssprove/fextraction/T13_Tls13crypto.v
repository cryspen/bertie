(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

From RecordUpdate Require Import RecordUpdate.

Import RecordSetNotations.

Require Import Fixes.

Require Import t13_Tls13utils.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Definition t_HashAlgorithm : choice_type :=
  ('unit ∐ 'unit ∐ 'unit).
Notation "'HashAlgorithm_SHA256_case'" := (inl (inl tt)) (at level 100).
Equations HashAlgorithm_SHA256 : both t_HashAlgorithm :=
  HashAlgorithm_SHA256  :=
    ret_both (inl (inl (tt : 'unit)) : t_HashAlgorithm) : both t_HashAlgorithm.
Fail Next Obligation.
Notation "'HashAlgorithm_SHA384_case'" := (inl (inr tt)) (at level 100).
Equations HashAlgorithm_SHA384 : both t_HashAlgorithm :=
  HashAlgorithm_SHA384  :=
    ret_both (inl (inr (tt : 'unit)) : t_HashAlgorithm) : both t_HashAlgorithm.
Fail Next Obligation.
Notation "'HashAlgorithm_SHA512_case'" := (inr tt) (at level 100).
Equations HashAlgorithm_SHA512 : both t_HashAlgorithm :=
  HashAlgorithm_SHA512  :=
    ret_both (inr (tt : 'unit) : t_HashAlgorithm) : both t_HashAlgorithm.
Fail Next Obligation.

Equations t_HashAlgorithm_cast_to_repr (x : both t_HashAlgorithm) : both uint_size :=
  t_HashAlgorithm_cast_to_repr x  :=
    matchb x with
    | HashAlgorithm_SHA256_case  =>
      ret_both (0 : uint_size)
    | HashAlgorithm_SHA384_case  =>
      ret_both (1 : uint_size)
    | HashAlgorithm_SHA512_case  =>
      ret_both (2 : uint_size)
    end : both uint_size.
Fail Next Obligation.

#[global] Program Instance t_HashAlgorithm_t_PartialEq : t_PartialEq t_HashAlgorithm t_HashAlgorithm :=
  _.
Fail Next Obligation.
Hint Unfold t_HashAlgorithm_t_PartialEq.

#[global] Program Instance t_HashAlgorithm_t_Eq : t_Eq t_HashAlgorithm :=
  _.
Fail Next Obligation.
Hint Unfold t_HashAlgorithm_t_Eq.

(* #[global] Program Instance t_HashAlgorithm_t_Hash : t_Hash t_HashAlgorithm := *)
(*   _. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_HashAlgorithm_t_Hash. *)

Equations hash_len_inner (h : both t_HashAlgorithm) : both uint_size :=
  hash_len_inner h :=
    matchb h with
    | HashAlgorithm_SHA256_case => ret_both 32
    | HashAlgorithm_SHA384_case => ret_both 48
    | HashAlgorithm_SHA512_case => ret_both 64
    end.

Equations impl_HashAlgorithm__hash_len (self : both t_HashAlgorithm) : both uint_size :=
  impl_HashAlgorithm__hash_len self  :=
    hash_len_inner self : both uint_size.
Fail Next Obligation.

(* Equations hmac_tag (alg : both t_HashAlgorithm) (mk : both t_Bytes) (input : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   hmac_tag alg mk input  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist20 := impl_HashAlgorithm__hmac_algorithm alg in *)
(*     Result_Ok (letb hoist21 := hmac hoist20 (f_deref (impl_Bytes__declassify mk)) (f_deref (impl_Bytes__declassify input)) Option_None in *)
(*     letb hoist22 := f_into hoist21 in *)
(*     Result_Ok hoist22)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations hmac_verify (alg : both t_HashAlgorithm) (mk : both t_Bytes) (input : both t_Bytes) (tag : both t_Bytes) : both (t_Result 'unit int8) := *)
(*   hmac_verify alg mk input tag  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist23 := hmac_tag alg mk input in *)
(*     Result_Ok (letb hoist24 := eq hoist23 tag in *)
(*     ifb hoist24 *)
(*     then Result_Ok (ret_both (tt : 'unit)) *)
(*     else tlserr v_CRYPTO_ERROR)) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations zero_key (alg : both t_HashAlgorithm) : both t_Bytes := *)
(*   zero_key alg  := *)
(*     impl_Bytes__zeroes (impl_HashAlgorithm__hash_len alg) : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations hkdf_algorithm (alg : both t_HashAlgorithm) : both (t_Result t_Algorithm int8) := *)
(*   hkdf_algorithm alg  := *)
(*     matchb alg with *)
(*     | HashAlgorithm_SHA256_case  => *)
(*       Result_Ok Algorithm_Sha256 *)
(*     | HashAlgorithm_SHA384_case  => *)
(*       Result_Ok Algorithm_Sha384 *)
(*     | HashAlgorithm_SHA512_case  => *)
(*       Result_Ok Algorithm_Sha512 *)
(*     end : both (t_Result t_Algorithm int8). *)
(* Fail Next Obligation. *)

(* Equations hkdf_extract (alg : both t_HashAlgorithm) (ikm : both t_Bytes) (salt : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   hkdf_extract alg ikm salt  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist25 := hkdf_algorithm alg in *)
(*     Result_Ok (letb hoist26 := extract hoist25 (impl_Bytes__declassify salt) (impl_Bytes__declassify ikm) in *)
(*     letb hoist27 := impl__map hoist26 (fun bytes => *)
(*       f_into bytes) in *)
(*     impl__map_err hoist27 (fun _ => *)
(*       v_CRYPTO_ERROR))) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations hkdf_expand (alg : both t_HashAlgorithm) (prk : both t_Bytes) (info : both t_Bytes) (len : both uint_size) : both (t_Result t_Bytes int8) := *)
(*   hkdf_expand alg prk info len  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist28 := hkdf_algorithm alg in *)
(*     Result_Ok (letb hoist29 := expand hoist28 (impl_Bytes__declassify prk) (impl_Bytes__declassify info) len in *)
(*     matchb hoist29 with *)
(*     | Result_Ok_case x => *)
(*       letb x := ret_both ((x) : (t_Vec int8 t_Global)) in *)
(*       Result_Ok (f_into x) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (t_Error)) in *)
(*       tlserr v_CRYPTO_ERROR *)
(*     end)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)
