(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import TryInto.
Export TryInto.

Require Import Read.
Export Read.

Require Import Write.
Export Write.

Require Import Crate_Tls13crypto.
Export Crate_Tls13crypto.

Require Import Crate_Tls13utils.
Export Crate_Tls13utils.

Definition t_BertieError : choice_type :=
  ('unit ∐ t_Error ∐ int8).
Notation "'BertieError_InvalidState_case'" := (inl (inl tt)) (at level 100).
Equations BertieError_InvalidState : both t_BertieError :=
  BertieError_InvalidState  :=
    ret_both (inl (inl (tt : 'unit)) : t_BertieError) : both t_BertieError.
Fail Next Obligation.
Notation "'BertieError_Io_case' x" := (inl (inr x)) (at level 100).
Equations BertieError_Io (x : both t_Error) : both t_BertieError :=
  BertieError_Io x  :=
    bind_both x (fun x =>
      ret_both (inl (inr x) : t_BertieError)) : both t_BertieError.
Fail Next Obligation.
Notation "'BertieError_TLS_case' x" := (inr x) (at level 100).
Equations BertieError_TLS (x : both int8) : both t_BertieError :=
  BertieError_TLS x  :=
    bind_both x (fun x =>
      ret_both (inr x : t_BertieError)) : both t_BertieError.
Fail Next Obligation.

#[global] Program Instance t_BertieError_t_From : t_From t_BertieError t_Error :=
  let f_from := fun  (e : both t_Error) => BertieError_Io e : both t_BertieError in
  {| f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_BertieError_t_From.

#[global] Program Instance t_BertieError_t_From : t_From t_BertieError int8 :=
  let f_from := fun  (error : both int8) => BertieError_TLS error : both t_BertieError in
  {| f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_BertieError_t_From.

(*(RefMut) The mutation of this [1m&mut[0m is not allowed here.
Last available AST for this item:

#[cfg(feature = "api")]
#[allow(non_upper_case_globals)]
#[allow(unused_variables)]
#[allow(clippy::large_enum_variant)]
#[allow(clippy::zero_prefixed_literal)]
#[feature(register_tool)]
#[register_tool(_hax)]
trait t_TlsStream<Self_, T>
where
    _: core::marker::t_Sized<T>,
    _: std::io::t_Write<T>,
    _: std::io::t_Read<T>,
{
    /// Write `bytes` out to the connection, using the underlying TLS connection.
    #[cfg(feature = "api")]
    #[allow(non_upper_case_globals)]
    #[allow(unused_variables)]
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::zero_prefixed_literal)]
    #[feature(register_tool)]
    #[register_tool(_hax)]
    fn f_write_tls<Anonymous: 'unk, Anonymous: 'unk>(
        _: Self,
        _: &[int],
    ) -> tuple2<
        Self,
        core::result::t_Result<tuple0, bertie::stream::bertie_stream::t_BertieError>,
    >;
    /// Read bytes from the TLS connection.
    #[cfg(feature = "api")]
    #[allow(non_upper_case_globals)]
    #[allow(unused_variables)]
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::zero_prefixed_literal)]
    #[feature(register_tool)]
    #[register_tool(_hax)]
    fn f_read_tls<Anonymous: 'unk>(
        _: Self,
    ) -> tuple2<
        Self,
        core::result::t_Result<
            alloc::vec::t_Vec<int, alloc::alloc::t_Global>,
            bertie::stream::bertie_stream::t_BertieError,
        >,
    >;
    /// Get the mutable underlying stream of type `T`.
    #[cfg(feature = "api")]
    #[allow(non_upper_case_globals)]
    #[allow(unused_variables)]
    #[allow(clippy::large_enum_variant)]
    #[allow(clippy::zero_prefixed_literal)]
    #[feature(register_tool)]
    #[register_tool(_hax)]
    fn f_stream_mut<Anonymous: 'unk>(_: Self) -> tuple2<Self, &mut T>;
}
 todo(item)*)

Equations read_record {v_R : _} `{ t_Sized v_R} `{ t_Read v_R} (read_buffer : both (t_Vec int8 t_Global)) (input : both v_R) : both (t_Vec int8 t_Global × v_R × t_Result (t_Vec int8 t_Global) t_BertieError) :=
  read_record read_buffer input  :=
    letb '((input,read_buffer),hoist19) := other loop todo(term) in
    letb hax_temp_output := never_to_any hoist19 in
    prod_b (read_buffer,input,hax_temp_output) : both (t_Vec int8 t_Global × v_R × t_Result (t_Vec int8 t_Global) t_BertieError).
Fail Next Obligation.

Definition t_BertieStream {v_State : _} `{ t_Sized v_State} : choice_type :=
  (v_State × t_String × t_Algorithms).
Equations f_state {v_State : _} `{ t_Sized v_State} (s : both t_BertieStream) : both v_State :=
  f_state s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : v_State)) : both v_State.
Fail Next Obligation.
Equations f_host {v_State : _} `{ t_Sized v_State} (s : both t_BertieStream) : both t_String :=
  f_host s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_String)) : both t_String.
Fail Next Obligation.
Equations f_ciphersuite {v_State : _} `{ t_Sized v_State} (s : both t_BertieStream) : both t_Algorithms :=
  f_ciphersuite s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations Build_t_BertieStream {v_State : _} `{ t_Sized v_State} {f_state : both v_State} {f_host : both t_String} {f_ciphersuite : both t_Algorithms} : both (t_BertieStream) :=
  Build_t_BertieStream  :=
    bind_both f_ciphersuite (fun f_ciphersuite =>
      bind_both f_host (fun f_host =>
        bind_both f_state (fun f_state =>
          ret_both ((f_state,f_host,f_ciphersuite) : (t_BertieStream))))) : both (t_BertieStream).
Fail Next Obligation.
Notation "'Build_t_BertieStream' '[' x ']' '(' 'f_state' ':=' y ')'" := (Build_t_BertieStream (f_state := y) (f_host := f_host x) (f_ciphersuite := f_ciphersuite x)).
Notation "'Build_t_BertieStream' '[' x ']' '(' 'f_host' ':=' y ')'" := (Build_t_BertieStream (f_state := f_state x) (f_host := y) (f_ciphersuite := f_ciphersuite x)).
Notation "'Build_t_BertieStream' '[' x ']' '(' 'f_ciphersuite' ':=' y ')'" := (Build_t_BertieStream (f_state := f_state x) (f_host := f_host x) (f_ciphersuite := y)).
