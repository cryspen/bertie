(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import File.
Export File.

Require Import BufReader.
Export BufReader.

Require Import Read.
Export Read.

Require Import Write.
Export Write.

Require Import TcpStream.
Export TcpStream.

Require Import CryptoRng.
Export CryptoRng.

Require Import RngCore.
Export RngCore.

Require Import ServerDB.
Export ServerDB.

Require Import rsa_private_key.
Export rsa_private_key.

Require Import verification_key_from_cert.
Export verification_key_from_cert.

Require Import Algorithms.
Export Algorithms.

Require Import SignatureKey.
Export SignatureKey.

Require Import SignatureScheme.
Export SignatureScheme.

Require Import AppData.
Export AppData.

Require Import Bytes.
Export Bytes.

Require Import INVALID_COMPRESSION_LIST.
Export INVALID_COMPRESSION_LIST.

Require Import MISSING_KEY_SHARE.
Export MISSING_KEY_SHARE.

Require Import PARSE_FAILED.
Export PARSE_FAILED.

Require Import PROTOCOL_VERSION_ALERT.
Export PROTOCOL_VERSION_ALERT.

Require Import Server.
Export Server.

Require Import read_record.
Export read_record.

Require Import BertieError.
Export BertieError.

Require Import BertieStream.
Export BertieStream.

Require Import TlsStream.
Export TlsStream.

Equations read_file (file_name : both chString) : both (t_Result (t_Vec int8 t_Global) t_BertieError) :=
  read_file file_name  :=
    run (letm[choice_typeMonad.result_bind_code t_BertieError] f := impl__map_err (impl__File__open file_name) f_from in
    letb reader := impl__new f in
    letb buffer := impl__new in
    letb '(tmp0,tmp1,out) := f_read_to_end reader buffer in
    letb reader := tmp0 in
    letb buffer := tmp1 in
    letb hoist20 := out in
    letb hoist21 := impl__map_err hoist20 f_from in
    letm[choice_typeMonad.result_bind_code t_BertieError] _ := hoist21 in
    Result_Ok (Result_Ok buffer)) : both (t_Result (t_Vec int8 t_Global) t_BertieError).
Fail Next Obligation.

(*item error backend*)

Definition t_ServerState {v_Stream : _} `{ t_Sized v_Stream} `{ t_Read v_Stream} `{ t_Write v_Stream} : choice_type :=
  (t_Option t_Server Ã— v_Stream Ã— t_ServerDB Ã— t_Vec int8 t_Global).
Equations f_sstate {v_Stream : _} `{ t_Sized v_Stream} `{ t_Read v_Stream} `{ t_Write v_Stream} (s : both t_ServerState) : both (t_Option t_Server) :=
  f_sstate s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst x)) : (t_Option t_Server))) : both (t_Option t_Server).
Fail Next Obligation.
Equations f_stream {v_Stream : _} `{ t_Sized v_Stream} `{ t_Read v_Stream} `{ t_Write v_Stream} (s : both t_ServerState) : both v_Stream :=
  f_stream s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : v_Stream)) : both v_Stream.
Fail Next Obligation.
Equations f_db {v_Stream : _} `{ t_Sized v_Stream} `{ t_Read v_Stream} `{ t_Write v_Stream} (s : both t_ServerState) : both t_ServerDB :=
  f_db s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_ServerDB)) : both t_ServerDB.
Fail Next Obligation.
Equations f_read_buffer {v_Stream : _} `{ t_Sized v_Stream} `{ t_Read v_Stream} `{ t_Write v_Stream} (s : both t_ServerState) : both (t_Vec int8 t_Global) :=
  f_read_buffer s  :=
    bind_both s (fun x =>
      ret_both (snd x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_ServerState {v_Stream : _} `{ t_Sized v_Stream} `{ t_Read v_Stream} `{ t_Write v_Stream} {f_sstate : both (t_Option t_Server)} {f_stream : both v_Stream} {f_db : both t_ServerDB} {f_read_buffer : both (t_Vec int8 t_Global)} : both (t_ServerState) :=
  Build_t_ServerState  :=
    bind_both f_read_buffer (fun f_read_buffer =>
      bind_both f_db (fun f_db =>
        bind_both f_stream (fun f_stream =>
          bind_both f_sstate (fun f_sstate =>
            ret_both ((f_sstate,f_stream,f_db,f_read_buffer) : (t_ServerState)))))) : both (t_ServerState).
Fail Next Obligation.
Notation "'Build_t_ServerState' '[' x ']' '(' 'f_sstate' ':=' y ')'" := (Build_t_ServerState (f_sstate := y) (f_stream := f_stream x) (f_db := f_db x) (f_read_buffer := f_read_buffer x)).
Notation "'Build_t_ServerState' '[' x ']' '(' 'f_stream' ':=' y ')'" := (Build_t_ServerState (f_sstate := f_sstate x) (f_stream := y) (f_db := f_db x) (f_read_buffer := f_read_buffer x)).
Notation "'Build_t_ServerState' '[' x ']' '(' 'f_db' ':=' y ')'" := (Build_t_ServerState (f_sstate := f_sstate x) (f_stream := f_stream x) (f_db := y) (f_read_buffer := f_read_buffer x)).
Notation "'Build_t_ServerState' '[' x ']' '(' 'f_read_buffer' ':=' y ')'" := (Build_t_ServerState (f_sstate := f_sstate x) (f_stream := f_stream x) (f_db := f_db x) (f_read_buffer := y)).

Equations impl__new {v_Stream : _} `{ t_Sized v_Stream} `{ t_Read v_Stream} `{ t_Write v_Stream} (stream : both v_Stream) (db : both t_ServerDB) : both (t_ServerState v_Stream) :=
  impl__new stream db  :=
    Build_t_ServerState (f_sstate := Option_None) (f_stream := stream) (f_read_buffer := impl__new) (f_db := db) : both (t_ServerState v_Stream).
Fail Next Obligation.

#[global] Program Instance t_ServerState v_Stream_t_TlsStream {v_Stream : _} `{ t_Sized v_Stream} `{ t_Read v_Stream} `{ t_Write v_Stream} : t_TlsStream (t_ServerState v_Stream) v_Stream :=
  let f_write_tls := fun  (self : both (t_ServerState v_Stream)) (bytes : both (seq int8)) => run (letb '(tmp0,out) := impl__take (f_sstate self) in
  letb self := Build_t_ServerState[self] (f_sstate := tmp0) in
  letb hoist288 := out in
  letm[choice_typeMonad.result_bind_code (t_ServerState v_Stream Ã— t_Result 'unit t_BertieError)] sstate := matchb hoist288 with
  | Option_Some_case state =>
    letb state := ret_both ((state) : (t_Server)) in
    ControlFlow_Continue state
  | Option_None_case  =>
    letm[choice_typeMonad.result_bind_code (t_ServerState v_Stream Ã— t_Result 'unit t_BertieError)] hoist287 := ControlFlow_Break (prod_b (self,Result_Err BertieError_InvalidState)) in
    ControlFlow_Continue (never_to_any hoist287)
  end in
  letm[choice_typeMonad.result_bind_code (t_ServerState v_Stream Ã— t_Result 'unit t_BertieError)] '(wire_bytes,new_state) := matchb f_branch (impl__Server__write sstate (impl__AppData__new (f_into bytes))) with
  | ControlFlow_Break_case residual =>
    letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
    letm[choice_typeMonad.result_bind_code (t_ServerState v_Stream Ã— t_Result 'unit t_BertieError)] hoist289 := ControlFlow_Break (prod_b (self,f_from_residual residual)) in
    ControlFlow_Continue (never_to_any hoist289)
  | ControlFlow_Continue_case val =>
    letb val := ret_both ((val) : (t_Bytes Ã— t_Server)) in
    ControlFlow_Continue val
  end in
  ControlFlow_Continue (letb self := Build_t_ServerState[self] (f_sstate := Option_Some new_state) in
  letb '(tmp0,out) := f_write_all (f_stream self) (f_deref (impl__Bytes__declassify wire_bytes)) in
  letb self := Build_t_ServerState[self] (f_stream := tmp0) in
  letb hoist290 := out in
  letb hax_temp_output := impl__map_err hoist290 (fun e =>
    f_into e) in
  prod_b (self,hax_temp_output))) : both (t_ServerState v_Stream Ã— t_Result 'unit t_BertieError) in
  let f_read_tls := fun  (self : both (t_ServerState v_Stream)) => run (letb '(tmp0,out) := impl__take (f_sstate self) in
  letb self := Build_t_ServerState[self] (f_sstate := tmp0) in
  letb hoist292 := out in
  letm[choice_typeMonad.result_bind_code (t_ServerState v_Stream Ã— t_Result (t_Vec int8 t_Global) t_BertieError)] sstate := matchb hoist292 with
  | Option_Some_case state =>
    letb state := ret_both ((state) : (t_Server)) in
    ControlFlow_Continue state
  | Option_None_case  =>
    letm[choice_typeMonad.result_bind_code (t_ServerState v_Stream Ã— t_Result (t_Vec int8 t_Global) t_BertieError)] hoist291 := ControlFlow_Break (prod_b (self,Result_Err BertieError_InvalidState)) in
    ControlFlow_Continue (never_to_any hoist291)
  end in
  ControlFlow_Continue (letb application_data := other loop todo(term) in
  letb self := Build_t_ServerState[self] (f_sstate := Option_Some sstate) in
  letb hax_temp_output := Result_Ok (impl__Bytes__declassify (impl__AppData__into_raw application_data)) in
  prod_b (self,hax_temp_output))) : both (t_ServerState v_Stream Ã— t_Result (t_Vec int8 t_Global) t_BertieError) in
  let f_stream_mut := fun  (self : both (t_ServerState v_Stream)) => failure (ret_both ((RefMut) The mutation of this [1m&mut[0m is not allowed here. : chString)) (ret_both ({
        let hax_temp_output: &mut Stream = {
            &mut (deref({
                &mut (deref(&mut (proj_bertie::stream::server::f_stream(self))))
            }))
        };
        Tuple2(self, hax_temp_output)
    } : chString)) : both t_failure in
  {| f_write_tls := (@f_write_tls);
  f_read_tls := (@f_read_tls);
  f_stream_mut := (@f_stream_mut)|}.
Fail Next Obligation.
Hint Unfold t_ServerState v_Stream_t_TlsStream.

Equations impl_2__server_with_stream {v_Stream : _} `{ t_Sized v_Stream} `{ t_Read v_Stream} `{ t_Write v_Stream} (host : both chString) (ciphersuite : both t_Algorithms) (stream : both v_Stream) (cert_file : both chString) (key_file : both chString) : both (t_Result (t_BertieStream (t_ServerState v_Stream)) t_BertieError) :=
  impl_2__server_with_stream host ciphersuite stream cert_file key_file  :=
    run (letm[choice_typeMonad.result_bind_code t_BertieError] db := init_db host key_file cert_file in
    Result_Ok (Result_Ok (Build_t_BertieStream (f_state := impl__new stream db) (f_ciphersuite := ciphersuite) (f_host := f_to_string host)))) : both (t_Result (t_BertieStream (t_ServerState v_Stream)) t_BertieError).
Fail Next Obligation.

Equations impl_3__check_ccs_message (self : both (t_BertieStream (t_ServerState t_TcpStream))) (buf : both (seq int8)) : both (t_Result 'unit t_BertieError) :=
  impl_3__check_ccs_message self buf  :=
    ifb andb (andb (andb (andb (andb (andb ((impl__len buf) =.? (ret_both (6 : uint_size))) ((buf.a[(ret_both (0 : uint_size))]) =.? (ret_both (20 : int8)))) ((buf.a[(ret_both (1 : uint_size))]) =.? (ret_both (3 : int8)))) ((buf.a[(ret_both (2 : uint_size))]) =.? (ret_both (3 : int8)))) ((buf.a[(ret_both (3 : uint_size))]) =.? (ret_both (0 : int8)))) ((buf.a[(ret_both (4 : uint_size))]) =.? (ret_both (1 : int8)))) ((buf.a[(ret_both (5 : uint_size))]) =.? (ret_both (1 : int8)))
    then Result_Ok (ret_both (tt : 'unit))
    else Result_Err (f_into v_PARSE_FAILED) : both (t_Result 'unit t_BertieError).
Fail Next Obligation.

Equations impl_3__read (self : both (t_BertieStream (t_ServerState t_TcpStream))) : both (t_BertieStream (t_ServerState t_TcpStream) Ã— t_Result (t_Vec int8 t_Global) t_BertieError) :=
  impl_3__read self  :=
    letb '(tmp0,out) := f_read_tls (f_state self) in
    letb self := Build_t_BertieStream[self] (f_state := tmp0) in
    letb hax_temp_output := out in
    prod_b (self,hax_temp_output) : both (t_BertieStream (t_ServerState t_TcpStream) Ã— t_Result (t_Vec int8 t_Global) t_BertieError).
Fail Next Obligation.

Equations impl_3__server (host : both chString) (port : both int16) (stream : both t_TcpStream) (ciphersuite : both t_Algorithms) (cert_file : both chString) (key_file : both chString) : both (t_Result (t_BertieStream (t_ServerState t_TcpStream)) t_BertieError) :=
  impl_3__server host port stream ciphersuite cert_file key_file  :=
    run (letm[choice_typeMonad.result_bind_code t_BertieError] db := init_db host key_file cert_file in
    Result_Ok (Result_Ok (Build_t_BertieStream (f_state := Build_t_ServerState (f_db := db) (f_stream := stream) (f_read_buffer := impl__new) (f_sstate := Option_None)) (f_host := f_to_string host) (f_ciphersuite := ciphersuite)))) : both (t_Result (t_BertieStream (t_ServerState t_TcpStream)) t_BertieError).
Fail Next Obligation.

Equations impl_3__write (self : both (t_BertieStream (t_ServerState t_TcpStream))) (bytes : both (seq int8)) : both (t_BertieStream (t_ServerState t_TcpStream) Ã— t_Result uint_size t_BertieError) :=
  impl_3__write self bytes  :=
    run (letb '(tmp0,out) := f_write_tls (f_state self) bytes in
    letb self := Build_t_BertieStream[self] (f_state := tmp0) in
    letb hoist294 := out in
    letb hoist295 := f_branch hoist294 in
    letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— t_Result uint_size t_BertieError)] _ := matchb hoist295 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— t_Result uint_size t_BertieError)] hoist293 := ControlFlow_Break (prod_b (self,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist293)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : ('unit)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (impl__len bytes) in
    prod_b (self,hax_temp_output))) : both (t_BertieStream (t_ServerState t_TcpStream) Ã— t_Result uint_size t_BertieError).
Fail Next Obligation.

Equations impl_3__write_all (self : both (t_BertieStream (t_ServerState t_TcpStream))) (bytes : both (seq int8)) : both (t_BertieStream (t_ServerState t_TcpStream) Ã— t_Result 'unit t_BertieError) :=
  impl_3__write_all self bytes  :=
    letb '(tmp0,out) := f_write_all (failure (ret_both ((RefMut) At this position, Hax was expecting an expression of the shape `&mut _`. Hax forbids `f(x)` (where `f` expects a mutable reference as input) when `x` is not a [1mplace expression[0m[90m[1][0m or when it is a dereference expression.

[1]: https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions
 : chString)) (ret_both (deref(
        bertie::stream::bertie_stream::f_stream_mut(
            &mut (proj_bertie::stream::bertie_stream::f_state(self)),
        ),
    ) : chString))) bytes in
    letb _ := failure (ret_both ((reject_ArbitraryLhs) ExplicitRejection { reason: "a node of kind [Arbitrary_lhs] have been found in the AST" } : chString)) (ret_both ((rust_primitives::hax::failure(
        "(RefMut) At this position, Hax was expecting an expression of the shape `&mut _`. Hax forbids `f(x)` (where `f` expects a mutable reference as input) when `x` is not a \027[1mplace expression\027[0m\027[90m[1]\027[0m or when it is a dereference expression.\n\n[1]: https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions\n",
        "deref(\n        bertie::stream::bertie_stream::f_stream_mut(\n            &mut (proj_bertie::stream::bertie_stream::f_state(self)),\n        ),\n    )",
    ) = tmp0) : chString)) in
    letb hax_temp_output := impl__map_err out (fun e =>
      f_into e) in
    prod_b (self,hax_temp_output) : both (t_BertieStream (t_ServerState t_TcpStream) Ã— t_Result 'unit t_BertieError).
Fail Next Obligation.

Equations impl_3__close (self : both (t_BertieStream (t_ServerState t_TcpStream))) : both (t_Result 'unit t_BertieError) :=
  impl_3__close self  :=
    run (letb '(tmp0,out) := impl_3__write_all self (unsize (array_from_list [ret_both (21 : int8);
      ret_both (3 : int8);
      ret_both (3 : int8);
      ret_both (0 : int8);
      ret_both (2 : int8);
      ret_both (1 : int8);
      ret_both (0 : int8)])) in
    letb self := tmp0 in
    letb hoist296 := out in
    letm[choice_typeMonad.result_bind_code t_BertieError] _ := hoist296 in
    Result_Ok (Result_Ok (ret_both (tt : 'unit)))) : both (t_Result 'unit t_BertieError).
Fail Next Obligation.

Equations impl_3__connect {impl_277843321_ : _} `{ t_Sized impl_277843321_} `{ t_RngCore impl_277843321_} `{ t_CryptoRng impl_277843321_} (self : both (t_BertieStream (t_ServerState t_TcpStream))) (rng : both impl_277843321_) : both (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError) :=
  impl_3__connect self rng  :=
    run (letb '(tmp0,tmp1,out) := read_record (f_read_buffer (f_state self)) (f_stream (f_state self)) in
    letb self := Build_t_BertieStream[self] (f_state := Build_t_ServerState[f_state self] (f_read_buffer := tmp0)) in
    letb self := Build_t_BertieStream[self] (f_state := Build_t_ServerState[f_state self] (f_stream := tmp1)) in
    letb hoist298 := out in
    letb hoist299 := f_branch hoist298 in
    letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] client_hello := matchb hoist299 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist297 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist297)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Vec int8 t_Global)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := impl__Server__accept (f_ciphersuite self) (f_clone (f_db (f_state self))) (f_into client_hello) rng in
    letb rng := tmp0 in
    letb hoist324 := out in
    letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] self := matchb hoist324 with
    | Result_Err_case x =>
      letb x := ret_both ((x) : (int8)) in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] self := matchb x with
      | 136 =>
        letb '(tmp0,out) := impl_3__write_all self (unsize (array_from_list [ret_both (21 : int8);
          ret_both (3 : int8);
          ret_both (3 : int8);
          ret_both (0 : int8);
          ret_both (2 : int8);
          ret_both (2 : int8);
          ret_both (47 : int8)])) in
        letb self := tmp0 in
        letb hoist301 := out in
        letb hoist302 := f_branch hoist301 in
        letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] _ := matchb hoist302 with
        | ControlFlow_Break_case residual =>
          letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
          letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist300 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
          ControlFlow_Continue (never_to_any hoist300)
        | ControlFlow_Continue_case val =>
          letb val := ret_both ((val) : ('unit)) in
          ControlFlow_Continue val
        end in
        ControlFlow_Continue self
      | 137 =>
        letb '(tmp0,out) := impl_3__write_all self (unsize (array_from_list [ret_both (21 : int8);
          ret_both (3 : int8);
          ret_both (3 : int8);
          ret_both (0 : int8);
          ret_both (2 : int8);
          ret_both (2 : int8);
          ret_both (70 : int8)])) in
        letb self := tmp0 in
        letb hoist304 := out in
        letb hoist305 := f_branch hoist304 in
        letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] _ := matchb hoist305 with
        | ControlFlow_Break_case residual =>
          letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
          letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist303 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
          ControlFlow_Continue (never_to_any hoist303)
        | ControlFlow_Continue_case val =>
          letb val := ret_both ((val) : ('unit)) in
          ControlFlow_Continue val
        end in
        ControlFlow_Continue self
      | 139 =>
        ControlFlow_Continue (letb _ := v__eprint (impl_2__new_const (array_from_list [ret_both (Hello message was missing a key share.
 : chString)])) in
        letb _ := ret_both (tt : 'unit) in
        self)
      | _ =>
        ControlFlow_Continue self
      end in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist306 := ControlFlow_Break (prod_b (self,rng,Result_Err (f_into x))) in
      ControlFlow_Continue self
    | Result_Ok_case (sh,sf,server_state) =>
      letb '(sh,sf,server_state) := ret_both (((sh,sf,server_state)) : (t_Bytes Ã— t_Bytes Ã— t_Server)) in
      letb '(tmp0,out) := impl_3__write_all self (f_deref (impl__Bytes__declassify sh)) in
      letb self := tmp0 in
      letb hoist308 := out in
      letb hoist309 := f_branch hoist308 in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] _ := matchb hoist309 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
        letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist307 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist307)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : ('unit)) in
        ControlFlow_Continue val
      end in
      letb ccs_rec := impl__Bytes__from_hex (ret_both (140303000101 : chString)) in
      letb '(tmp0,out) := impl_3__write_all self (f_deref (impl__Bytes__declassify ccs_rec)) in
      letb self := tmp0 in
      letb hoist311 := out in
      letb hoist312 := f_branch hoist311 in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] _ := matchb hoist312 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
        letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist310 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist310)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : ('unit)) in
        ControlFlow_Continue val
      end in
      letb '(tmp0,out) := impl_3__write_all self (f_deref (impl__Bytes__declassify sf)) in
      letb self := tmp0 in
      letb hoist314 := out in
      letb hoist315 := f_branch hoist314 in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] _ := matchb hoist315 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
        letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist313 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist313)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : ('unit)) in
        ControlFlow_Continue val
      end in
      letb '(tmp0,tmp1,out) := read_record (f_read_buffer (f_state self)) (f_stream (f_state self)) in
      letb self := Build_t_BertieStream[self] (f_state := Build_t_ServerState[f_state self] (f_read_buffer := tmp0)) in
      letb self := Build_t_BertieStream[self] (f_state := Build_t_ServerState[f_state self] (f_stream := tmp1)) in
      letb hoist317 := out in
      letb hoist318 := f_branch hoist317 in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] ccs := matchb hoist318 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
        letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist316 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist316)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_Vec int8 t_Global)) in
        ControlFlow_Continue val
      end in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] _ := matchb f_branch (impl_3__check_ccs_message self (f_deref ccs)) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
        letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist319 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist319)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : ('unit)) in
        ControlFlow_Continue val
      end in
      letb '(tmp0,tmp1,out) := read_record (f_read_buffer (f_state self)) (f_stream (f_state self)) in
      letb self := Build_t_BertieStream[self] (f_state := Build_t_ServerState[f_state self] (f_read_buffer := tmp0)) in
      letb self := Build_t_BertieStream[self] (f_state := Build_t_ServerState[f_state self] (f_stream := tmp1)) in
      letb hoist321 := out in
      letb hoist322 := f_branch hoist321 in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] cf_rec := matchb hoist322 with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible t_BertieError)) in
        letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist320 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist320)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_Vec int8 t_Global)) in
        ControlFlow_Continue val
      end in
      letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] sstate := matchb f_branch (impl__Server__read_handshake server_state (f_into cf_rec)) with
      | ControlFlow_Break_case residual =>
        letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
        letm[choice_typeMonad.result_bind_code (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError)] hoist323 := ControlFlow_Break (prod_b (self,rng,f_from_residual residual)) in
        ControlFlow_Continue (never_to_any hoist323)
      | ControlFlow_Continue_case val =>
        letb val := ret_both ((val) : (t_Server)) in
        ControlFlow_Continue val
      end in
      ControlFlow_Continue (letb self := Build_t_BertieStream[self] (f_state := Build_t_ServerState[f_state self] (f_sstate := Option_Some sstate)) in
      self)
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (ret_both (tt : 'unit)) in
    prod_b (self,rng,hax_temp_output))) : both (t_BertieStream (t_ServerState t_TcpStream) Ã— impl_277843321_ Ã— t_Result 'unit t_BertieError).
Fail Next Obligation.
