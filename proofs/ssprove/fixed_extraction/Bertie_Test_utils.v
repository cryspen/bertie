(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(* Require Import CryptoRng. *)
(* Export CryptoRng. *)

(* Require Import RngCore. *)
(* Export RngCore. *)

Definition t_TestRng : choice_type :=
  (t_Vec int8 t_Global).
Equations f_bytes (s : both t_TestRng) : both (t_Vec int8 t_Global) :=
  f_bytes s  :=
    bind_both s (fun x =>
      ret_both (x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_TestRng {f_bytes : both (t_Vec int8 t_Global)} : both (t_TestRng) :=
  Build_t_TestRng  :=
    bind_both f_bytes (fun f_bytes =>
      ret_both ((f_bytes) : (t_TestRng))) : both (t_TestRng).
Fail Next Obligation.
Notation "'Build_t_TestRng' '[' x ']' '(' 'f_bytes' ':=' y ')'" := (Build_t_TestRng (f_bytes := y)).

Equations impl__TestRng__new (bytes : both (t_Vec int8 t_Global)) : both t_TestRng :=
  impl__TestRng__new bytes  :=
    Build_t_TestRng (f_bytes := bytes) : both t_TestRng.
Fail Next Obligation.

Axiom f_deref :  both (t_Vec int8 t_Global) -> both (seq int8).
Class t_RngCore (A : choice_type) := {

    }.
Axiom panic : forall A, False -> both A.

Equations impl__TestRng__raw (self : both t_TestRng) : both (seq int8) :=
  impl__TestRng__raw self  :=
    f_deref (f_bytes self) : both (seq int8).
Fail Next Obligation.

Notation f_as_ref := id.

#[global] Program Instance t_TestRng_t_RngCore : t_RngCore t_TestRng :=
  let f_next_u32 := fun  (self : both t_TestRng) => letb hax_temp_output := never_to_any (panic _ (* (ret_both (not yet implemented : chString)) *)) in
  prod_b (self,hax_temp_output) : both (t_TestRng × int32) in
  let f_next_u64 := fun  (self : both t_TestRng) => letb hax_temp_output := never_to_any (panic _ (* (ret_both (not yet implemented : chString)) *)) in
  prod_b (self,hax_temp_output) : both (t_TestRng × int64) in
  let f_fill_bytes := fun  (self : both t_TestRng) (dest : both (seq int8)) => letb '(tmp0,out) := drain (f_bytes self) (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := len dest)) in
  letb self := Build_t_TestRng[self] (f_bytes := tmp0) in
  letb hoist22 := out in
  letb hoist23 := f_as_ref hoist22 in
  letb hoist24 := impl__copy_from_slice dest hoist23 in
  letb dest := hoist24 in
  prod_b (self,dest) : both (t_TestRng × seq int8) in
  let f_try_fill_bytes := fun  (self : both t_TestRng) (dest : both (seq int8)) => letb '(tmp0,out) := impl_1__drain (f_bytes self) (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := impl__len dest)) in
  letb self := Build_t_TestRng[self] (f_bytes := tmp0) in
  letb hoist25 := out in
  letb hoist26 := f_as_ref hoist25 in
  letb hoist27 := impl__copy_from_slice dest hoist26 in
  letb dest := hoist27 in
  letb hax_temp_output := Result_Ok (ret_both (tt : 'unit)) in
  prod_b (self,dest,hax_temp_output) : both (t_TestRng × seq int8 × t_Result 'unit t_Error) in
  {| f_next_u32 := (@f_next_u32);
  f_next_u64 := (@f_next_u64);
  f_fill_bytes := (@f_fill_bytes);
  f_try_fill_bytes := (@f_try_fill_bytes)|}.
Fail Next Obligation.
Hint Unfold t_TestRng_t_RngCore.

#[global] Program Instance t_TestRng_t_CryptoRng : t_CryptoRng t_TestRng :=
  _.
Fail Next Obligation.
Hint Unfold t_TestRng_t_CryptoRng.
