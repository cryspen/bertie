(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import CryptoRng.
Export CryptoRng.

Require Import RngCore.
Export RngCore.

Require Import ServerDB.
Export ServerDB.

Require Import Crate_Tls13crypto.
Export Crate_Tls13crypto.

Require Import HandshakeType.
Export HandshakeType.

Require Import Crate_Tls13formats.
Export Crate_Tls13formats.

Require Import Crate_Tls13handshake.
Export Crate_Tls13handshake.

Require Import Crate_Tls13record.
Export Crate_Tls13record.

Require Import Crate_Tls13utils.
Export Crate_Tls13utils.

Definition t_Client : choice_type :=
  (t_ClientPostClientHello × t_Option t_ClientCipherState0 ∐ t_ClientPostServerHello × t_Option t_ClientCipherState0 × t_DuplexCipherStateH × t_HandshakeData ∐ t_ClientPostClientFinished × t_DuplexCipherState1).
Notation "'Client_Client0_case' x" := (inl (inl x)) (at level 100).
Equations Client_Client0 (x : both (t_ClientPostClientHello × t_Option t_ClientCipherState0)) : both t_Client :=
  Client_Client0 x  :=
    bind_both x (fun x =>
      ret_both (inl (inl x) : t_Client)) : both t_Client.
Fail Next Obligation.
Notation "'Client_ClientH_case' x" := (inl (inr x)) (at level 100).
Equations Client_ClientH (x : both (t_ClientPostServerHello × t_Option t_ClientCipherState0 × t_DuplexCipherStateH × t_HandshakeData)) : both t_Client :=
  Client_ClientH x  :=
    bind_both x (fun x =>
      ret_both (inl (inr x) : t_Client)) : both t_Client.
Fail Next Obligation.
Notation "'Client_Client1_case' x" := (inr x) (at level 100).
Equations Client_Client1 (x : both (t_ClientPostClientFinished × t_DuplexCipherState1)) : both t_Client :=
  Client_Client1 x  :=
    bind_both x (fun x =>
      ret_both (inr x : t_Client)) : both t_Client.
Fail Next Obligation.

Equations in_psk_mode (c : both t_Client) : both 'bool :=
  in_psk_mode c  :=
    matchb c with
    | Client_Client0_case (cstate,_) =>
      letb cstate := ret_both ((cstate) : (t_ClientPostClientHello × t_Option t_ClientCipherState0)) in
      impl__Algorithms__psk_mode (algs_post_client_hello cstate)
    | Client_ClientH_case (cstate,_,_,_) =>
      letb cstate := ret_both ((cstate) : (t_ClientPostServerHello × t_Option t_ClientCipherState0 × t_DuplexCipherStateH × t_HandshakeData)) in
      impl__Algorithms__psk_mode (algs_post_server_hello cstate)
    | Client_Client1_case (cstate,_) =>
      letb cstate := ret_both ((cstate) : (t_ClientPostClientFinished × t_DuplexCipherState1)) in
      impl__Algorithms__psk_mode (algs_post_client_finished cstate)
    end : both 'bool.
Fail Next Obligation.

Definition t_Server : choice_type :=
  (t_ServerPostServerFinished × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 ∐ t_ServerPostClientFinished × t_DuplexCipherState1).
Notation "'Server_ServerH_case' x" := (inl x) (at level 100).
Equations Server_ServerH (x : both (t_ServerPostServerFinished × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1)) : both t_Server :=
  Server_ServerH x  :=
    bind_both x (fun x =>
      ret_both (inl x : t_Server)) : both t_Server.
Fail Next Obligation.
Notation "'Server_Server1_case' x" := (inr x) (at level 100).
Equations Server_Server1 (x : both (t_ServerPostClientFinished × t_DuplexCipherState1)) : both t_Server :=
  Server_Server1 x  :=
    bind_both x (fun x =>
      ret_both (inr x : t_Server)) : both t_Server.
Fail Next Obligation.

Equations impl__Client__connect {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (ciphersuite : both t_Algorithms) (server_name : both t_Bytes) (session_ticket : both (t_Option t_Bytes)) (psk : both (t_Option t_Bytes)) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_Bytes × t_Client) int8) :=
  impl__Client__connect ciphersuite server_name session_ticket psk rng  :=
    run (letb '(tmp0,out) := client_init ciphersuite server_name session_ticket psk rng in
    letb rng := tmp0 in
    letb hoist224 := out in
    letb hoist225 := f_branch hoist224 in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Client) int8)] '(client_hello,cipherstate0,client_state) := matchb hoist225 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Client) int8)] hoist223 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist223)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Client) int8)] client_hello_record := matchb f_branch (handshake_record client_hello) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Client) int8)] hoist226 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist226)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb client_hello_record := update_at client_hello_record (ret_both (2 : uint_size)) (v_U8 (ret_both (1 : int8))) in
    letb hax_temp_output := Result_Ok (prod_b (client_hello_record,Client_Client0 client_state cipherstate0)) in
    prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result (t_Bytes × t_Client) int8).
Fail Next Obligation.

Equations impl__Server__read (self : both t_Server) (application_data : both t_Bytes) : both (t_Result (t_Option t_AppData × t_Server) int8) :=
  impl__Server__read self application_data  :=
    run (matchb self with
    | Server_Server1_case (sstate,cipher1) =>
      letb '(sstate,cipher1) := ret_both ((sstate,cipher1) : (t_ServerPostClientFinished × t_DuplexCipherState1)) in
      letm[choice_typeMonad.result_bind_code int8] '(ad,cipher1) := decrypt_data application_data cipher1 in
      Result_Ok (Result_Ok (prod_b (Option_Some ad,Server_Server1 sstate cipher1)))
    | _ =>
      Result_Ok (Result_Err v_INCORRECT_STATE)
    end) : both (t_Result (t_Option t_AppData × t_Server) int8).
Fail Next Obligation.

Equations impl__Client__read (self : both t_Client) (message_bytes : both t_Bytes) : both (t_Result (t_Option t_AppData × t_Client) int8) :=
  impl__Client__read self message_bytes  :=
    run (matchb self with
    | Client_Client1_case (state,cipher1) =>
      letb '(state,cipher1) := ret_both ((state,cipher1) : (t_ClientPostClientFinished × t_DuplexCipherState1)) in
      letm[choice_typeMonad.result_bind_code int8] '(ty,hd,cipher1) := decrypt_data_or_hs message_bytes cipher1 in
      Result_Ok (matchb ty with
      | ContentType_ApplicationData_case  =>
        Result_Ok (prod_b (Option_Some (impl__AppData__new hd),Client_Client1 state cipher1))
      | ContentType_Handshake_case  =>
        letb _ := v__eprint (impl_2__new_const (array_from_list [ret_both (Received Session Ticket
 : chString)])) in
        letb _ := ret_both (tt : 'unit) in
        Result_Ok (prod_b (Option_None,Client_Client1 state cipher1))
      | _ =>
        Result_Err v_PARSE_FAILED
      end)
    | _ =>
      Result_Ok (Result_Err v_INCORRECT_STATE)
    end) : both (t_Result (t_Option t_AppData × t_Client) int8).
Fail Next Obligation.

Equations impl__Server__read_handshake (self : both t_Server) (handshake_bytes : both t_Bytes) : both (t_Result t_Server int8) :=
  impl__Server__read_handshake self handshake_bytes  :=
    run (matchb self with
    | Server_ServerH_case (sstate,v__cipher0,cipher_hs,cipher1) =>
      letb '(sstate,v__cipher0,cipher_hs,cipher1) := ret_both ((sstate,v__cipher0,cipher_hs,cipher1) : (t_ServerPostServerFinished × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1)) in
      letm[choice_typeMonad.result_bind_code int8] '(cf,v__cipher_hs) := decrypt_handshake handshake_bytes cipher_hs in
      letm[choice_typeMonad.result_bind_code int8] sstate := server_finish cf sstate in
      Result_Ok (Result_Ok (Server_Server1 sstate cipher1))
    | _ =>
      Result_Ok (Result_Err v_INCORRECT_STATE)
    end) : both (t_Result t_Server int8).
Fail Next Obligation.

Equations impl__Client__write (self : both t_Client) (application_data : both t_AppData) : both (t_Result (t_Bytes × t_Client) int8) :=
  impl__Client__write self application_data  :=
    run (matchb self with
    | Client_Client1_case (cstate,cipher1) =>
      letb '(cstate,cipher1) := ret_both ((cstate,cipher1) : (t_ClientPostClientFinished × t_DuplexCipherState1)) in
      letm[choice_typeMonad.result_bind_code int8] '(by,cipher1) := encrypt_data application_data (ret_both (0 : uint_size)) cipher1 in
      Result_Ok (Result_Ok (prod_b (by,Client_Client1 cstate cipher1)))
    | _ =>
      Result_Ok (Result_Err v_INCORRECT_STATE)
    end) : both (t_Result (t_Bytes × t_Client) int8).
Fail Next Obligation.

Equations impl__Server__write (self : both t_Server) (application_data : both t_AppData) : both (t_Result (t_Bytes × t_Server) int8) :=
  impl__Server__write self application_data  :=
    run (matchb self with
    | Server_Server1_case (sstate,cipher1) =>
      letb '(sstate,cipher1) := ret_both ((sstate,cipher1) : (t_ServerPostClientFinished × t_DuplexCipherState1)) in
      letm[choice_typeMonad.result_bind_code int8] '(by,cipher1) := encrypt_data application_data (ret_both (0 : uint_size)) cipher1 in
      Result_Ok (Result_Ok (prod_b (by,Server_Server1 sstate cipher1)))
    | _ =>
      Result_Ok (Result_Err v_INCORRECT_STATE)
    end) : both (t_Result (t_Bytes × t_Server) int8).
Fail Next Obligation.

Equations impl__Client__read_handshake (self : both t_Client) (handshake_bytes : both t_Bytes) : both (t_Result (t_Option t_Bytes × t_Client) int8) :=
  impl__Client__read_handshake self handshake_bytes  :=
    run (matchb self with
    | Client_Client0_case (state,cipher_state) =>
      letb '(state,cipher_state) := ret_both ((state,cipher_state) : (t_ClientPostClientHello × t_Option t_ClientCipherState0)) in
      letm[choice_typeMonad.result_bind_code int8] sf := get_handshake_record handshake_bytes in
      letm[choice_typeMonad.result_bind_code int8] '(cipher1,cstate) := client_set_params sf state in
      Result_Ok (letb buf := f_from impl__Bytes__new in
      Result_Ok (prod_b (Option_None,Client_ClientH cstate cipher_state cipher1 buf)))
    | Client_ClientH_case (cstate,cipher0,cipher_hs,buf) =>
      letb '(cstate,cipher0,cipher_hs,buf) := ret_both ((cstate,cipher0,cipher_hs,buf) : (t_ClientPostServerHello × t_Option t_ClientCipherState0 × t_DuplexCipherStateH × t_HandshakeData)) in
      letm[choice_typeMonad.result_bind_code int8] '(hd,cipher_hs) := decrypt_handshake handshake_bytes cipher_hs in
      letb buf := impl__HandshakeData__concat buf hd in
      ifb impl__HandshakeData__find_handshake_message buf HandshakeType_Finished (ret_both (0 : uint_size))
      then letm[choice_typeMonad.result_bind_code int8] '(cfin,cipher1,cstate) := client_finish buf cstate in
      letm[choice_typeMonad.result_bind_code int8] '(cf_rec,v__cipher_hs) := encrypt_handshake cfin (ret_both (0 : uint_size)) cipher_hs in
      Result_Ok (Result_Ok (prod_b (Option_Some cf_rec,Client_Client1 cstate cipher1)))
      else Result_Ok (Result_Ok (prod_b (Option_None,Client_ClientH cstate cipher0 cipher_hs buf)))
    | _ =>
      Result_Ok (Result_Err v_INCORRECT_STATE)
    end) : both (t_Result (t_Option t_Bytes × t_Client) int8).
Fail Next Obligation.

Equations impl__Server__accept {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (ciphersuite : both t_Algorithms) (db : both t_ServerDB) (client_hello : both t_Bytes) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8) :=
  impl__Server__accept ciphersuite db client_hello rng  :=
    run (letb ch_rec := f_clone client_hello in
    letb ch_rec := update_at ch_rec (ret_both (2 : uint_size)) (v_U8 (ret_both (3 : int8))) in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8)] ch := matchb f_branch (get_handshake_record ch_rec) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8)] hoist241 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist241)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := server_init ciphersuite ch db rng in
    letb rng := tmp0 in
    letb hoist243 := out in
    letb hoist244 := f_branch hoist243 in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8)] '(server_hello,server_finished,cipher0,cipher_hs,cipher1,sstate) := matchb hoist244 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8)] hoist242 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist242)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8)] sh_rec := matchb f_branch (handshake_record server_hello) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8)] hoist245 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist245)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8)] '(sf_rec,cipher_hs) := matchb f_branch (encrypt_handshake server_finished (ret_both (0 : uint_size)) cipher_hs) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8)] hoist246 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist246)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes × t_DuplexCipherStateH)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (sh_rec,sf_rec,Server_ServerH sstate cipher0 cipher_hs cipher1)) in
    prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result (t_Bytes × t_Bytes × t_Server) int8).
Fail Next Obligation.
