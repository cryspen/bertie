(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Declassify.
Export Declassify.

Require Import PublicVerificationKey.
Export PublicVerificationKey.

Require Import RsaVerificationKey.
Export RsaVerificationKey.

Require Import SignatureScheme.
Export SignatureScheme.

Require Import VerificationKey.
Export VerificationKey.

Require Import u32_from_be_bytes.
Export u32_from_be_bytes.

Require Import Bytes.
Export Bytes.

Require Import U8.
Export U8.

Equations v_ASN1_ERROR : both int8 :=
  v_ASN1_ERROR  :=
    ret_both (25 : int8) : both int8.
Fail Next Obligation.

Equations v_ASN1_INVALID_CERTIFICATE : both int8 :=
  v_ASN1_INVALID_CERTIFICATE  :=
    ret_both (23 : int8) : both int8.
Fail Next Obligation.

Equations v_ASN1_INVALID_TAG : both int8 :=
  v_ASN1_INVALID_TAG  :=
    ret_both (22 : int8) : both int8.
Fail Next Obligation.

Equations v_ASN1_SEQUENCE_TOO_LONG : both int8 :=
  v_ASN1_SEQUENCE_TOO_LONG  :=
    ret_both (21 : int8) : both int8.
Fail Next Obligation.

Equations v_ASN1_UNSUPPORTED_ALGORITHM : both int8 :=
  v_ASN1_UNSUPPORTED_ALGORITHM  :=
    ret_both (24 : int8) : both int8.
Fail Next Obligation.

Equations asn1_error {v_T : _} `{ t_Sized v_T} (err : both int8) : both (t_Result v_T int8) :=
  asn1_error err  :=
    Result_Err err : both (t_Result v_T int8).
Fail Next Obligation.

Equations check_success (val : both 'bool) : both (t_Result 'unit int8) :=
  check_success val  :=
    ifb val
    then Result_Ok (ret_both (tt : 'unit))
    else asn1_error v_ASN1_ERROR : both (t_Result 'unit int8).
Fail Next Obligation.

Definition t_CertificateKey : choice_type :=
  (uint_size × uint_size).
Equations 0 (s : both t_CertificateKey) : both uint_size :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations 1 (s : both t_CertificateKey) : both uint_size :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd x : uint_size)) : both uint_size.
Fail Next Obligation.
Equations Build_t_CertificateKey {0 : both uint_size} {1 : both uint_size} : both (t_CertificateKey) :=
  Build_t_CertificateKey  :=
    bind_both 1 (fun 1 =>
      bind_both 0 (fun 0 =>
        ret_both ((0,1) : (t_CertificateKey)))) : both (t_CertificateKey).
Fail Next Obligation.
Notation "'Build_t_CertificateKey' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_CertificateKey (0 := y) (1 := 1 x)).
Notation "'Build_t_CertificateKey' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_CertificateKey (0 := 0 x) (1 := y)).

Equations ecdsa_secp256r1_sha256_oid (_ : both 'unit) : both t_Bytes :=
  ecdsa_secp256r1_sha256_oid _  :=
    f_into (array_from_list [ret_both (42 : int8);
      ret_both (134 : int8);
      ret_both (72 : int8);
      ret_both (206 : int8);
      ret_both (61 : int8);
      ret_both (3 : int8);
      ret_both (1 : int8);
      ret_both (7 : int8)]) : both t_Bytes.
Fail Next Obligation.

Equations rsa_pkcs1_encryption_oid (_ : both 'unit) : both t_Bytes :=
  rsa_pkcs1_encryption_oid _  :=
    f_into (array_from_list [ret_both (42 : int8);
      ret_both (134 : int8);
      ret_both (72 : int8);
      ret_both (134 : int8);
      ret_both (247 : int8);
      ret_both (13 : int8);
      ret_both (1 : int8);
      ret_both (1 : int8);
      ret_both (1 : int8)]) : both t_Bytes.
Fail Next Obligation.

Equations x962_ec_public_key_oid (_ : both 'unit) : both t_Bytes :=
  x962_ec_public_key_oid _  :=
    f_into (array_from_list [ret_both (42 : int8);
      ret_both (134 : int8);
      ret_both (72 : int8);
      ret_both (206 : int8);
      ret_both (61 : int8);
      ret_both (2 : int8);
      ret_both (1 : int8)]) : both t_Bytes.
Fail Next Obligation.

Equations check_tag (b : both t_Bytes) (offset : both uint_size) (value : both int8) : both (t_Result 'unit int8) :=
  check_tag b offset value  :=
    ifb (f_declassify (b.a[offset])) =.? value
    then Result_Ok (ret_both (tt : 'unit))
    else asn1_error v_ASN1_INVALID_TAG : both (t_Result 'unit int8).
Fail Next Obligation.

Equations length_length (b : both t_Bytes) (offset : both uint_size) : both uint_size :=
  length_length b offset  :=
    ifb ((f_declassify (b.a[offset])) shift_right (ret_both (7 : int32))) =.? (ret_both (1 : int8))
    then cast_int (WS2 := _) ((f_declassify (b.a[offset])) .& (ret_both (127 : int8)))
    else ret_both (0 : uint_size) : both uint_size.
Fail Next Obligation.

Equations read_octet_header (b : both t_Bytes) (offset : both uint_size) : both (t_Result uint_size int8) :=
  read_octet_header b offset  :=
    run (letm[choice_typeMonad.result_bind_code int8] _ := check_tag b offset (ret_both (4 : int8)) in
    Result_Ok (letb offset := offset .+ (ret_both (1 : uint_size)) in
    letb length_length := length_length b offset in
    letb offset := (offset .+ length_length) .+ (ret_both (1 : uint_size)) in
    Result_Ok offset)) : both (t_Result uint_size int8).
Fail Next Obligation.

Equations read_sequence_header (b : both t_Bytes) (offset : both uint_size) : both (t_Result uint_size int8) :=
  read_sequence_header b offset  :=
    run (letm[choice_typeMonad.result_bind_code int8] _ := check_tag b offset (ret_both (48 : int8)) in
    Result_Ok (letb offset := offset .+ (ret_both (1 : uint_size)) in
    letb length_length := length_length b offset in
    letb offset := (offset .+ length_length) .+ (ret_both (1 : uint_size)) in
    Result_Ok offset)) : both (t_Result uint_size int8).
Fail Next Obligation.

Equations short_length (b : both t_Bytes) (offset : both uint_size) : both (t_Result uint_size int8) :=
  short_length b offset  :=
    ifb ((f_declassify (b.a[offset])) .& (ret_both (128 : int8))) =.? (ret_both (0 : int8))
    then Result_Ok (cast_int (WS2 := _) ((f_declassify (b.a[offset])) .& (ret_both (127 : int8))))
    else asn1_error v_ASN1_ERROR : both (t_Result uint_size int8).
Fail Next Obligation.

Equations read_version_number (b : both t_Bytes) (offset : both uint_size) : both (t_Result uint_size int8) :=
  read_version_number b offset  :=
    run (matchb check_tag b offset (ret_both (160 : int8)) with
    | Result_Ok_case _ =>
      letb _ := ret_both (tt (* Empty tuple *) : ('unit)) in
      letb offset := offset .+ (ret_both (1 : uint_size)) in
      letm[choice_typeMonad.result_bind_code int8] length := short_length b offset in
      Result_Ok (Result_Ok ((offset .+ (ret_both (1 : uint_size))) .+ length))
    | Result_Err_case _ =>
      letb _ := ret_both (tt (* Empty tuple *) : (int8)) in
      Result_Ok (Result_Ok offset)
    end) : both (t_Result uint_size int8).
Fail Next Obligation.

Equations long_length (b : both t_Bytes) (offset : both uint_size) (len : both uint_size) : both (t_Result uint_size int8) :=
  long_length b offset len  :=
    ifb len >.? (ret_both (4 : uint_size))
    then asn1_error v_ASN1_SEQUENCE_TOO_LONG
    else letb u32word := repeat (v_U8 (ret_both (0 : int8))) (ret_both (4 : uint_size)) in
    letb u32word := update_at_range u32word (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := len)) (impl__copy_from_slice (u32word.a[(Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := len))]) (b.a[(Build_t_Range (f_start := offset) (f_end := offset .+ len))])) in
    Result_Ok ((cast_int (WS2 := _) (f_declassify (u32_from_be_bytes u32word))) shift_right (((ret_both (4 : uint_size)) .- len) .* (ret_both (8 : uint_size)))) : both (t_Result uint_size int8).
Fail Next Obligation.

Equations length (b : both t_Bytes) (offset : both uint_size) : both (t_Result (uint_size × uint_size) int8) :=
  length b offset  :=
    run (ifb ((f_declassify (b.a[offset])) .& (ret_both (128 : int8))) =.? (ret_both (0 : int8))
    then letm[choice_typeMonad.result_bind_code int8] len := short_length b offset in
    Result_Ok (Result_Ok (prod_b (offset .+ (ret_both (1 : uint_size)),len)))
    else letb len := length_length b offset in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] end := long_length b offset len in
    Result_Ok (Result_Ok (prod_b (offset .+ len,end)))) : both (t_Result (uint_size × uint_size) int8).
Fail Next Obligation.

Equations skip_integer (b : both t_Bytes) (offset : both uint_size) : both (t_Result uint_size int8) :=
  skip_integer b offset  :=
    run (letm[choice_typeMonad.result_bind_code int8] _ := check_tag b offset (ret_both (2 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,length) := length b offset in
    Result_Ok (Result_Ok (offset .+ length))) : both (t_Result uint_size int8).
Fail Next Obligation.

Equations skip_sequence (b : both t_Bytes) (offset : both uint_size) : both (t_Result uint_size int8) :=
  skip_sequence b offset  :=
    run (letm[choice_typeMonad.result_bind_code int8] _ := check_tag b offset (ret_both (48 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,length) := length b offset in
    Result_Ok (Result_Ok (offset .+ length))) : both (t_Result uint_size int8).
Fail Next Obligation.

Equations read_spki (cert : both t_Bytes) (offset : both uint_size) : both (t_Result (t_SignatureScheme × t_CertificateKey) int8) :=
  read_spki cert offset  :=
    run (letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (48 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,v__seq_len) := length cert offset in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (48 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,seq_len) := length cert offset in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (6 : int8)) in
    letm[choice_typeMonad.result_bind_code int8] '(oid_offset,oid_len) := length cert (offset .+ (ret_both (1 : uint_size))) in
    letb '(ec_pk_oid,ecdsa_p256,rsa_pk_oid) := prod_b (ret_both (false : 'bool),ret_both (false : 'bool),ret_both (false : 'bool)) in
    letb ec_oid := x962_ec_public_key_oid in
    letb rsa_oid := rsa_pkcs1_encryption_oid in
    letm[choice_typeMonad.result_bind_code int8] '(ec_pk_oid,ecdsa_p256,oid_offset) := ifb (impl__Bytes__len ec_oid) =.? oid_len
    then letb ec_pk_oid := ret_both (true : 'bool) in
    letb ec_pk_oid := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := impl__Bytes__len ec_oid))) (fun i =>
      ssp (fun ec_pk_oid =>
        letb oid_byte_equal := (f_declassify (cert.a[(oid_offset .+ i)])) =.? (f_declassify (ec_oid.a[i])) in
        letb ec_pk_oid := andb ec_pk_oid oid_byte_equal in
        ec_pk_oid : (both 'bool))) ec_pk_oid in
    ifb ec_pk_oid
    then letb oid_offset := oid_offset .+ oid_len in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert oid_offset (ret_both (6 : int8)) in
    letb oid_offset := oid_offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(oid_offset,v__oid_len) := length cert oid_offset in
    letb ecdsa_p256 := ret_both (true : 'bool) in
    letb ec_oid := ecdsa_secp256r1_sha256_oid in
    letb ecdsa_p256 := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := impl__Bytes__len ec_oid))) (fun i =>
      ssp (fun ecdsa_p256 =>
        letb oid_byte_equal := (f_declassify (cert.a[(oid_offset .+ i)])) =.? (f_declassify (ec_oid.a[i])) in
        letb ecdsa_p256 := andb ecdsa_p256 oid_byte_equal in
        ecdsa_p256 : (both 'bool))) ecdsa_p256 in
    letm[choice_typeMonad.result_bind_code int8] _ := check_success ecdsa_p256 in
    Result_Ok (prod_b (ec_pk_oid,ecdsa_p256,oid_offset))
    else Result_Ok (prod_b (ec_pk_oid,ecdsa_p256,oid_offset))
    else Result_Ok (prod_b (ec_pk_oid,ecdsa_p256,oid_offset)) in
    letb rsa_pk_oid := ifb (impl__Bytes__len rsa_oid) =.? oid_len
    then letb rsa_pk_oid := ret_both (true : 'bool) in
    foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := impl__Bytes__len rsa_oid))) (fun i =>
      ssp (fun rsa_pk_oid =>
        letb oid_byte_equal := (f_declassify (cert.a[(oid_offset .+ i)])) =.? (f_declassify (rsa_oid.a[i])) in
        letb rsa_pk_oid := andb rsa_pk_oid oid_byte_equal in
        rsa_pk_oid : (both 'bool))) rsa_pk_oid
    else rsa_pk_oid in
    letm[choice_typeMonad.result_bind_code int8] _ := check_success (orb (andb ec_pk_oid ecdsa_p256) rsa_pk_oid) in
    letb offset := offset .+ seq_len in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (3 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,bit_string_len) := length cert offset in
    Result_Ok (letb offset := ifb (f_declassify (cert.a[offset])) =.? (ret_both (0 : int8))
    then letb offset := offset .+ (ret_both (1 : uint_size)) in
    offset
    else offset in
    ifb andb ec_pk_oid ecdsa_p256
    then Result_Ok (prod_b (SignatureScheme_EcdsaSecp256r1Sha256,CertificateKey offset (bit_string_len .- (ret_both (1 : uint_size)))))
    else ifb rsa_pk_oid
    then Result_Ok (prod_b (SignatureScheme_RsaPssRsaSha256,CertificateKey offset (bit_string_len .- (ret_both (1 : uint_size)))))
    else asn1_error v_ASN1_INVALID_CERTIFICATE)) : both (t_Result (t_SignatureScheme × t_CertificateKey) int8).
Fail Next Obligation.

Equations verification_key_from_cert (cert : both t_Bytes) : both (t_Result (t_SignatureScheme × t_CertificateKey) int8) :=
  verification_key_from_cert cert  :=
    run (letm[choice_typeMonad.result_bind_code int8] offset := read_sequence_header cert (ret_both (0 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] hoist52 := read_sequence_header cert offset in
    letb offset := hoist52 in
    letm[choice_typeMonad.result_bind_code int8] hoist53 := read_version_number cert offset in
    letb offset := hoist53 in
    letm[choice_typeMonad.result_bind_code int8] hoist54 := skip_integer cert offset in
    letb offset := hoist54 in
    letm[choice_typeMonad.result_bind_code int8] hoist55 := skip_sequence cert offset in
    letb offset := hoist55 in
    letm[choice_typeMonad.result_bind_code int8] hoist56 := skip_sequence cert offset in
    letb offset := hoist56 in
    letm[choice_typeMonad.result_bind_code int8] hoist57 := skip_sequence cert offset in
    letb offset := hoist57 in
    letm[choice_typeMonad.result_bind_code int8] hoist58 := skip_sequence cert offset in
    Result_Ok (letb offset := hoist58 in
    read_spki cert offset)) : both (t_Result (t_SignatureScheme × t_CertificateKey) int8).
Fail Next Obligation.

Equations ecdsa_public_key (cert : both t_Bytes) (indices : both t_CertificateKey) : both (t_Result t_Bytes int8) :=
  ecdsa_public_key cert indices  :=
    run (letb CertificateKey (offset,len) := indices in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (4 : int8)) in
    Result_Ok (Result_Ok (impl__Bytes__slice cert (offset .+ (ret_both (1 : uint_size))) (len .- (ret_both (1 : uint_size)))))) : both (t_Result t_Bytes int8).
Fail Next Obligation.

Equations read_integer (b : both t_Bytes) (offset : both uint_size) : both (t_Result t_Bytes int8) :=
  read_integer b offset  :=
    run (letm[choice_typeMonad.result_bind_code int8] _ := check_tag b offset (ret_both (2 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,length) := length b offset in
    Result_Ok (Result_Ok (impl__Bytes__slice b offset length))) : both (t_Result t_Bytes int8).
Fail Next Obligation.

Equations rsa_private_key (key : both t_Bytes) : both (t_Result t_Bytes int8) :=
  rsa_private_key key  :=
    run (letm[choice_typeMonad.result_bind_code int8] offset := read_sequence_header key (ret_both (0 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] hoist67 := skip_integer key offset in
    letb offset := hoist67 in
    letm[choice_typeMonad.result_bind_code int8] hoist68 := skip_sequence key offset in
    letb offset := hoist68 in
    letm[choice_typeMonad.result_bind_code int8] hoist69 := read_octet_header key offset in
    letb offset := hoist69 in
    letm[choice_typeMonad.result_bind_code int8] hoist70 := read_sequence_header key offset in
    letb offset := hoist70 in
    letm[choice_typeMonad.result_bind_code int8] hoist71 := skip_integer key offset in
    letb offset := hoist71 in
    letm[choice_typeMonad.result_bind_code int8] hoist72 := skip_integer key offset in
    letb offset := hoist72 in
    letm[choice_typeMonad.result_bind_code int8] hoist73 := skip_integer key offset in
    Result_Ok (letb offset := hoist73 in
    read_integer key offset)) : both (t_Result t_Bytes int8).
Fail Next Obligation.

Equations rsa_public_key (cert : both t_Bytes) (indices : both t_CertificateKey) : both (t_Result t_RsaVerificationKey int8) :=
  rsa_public_key cert indices  :=
    run (letb CertificateKey (offset,v__len) := indices in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (48 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,v__seq_len) := length cert offset in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (2 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,int_len) := length cert offset in
    letb n := impl__Bytes__slice cert offset int_len in
    letb offset := offset .+ int_len in
    letm[choice_typeMonad.result_bind_code int8] _ := check_tag cert offset (ret_both (2 : int8)) in
    letb offset := offset .+ (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] '(offset,int_len) := length cert offset in
    Result_Ok (letb e := impl__Bytes__slice cert offset int_len in
    Result_Ok (Build_t_RsaVerificationKey (f_modulus := n) (f_exponent := e)))) : both (t_Result t_RsaVerificationKey int8).
Fail Next Obligation.

(*item error backend*)
