(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(* Require Import RsaPssKeySize. *)
(* Export RsaPssKeySize. *)

(* Require Import RsaPssPrivateKey. *)
(* Export RsaPssPrivateKey. *)

(* Require Import RsaPssPublicKey. *)
(* Export RsaPssPublicKey. *)

(* Require Import Libcrux. *)
(* Export Libcrux. *)

(* Require Import Ct. *)
(* Export Ct. *)

(* Require Import PrivateKey. *)
(* Export PrivateKey. *)

(* Require Import PublicKey. *)
(* Export PublicKey. *)

(* Require Import CryptoRng. *)
(* Export CryptoRng. *)

(* Require Import RngCore. *)
(* Export RngCore. *)

(* Require Import Display. *)
(* Export Display. *)

(* Require Import check_mem. *)
(* Export check_mem. *)

(* Require Import eq. *)
(* Export eq. *)

(* Require Import length_u16_encoded. *)
(* Export length_u16_encoded. *)

(* Require Import tlserr. *)
(* Export tlserr. *)

(* Require Import Bytes. *)
(* Export Bytes. *)

(* Require Import Error. *)
(* Export Error. *)

(* Require Import TLSError. *)
(* Export TLSError. *)

From BertieExtraction Require Import Bertie_Tls13utils.

(* Require Import CRYPTO_ERROR. *)
(* Export CRYPTO_ERROR. *)

(* Require Import INVALID_SIGNATURE. *)
(* Export INVALID_SIGNATURE. *)

(* Require Import U8. *)
(* Export U8. *)

(* Require Import UNSUPPORTED_ALGORITHM. *)
(* Export UNSUPPORTED_ALGORITHM. *)

From BertieExtraction Require Import Fixes.

Definition t_AeadAlgorithm : choice_type :=
  ('unit ∐ 'unit ∐ 'unit).
Notation "'AeadAlgorithm_Chacha20Poly1305_case'" := (inl (inl tt)) (at level 100).
Equations AeadAlgorithm_Chacha20Poly1305 : both t_AeadAlgorithm :=
  AeadAlgorithm_Chacha20Poly1305  :=
    ret_both (inl (inl (tt : 'unit)) : t_AeadAlgorithm) : both t_AeadAlgorithm.
Fail Next Obligation.
Notation "'AeadAlgorithm_Aes128Gcm_case'" := (inl (inr tt)) (at level 100).
Equations AeadAlgorithm_Aes128Gcm : both t_AeadAlgorithm :=
  AeadAlgorithm_Aes128Gcm  :=
    ret_both (inl (inr (tt : 'unit)) : t_AeadAlgorithm) : both t_AeadAlgorithm.
Fail Next Obligation.
Notation "'AeadAlgorithm_Aes256Gcm_case'" := (inr tt) (at level 100).
Equations AeadAlgorithm_Aes256Gcm : both t_AeadAlgorithm :=
  AeadAlgorithm_Aes256Gcm  :=
    ret_both (inr (tt : 'unit) : t_AeadAlgorithm) : both t_AeadAlgorithm.
Fail Next Obligation.

Equations impl__AeadAlgorithm__iv_len (self : both t_AeadAlgorithm) : both uint_size :=
  impl__AeadAlgorithm__iv_len self  :=
    matchb self with
    | AeadAlgorithm_Chacha20Poly1305_case  =>
      ret_both (12 : uint_size)
    | AeadAlgorithm_Aes128Gcm_case  =>
      ret_both (12 : uint_size)
    | AeadAlgorithm_Aes256Gcm_case  =>
      ret_both (12 : uint_size)
    end : both uint_size.
Fail Next Obligation.

Equations impl__AeadAlgorithm__key_len (self : both t_AeadAlgorithm) : both uint_size :=
  impl__AeadAlgorithm__key_len self  :=
    matchb self with
    | AeadAlgorithm_Chacha20Poly1305_case  =>
      ret_both (32 : uint_size)
    | AeadAlgorithm_Aes128Gcm_case  =>
      ret_both (16 : uint_size)
    | AeadAlgorithm_Aes256Gcm_case  =>
      ret_both (32 : uint_size)
    end : both uint_size.
Fail Next Obligation.

Equations t_AeadAlgorithm_cast_to_repr (x : both t_AeadAlgorithm) : both uint_size :=
  t_AeadAlgorithm_cast_to_repr x  :=
    matchb x with
    | AeadAlgorithm_Chacha20Poly1305_case  =>
      ret_both (0 : uint_size)
    | AeadAlgorithm_Aes128Gcm_case  =>
      ret_both (1 : uint_size)
    | AeadAlgorithm_Aes256Gcm_case  =>
      ret_both (3 : uint_size)
    end : both uint_size.
Fail Next Obligation.

Definition t_HashAlgorithm : choice_type :=
  ('unit ∐ 'unit ∐ 'unit).
Notation "'HashAlgorithm_SHA256_case'" := (inl (inl tt)) (at level 100).
Equations HashAlgorithm_SHA256 : both t_HashAlgorithm :=
  HashAlgorithm_SHA256  :=
    ret_both (inl (inl (tt : 'unit)) : t_HashAlgorithm) : both t_HashAlgorithm.
Fail Next Obligation.
Notation "'HashAlgorithm_SHA384_case'" := (inl (inr tt)) (at level 100).
Equations HashAlgorithm_SHA384 : both t_HashAlgorithm :=
  HashAlgorithm_SHA384  :=
    ret_both (inl (inr (tt : 'unit)) : t_HashAlgorithm) : both t_HashAlgorithm.
Fail Next Obligation.
Notation "'HashAlgorithm_SHA512_case'" := (inr tt) (at level 100).
Equations HashAlgorithm_SHA512 : both t_HashAlgorithm :=
  HashAlgorithm_SHA512  :=
    ret_both (inr (tt : 'unit) : t_HashAlgorithm) : both t_HashAlgorithm.
Fail Next Obligation.

Equations t_HashAlgorithm_cast_to_repr (x : both t_HashAlgorithm) : both uint_size :=
  t_HashAlgorithm_cast_to_repr x  :=
    matchb x with
    | HashAlgorithm_SHA256_case  =>
      ret_both (0 : uint_size)
    | HashAlgorithm_SHA384_case  =>
      ret_both (1 : uint_size)
    | HashAlgorithm_SHA512_case  =>
      ret_both (3 : uint_size)
    end : both uint_size.
Fail Next Obligation.

Definition t_KemScheme : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'KemScheme_X25519_case'" := (inl (inl (inl (inl (inl tt))))) (at level 100).
Equations KemScheme_X25519 : both t_KemScheme :=
  KemScheme_X25519  :=
    ret_both (inl (inl (inl (inl (inl (tt : 'unit))))) : t_KemScheme) : both t_KemScheme.
Fail Next Obligation.
Notation "'KemScheme_Secp256r1_case'" := (inl (inl (inl (inl (inr tt))))) (at level 100).
Equations KemScheme_Secp256r1 : both t_KemScheme :=
  KemScheme_Secp256r1  :=
    ret_both (inl (inl (inl (inl (inr (tt : 'unit))))) : t_KemScheme) : both t_KemScheme.
Fail Next Obligation.
Notation "'KemScheme_X448_case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations KemScheme_X448 : both t_KemScheme :=
  KemScheme_X448  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_KemScheme) : both t_KemScheme.
Fail Next Obligation.
Notation "'KemScheme_Secp384r1_case'" := (inl (inl (inr tt))) (at level 100).
Equations KemScheme_Secp384r1 : both t_KemScheme :=
  KemScheme_Secp384r1  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_KemScheme) : both t_KemScheme.
Fail Next Obligation.
Notation "'KemScheme_Secp521r1_case'" := (inl (inr tt)) (at level 100).
Equations KemScheme_Secp521r1 : both t_KemScheme :=
  KemScheme_Secp521r1  :=
    ret_both (inl (inr (tt : 'unit)) : t_KemScheme) : both t_KemScheme.
Fail Next Obligation.
Notation "'KemScheme_X25519Kyber768Draft00_case'" := (inr tt) (at level 100).
Equations KemScheme_X25519Kyber768Draft00 : both t_KemScheme :=
  KemScheme_X25519Kyber768Draft00  :=
    ret_both (inr (tt : 'unit) : t_KemScheme) : both t_KemScheme.
Fail Next Obligation.

Equations t_KemScheme_cast_to_repr (x : both t_KemScheme) : both uint_size :=
  t_KemScheme_cast_to_repr x  :=
    matchb x with
    | KemScheme_X25519_case  =>
      ret_both (0 : uint_size)
    | KemScheme_Secp256r1_case  =>
      ret_both (1 : uint_size)
    | KemScheme_X448_case  =>
      ret_both (3 : uint_size)
    | KemScheme_Secp384r1_case  =>
      ret_both (6 : uint_size)
    | KemScheme_Secp521r1_case  =>
      ret_both (10 : uint_size)
    | KemScheme_X25519Kyber768Draft00_case  =>
      ret_both (15 : uint_size)
    end : both uint_size.
Fail Next Obligation.

Definition t_SignatureScheme : choice_type :=
  ('unit ∐ 'unit ∐ 'unit).
Notation "'SignatureScheme_RsaPssRsaSha256_case'" := (inl (inl tt)) (at level 100).
Equations SignatureScheme_RsaPssRsaSha256 : both t_SignatureScheme :=
  SignatureScheme_RsaPssRsaSha256  :=
    ret_both (inl (inl (tt : 'unit)) : t_SignatureScheme) : both t_SignatureScheme.
Fail Next Obligation.
Notation "'SignatureScheme_EcdsaSecp256r1Sha256_case'" := (inl (inr tt)) (at level 100).
Equations SignatureScheme_EcdsaSecp256r1Sha256 : both t_SignatureScheme :=
  SignatureScheme_EcdsaSecp256r1Sha256  :=
    ret_both (inl (inr (tt : 'unit)) : t_SignatureScheme) : both t_SignatureScheme.
Fail Next Obligation.
Notation "'SignatureScheme_ED25519_case'" := (inr tt) (at level 100).
Equations SignatureScheme_ED25519 : both t_SignatureScheme :=
  SignatureScheme_ED25519  :=
    ret_both (inr (tt : 'unit) : t_SignatureScheme) : both t_SignatureScheme.
Fail Next Obligation.

Equations t_SignatureScheme_cast_to_repr (x : both t_SignatureScheme) : both uint_size :=
  t_SignatureScheme_cast_to_repr x  :=
    matchb x with
    | SignatureScheme_RsaPssRsaSha256_case  =>
      ret_both (0 : uint_size)
    | SignatureScheme_EcdsaSecp256r1Sha256_case  =>
      ret_both (1 : uint_size)
    | SignatureScheme_ED25519_case  =>
      ret_both (3 : uint_size)
    end : both uint_size.
Fail Next Obligation.

Equations valid_rsa_exponent (e : both (t_Vec int8 t_Global)) : both 'bool :=
  valid_rsa_exponent e  :=
    andb (andb (andb ((Hacspec.Hacspec_Lib_TODO.len e) =.? (ret_both (3 : uint_size))) ((e.a[(ret_both (0 : uint_size))]) =.? (ret_both (1 : int8)))) ((e.a[(ret_both (1 : uint_size))]) =.? (ret_both (0 : int8)))) ((e.a[(ret_both (2 : uint_size))]) =.? (ret_both (1 : int8))) : both 'bool.
Fail Next Obligation.

Equations impl__HashAlgorithm__libcrux_algorithm (self : both t_HashAlgorithm) : both (t_Result Digest.t_Algorithm int8) :=
  impl__HashAlgorithm__libcrux_algorithm self  :=
    matchb self with
    | HashAlgorithm_SHA256_case  =>
      Result_Ok Digest.Algorithm_Sha256
    | HashAlgorithm_SHA384_case  =>
      Result_Ok Digest.Algorithm_Sha384
    | HashAlgorithm_SHA512_case  =>
      Result_Ok Digest.Algorithm_Sha512
    end : both (t_Result Digest.t_Algorithm int8).
Fail Next Obligation.

Equations impl__HashAlgorithm__hash_len (self : both t_HashAlgorithm) : both uint_size :=
  impl__HashAlgorithm__hash_len self  :=
    matchb self with
    | HashAlgorithm_SHA256_case  =>
      Digest.digest_size Digest.Algorithm_Sha256
    | HashAlgorithm_SHA384_case  =>
      Digest.digest_size Digest.Algorithm_Sha384
    | HashAlgorithm_SHA512_case  =>
      Digest.digest_size Digest.Algorithm_Sha512
    end : both uint_size.
Fail Next Obligation.

Equations impl__HashAlgorithm__hmac_tag_len (self : both t_HashAlgorithm) : both uint_size :=
  impl__HashAlgorithm__hmac_tag_len self  :=
    impl__HashAlgorithm__hash_len self : both uint_size.
Fail Next Obligation.

Equations hkdf_algorithm (alg : both t_HashAlgorithm) : both (t_Result Hkdf.t_Algorithm int8) :=
  hkdf_algorithm alg  :=
    matchb alg with
    | HashAlgorithm_SHA256_case  =>
      Result_Ok Hkdf.Algorithm_Sha256
    | HashAlgorithm_SHA384_case  =>
      Result_Ok Hkdf.Algorithm_Sha384
    | HashAlgorithm_SHA512_case  =>
      Result_Ok Hkdf.Algorithm_Sha512
    end : both (t_Result Hkdf.t_Algorithm int8).
Fail Next Obligation.

Equations impl__HashAlgorithm__hmac_algorithm (self : both t_HashAlgorithm) : both (t_Result Digest.t_Algorithm int8) :=
  impl__HashAlgorithm__hmac_algorithm self  :=
    matchb self with
    | HashAlgorithm_SHA256_case  =>
      Result_Ok Digest.Algorithm_Sha256
    | HashAlgorithm_SHA384_case  =>
      Result_Ok Digest.Algorithm_Sha384
    | HashAlgorithm_SHA512_case  =>
      Result_Ok Digest.Algorithm_Sha512
    end : both (t_Result Digest.t_Algorithm int8).
Fail Next Obligation.

Equations impl__SignatureScheme__libcrux_scheme (self : both t_SignatureScheme) : both (t_Result Signature.t_Algorithm int8) :=
  impl__SignatureScheme__libcrux_scheme self  :=
    matchb self with
    | SignatureScheme_RsaPssRsaSha256_case  =>
      Result_Ok (Signature.Algorithm_RsaPss Signature.DigestAlgorithm_Sha256)
    | SignatureScheme_ED25519_case  =>
      Result_Ok Signature.Algorithm_Ed25519
    | SignatureScheme_EcdsaSecp256r1Sha256_case  =>
      Result_Ok (Signature.Algorithm_EcDsaP256 Signature.DigestAlgorithm_Sha256)
    end : both (t_Result Signature.t_Algorithm int8).
Fail Next Obligation.

Equations impl__KemScheme__libcrux_kem_algorithm (self : both t_KemScheme) : both (t_Result Libcrux_kem.t_Algorithm int8) :=
  impl__KemScheme__libcrux_kem_algorithm self  :=
    matchb self with
    | KemScheme_X25519_case  =>
      Result_Ok Libcrux_kem.Algorithm_X25519
    | KemScheme_Secp256r1_case  =>
      Result_Ok Libcrux_kem.Algorithm_Secp256r1
    | KemScheme_X25519Kyber768Draft00_case  =>
      Result_Ok Libcrux_kem.Algorithm_X25519Kyber768Draft00
    | _ =>
      tlserr v_UNSUPPORTED_ALGORITHM
    end : both (t_Result Libcrux_kem.t_Algorithm int8).
Fail Next Obligation.

Definition t_Algorithms : choice_type :=
  (t_HashAlgorithm × t_AeadAlgorithm × t_SignatureScheme × t_KemScheme × 'bool × 'bool).
Equations f_hash (s : both t_Algorithms) : both t_HashAlgorithm :=
  f_hash s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst x)))) : t_HashAlgorithm)) : both t_HashAlgorithm.
Fail Next Obligation.
Equations f_aead (s : both t_Algorithms) : both t_AeadAlgorithm :=
  f_aead s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_AeadAlgorithm)) : both t_AeadAlgorithm.
Fail Next Obligation.
Equations f_signature (s : both t_Algorithms) : both t_SignatureScheme :=
  f_signature s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_SignatureScheme)) : both t_SignatureScheme.
Fail Next Obligation.
Equations f_kem (s : both t_Algorithms) : both t_KemScheme :=
  f_kem s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_KemScheme)) : both t_KemScheme.
Fail Next Obligation.
Equations f_psk_mode (s : both t_Algorithms) : both 'bool :=
  f_psk_mode s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : 'bool)) : both 'bool.
Fail Next Obligation.
Equations f_zero_rtt (s : both t_Algorithms) : both 'bool :=
  f_zero_rtt s  :=
    bind_both s (fun x =>
      ret_both (snd x : 'bool)) : both 'bool.
Fail Next Obligation.
Equations Build_t_Algorithms {f_hash : both t_HashAlgorithm} {f_aead : both t_AeadAlgorithm} {f_signature : both t_SignatureScheme} {f_kem : both t_KemScheme} {f_psk_mode : both 'bool} {f_zero_rtt : both 'bool} : both (t_Algorithms) :=
  Build_t_Algorithms  :=
    bind_both f_zero_rtt (fun f_zero_rtt =>
      bind_both f_psk_mode (fun f_psk_mode =>
        bind_both f_kem (fun f_kem =>
          bind_both f_signature (fun f_signature =>
            bind_both f_aead (fun f_aead =>
              bind_both f_hash (fun f_hash =>
                ret_both ((f_hash,f_aead,f_signature,f_kem,f_psk_mode,f_zero_rtt) : (t_Algorithms)))))))) : both (t_Algorithms).
Fail Next Obligation.
Notation "'Build_t_Algorithms' '[' x ']' '(' 'f_hash' ':=' y ')'" := (Build_t_Algorithms (f_hash := y) (f_aead := f_aead x) (f_signature := f_signature x) (f_kem := f_kem x) (f_psk_mode := f_psk_mode x) (f_zero_rtt := f_zero_rtt x)).
Notation "'Build_t_Algorithms' '[' x ']' '(' 'f_aead' ':=' y ')'" := (Build_t_Algorithms (f_hash := f_hash x) (f_aead := y) (f_signature := f_signature x) (f_kem := f_kem x) (f_psk_mode := f_psk_mode x) (f_zero_rtt := f_zero_rtt x)).
Notation "'Build_t_Algorithms' '[' x ']' '(' 'f_signature' ':=' y ')'" := (Build_t_Algorithms (f_hash := f_hash x) (f_aead := f_aead x) (f_signature := y) (f_kem := f_kem x) (f_psk_mode := f_psk_mode x) (f_zero_rtt := f_zero_rtt x)).
Notation "'Build_t_Algorithms' '[' x ']' '(' 'f_kem' ':=' y ')'" := (Build_t_Algorithms (f_hash := f_hash x) (f_aead := f_aead x) (f_signature := f_signature x) (f_kem := y) (f_psk_mode := f_psk_mode x) (f_zero_rtt := f_zero_rtt x)).
Notation "'Build_t_Algorithms' '[' x ']' '(' 'f_psk_mode' ':=' y ')'" := (Build_t_Algorithms (f_hash := f_hash x) (f_aead := f_aead x) (f_signature := f_signature x) (f_kem := f_kem x) (f_psk_mode := y) (f_zero_rtt := f_zero_rtt x)).
Notation "'Build_t_Algorithms' '[' x ']' '(' 'f_zero_rtt' ':=' y ')'" := (Build_t_Algorithms (f_hash := f_hash x) (f_aead := f_aead x) (f_signature := f_signature x) (f_kem := f_kem x) (f_psk_mode := f_psk_mode x) (f_zero_rtt := y)).

Equations impl__Algorithms__aead (self : both t_Algorithms) : both t_AeadAlgorithm :=
  impl__Algorithms__aead self  :=
    f_aead self : both t_AeadAlgorithm.
Fail Next Obligation.

Equations impl__Algorithms__hash (self : both t_Algorithms) : both t_HashAlgorithm :=
  impl__Algorithms__hash self  :=
    f_hash self : both t_HashAlgorithm.
Fail Next Obligation.

Equations impl__Algorithms__kem (self : both t_Algorithms) : both t_KemScheme :=
  impl__Algorithms__kem self  :=
    f_kem self : both t_KemScheme.
Fail Next Obligation.

Equations impl__Algorithms__new (hash : both t_HashAlgorithm) (aead : both t_AeadAlgorithm) (sig : both t_SignatureScheme) (kem : both t_KemScheme) (psk : both 'bool) (zero_rtt : both 'bool) : both t_Algorithms :=
  impl__Algorithms__new hash aead sig kem psk zero_rtt  :=
    Build_t_Algorithms (f_hash := hash) (f_aead := aead) (f_signature := sig) (f_kem := kem) (f_psk_mode := psk) (f_zero_rtt := zero_rtt) : both t_Algorithms.
Fail Next Obligation.

Equations impl__Algorithms__psk_mode (self : both t_Algorithms) : both 'bool :=
  impl__Algorithms__psk_mode self  :=
    f_psk_mode self : both 'bool.
Fail Next Obligation.

Equations impl__Algorithms__signature (self : both t_Algorithms) : both t_SignatureScheme :=
  impl__Algorithms__signature self  :=
    f_signature self : both t_SignatureScheme.
Fail Next Obligation.

Equations impl__Algorithms__zero_rtt (self : both t_Algorithms) : both 'bool :=
  impl__Algorithms__zero_rtt self  :=
    f_zero_rtt self : both 'bool.
Fail Next Obligation.

(* #[global] Program Instance t_Algorithms_t_Display : t_Display t_Algorithms := *)
(*   let f_fmt := fun  (self : both t_Algorithms) (f : both t_Formatter) => letb '(tmp0,out) := impl_9__write_fmt f (impl_2__new_v1 (array_from_list [ret_both (TLS_ : chString); *)
(*     ret_both (_ : chString); *)
(*     ret_both ( w/  : chString); *)
(*     ret_both ( |  : chString)]) (array_from_list [impl_1__new_debug (f_aead self); *)
(*     impl_1__new_debug (f_hash self); *)
(*     impl_1__new_debug (f_signature self); *)
(*     impl_1__new_debug (f_kem self)])) in *)
(*   letb f := tmp0 in *)
(*   letb hax_temp_output := out in *)
(*   prod_b (f,hax_temp_output) : both (t_Formatter × t_Result 'unit t_Error) in *)
(*   {| f_fmt := (@f_fmt)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Algorithms_t_Display. *)

Equations v_SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_P256 : both t_Algorithms :=
  v_SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_P256  :=
    impl__Algorithms__new HashAlgorithm_SHA256 AeadAlgorithm_Aes128Gcm SignatureScheme_EcdsaSecp256r1Sha256 KemScheme_Secp256r1 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_X25519 : both t_Algorithms :=
  v_SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_X25519  :=
    impl__Algorithms__new HashAlgorithm_SHA256 AeadAlgorithm_Aes128Gcm SignatureScheme_EcdsaSecp256r1Sha256 KemScheme_X25519 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA256_Aes128Gcm_RsaPssRsaSha256_P256 : both t_Algorithms :=
  v_SHA256_Aes128Gcm_RsaPssRsaSha256_P256  :=
    impl__Algorithms__new HashAlgorithm_SHA256 AeadAlgorithm_Aes128Gcm SignatureScheme_RsaPssRsaSha256 KemScheme_Secp256r1 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA256_Aes128Gcm_RsaPssRsaSha256_X25519 : both t_Algorithms :=
  v_SHA256_Aes128Gcm_RsaPssRsaSha256_X25519  :=
    impl__Algorithms__new HashAlgorithm_SHA256 AeadAlgorithm_Aes128Gcm SignatureScheme_RsaPssRsaSha256 KemScheme_X25519 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_P256 : both t_Algorithms :=
  v_SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_P256  :=
    impl__Algorithms__new HashAlgorithm_SHA256 AeadAlgorithm_Chacha20Poly1305 SignatureScheme_EcdsaSecp256r1Sha256 KemScheme_Secp256r1 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519 : both t_Algorithms :=
  v_SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519  :=
    impl__Algorithms__new HashAlgorithm_SHA256 AeadAlgorithm_Chacha20Poly1305 SignatureScheme_EcdsaSecp256r1Sha256 KemScheme_X25519 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519Kyber768Draft00 : both t_Algorithms :=
  v_SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519Kyber768Draft00  :=
    impl__Algorithms__new HashAlgorithm_SHA256 AeadAlgorithm_Chacha20Poly1305 SignatureScheme_EcdsaSecp256r1Sha256 KemScheme_X25519Kyber768Draft00 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA256_Chacha20Poly1305_RsaPssRsaSha256_P256 : both t_Algorithms :=
  v_SHA256_Chacha20Poly1305_RsaPssRsaSha256_P256  :=
    impl__Algorithms__new HashAlgorithm_SHA256 AeadAlgorithm_Chacha20Poly1305 SignatureScheme_RsaPssRsaSha256 KemScheme_Secp256r1 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA256_Chacha20Poly1305_RsaPssRsaSha256_X25519 : both t_Algorithms :=
  v_SHA256_Chacha20Poly1305_RsaPssRsaSha256_X25519  :=
    impl__Algorithms__new HashAlgorithm_SHA256 AeadAlgorithm_Chacha20Poly1305 SignatureScheme_RsaPssRsaSha256 KemScheme_X25519 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_P256 : both t_Algorithms :=
  v_SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_P256  :=
    impl__Algorithms__new HashAlgorithm_SHA384 AeadAlgorithm_Aes256Gcm SignatureScheme_EcdsaSecp256r1Sha256 KemScheme_Secp256r1 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_X25519 : both t_Algorithms :=
  v_SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_X25519  :=
    impl__Algorithms__new HashAlgorithm_SHA384 AeadAlgorithm_Aes256Gcm SignatureScheme_EcdsaSecp256r1Sha256 KemScheme_X25519 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA384_Aes256Gcm_RsaPssRsaSha256_P256 : both t_Algorithms :=
  v_SHA384_Aes256Gcm_RsaPssRsaSha256_P256  :=
    impl__Algorithms__new HashAlgorithm_SHA384 AeadAlgorithm_Aes256Gcm SignatureScheme_RsaPssRsaSha256 KemScheme_Secp256r1 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations v_SHA384_Aes256Gcm_RsaPssRsaSha256_X25519 : both t_Algorithms :=
  v_SHA384_Aes256Gcm_RsaPssRsaSha256_X25519  :=
    impl__Algorithms__new HashAlgorithm_SHA384 AeadAlgorithm_Aes256Gcm SignatureScheme_RsaPssRsaSha256 KemScheme_X25519 (ret_both (false : 'bool)) (ret_both (false : 'bool)) : both t_Algorithms.
Fail Next Obligation.

Equations impl__HashAlgorithm__hash (self : both t_HashAlgorithm) (data : both t_Bytes) : both (t_Result t_Bytes int8) :=
  impl__HashAlgorithm__hash self data  :=
    (* run *) (letm[choice_typeMonad.result_bind_code int8] hoist28 := impl__HashAlgorithm__libcrux_algorithm self in
    (* Result_Ok *) (letb hoist29 := Digest.hash hoist28 (f_deref (impl__Bytes__declassify data)) in
    letb hoist30 := f_into hoist29 in
    Result_Ok hoist30)) : both (t_Result t_Bytes int8).
Fail Next Obligation.

Equations hkdf_expand (alg : both t_HashAlgorithm) (prk : both t_Bytes) (info : both t_Bytes) (len : both uint_size) : both (t_Result t_Bytes int8) :=
  hkdf_expand alg prk info len  :=
    _
    (* run (letm[choice_typeMonad.result_bind_code _ (* int8 *)] hoist31 := hkdf_algorithm alg in *)
    (* (* Result_Ok *) (letb hoist32 := Hkdf.expand hoist31 (impl__Bytes__declassify prk) (impl__Bytes__declassify info) len in *)
    (* matchb hoist32 with *)
    (* | Result_Ok_case x => *)
    (*   letb x := ret_both ((x) : (t_Vec int8 t_Global)) in *)
    (*   Result_Ok (f_into x) *)
    (* | Result_Err_case _ => *)
    (*   letb _ := ret_both (tt (* Empty tuple *) : (Hkdf.t_Error)) in *)
    (*   tlserr v_CRYPTO_ERROR *)
    (* end)) *) : both (t_Result t_Bytes int8).
Admit Obligations.
Fail Next Obligation.

Equations hkdf_extract (alg : both t_HashAlgorithm) (ikm : both t_Bytes) (salt : both t_Bytes) : both (t_Result t_Bytes int8) :=
  hkdf_extract alg ikm salt  :=
    _
    (* run (letm[choice_typeMonad.result_bind_code int8] hoist33 := hkdf_algorithm alg in *)
    (* Result_Ok (letb hoist34 := Hkdf.extract hoist33 (impl__Bytes__declassify salt) (impl__Bytes__declassify ikm) in *)
    (* letb hoist35 := f_into hoist34 in *)
    (* Result_Ok hoist35)) *) : both (t_Result t_Bytes int8).
Admit Obligations.
Fail Next Obligation.

(* Equations hmac_tag (alg : both t_HashAlgorithm) (mk : both t_Bytes) (input : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   hmac_tag alg mk input  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist36 := impl__HashAlgorithm__hmac_algorithm alg in *)
(*     Result_Ok (letb hoist37 := hmac hoist36 (f_deref (impl__Bytes__declassify mk)) (f_deref (impl__Bytes__declassify input)) Option_None in *)
(*     letb hoist38 := f_into hoist37 in *)
(*     Result_Ok hoist38)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations impl__Algorithms__ciphersuite (self : both t_Algorithms) : both (t_Result t_Bytes int8) := *)
(*   impl__Algorithms__ciphersuite self  := *)
(*     matchb prod_b (f_hash self,f_aead self) with *)
(*     | '(HashAlgorithm_SHA256 ,AeadAlgorithm_Aes128Gcm ) => *)
(*       Result_Ok (f_into (array_from_list [ret_both (19 : int8); *)
(*         ret_both (1 : int8)])) *)
(*     | '(HashAlgorithm_SHA384 ,AeadAlgorithm_Aes256Gcm ) => *)
(*       Result_Ok (f_into (array_from_list [ret_both (19 : int8); *)
(*         ret_both (2 : int8)])) *)
(*     | '(HashAlgorithm_SHA256 ,AeadAlgorithm_Chacha20Poly1305 ) => *)
(*       Result_Ok (f_into (array_from_list [ret_both (19 : int8); *)
(*         ret_both (3 : int8)])) *)
(*     | _ => *)
(*       tlserr v_UNSUPPORTED_ALGORITHM *)
(*     end : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations impl__Algorithms__check (self : both t_Algorithms) (bytes : both (seq int8)) : both (t_Result uint_size int8) := *)
(*   impl__Algorithms__check self bytes  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] len := length_u16_encoded bytes in *)
(*     letm[choice_typeMonad.result_bind_code int8] cs := impl__Algorithms__ciphersuite self in *)
(*     letb csl := bytes.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := (ret_both (2 : uint_size)) .+ len))] in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_mem (impl__Bytes__as_raw cs) csl in *)
(*     Result_Ok (Result_Ok (len .+ (ret_both (2 : uint_size))))) : both (t_Result uint_size int8). *)
(* Fail Next Obligation. *)

(* Equations impl__Algorithms__signature_algorithm (self : both t_Algorithms) : both (t_Result t_Bytes int8) := *)
(*   impl__Algorithms__signature_algorithm self  := *)
(*     matchb impl__Algorithms__signature self with *)
(*     | SignatureScheme_RsaPssRsaSha256_case  => *)
(*       Result_Ok (f_into (array_from_list [ret_both (8 : int8); *)
(*         ret_both (4 : int8)])) *)
(*     | SignatureScheme_EcdsaSecp256r1Sha256_case  => *)
(*       Result_Ok (f_into (array_from_list [ret_both (4 : int8); *)
(*         ret_both (3 : int8)])) *)
(*     | SignatureScheme_ED25519_case  => *)
(*       tlserr v_UNSUPPORTED_ALGORITHM *)
(*     end : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations impl__Algorithms__supported_group (self : both t_Algorithms) : both (t_Result t_Bytes int8) := *)
(*   impl__Algorithms__supported_group self  := *)
(*     matchb impl__Algorithms__kem self with *)
(*     | KemScheme_X25519_case  => *)
(*       Result_Ok (f_into (array_from_list [ret_both (0 : int8); *)
(*         ret_both (29 : int8)])) *)
(*     | KemScheme_Secp256r1_case  => *)
(*       Result_Ok (f_into (array_from_list [ret_both (0 : int8); *)
(*         ret_both (23 : int8)])) *)
(*     | KemScheme_X448_case  => *)
(*       tlserr v_UNSUPPORTED_ALGORITHM *)
(*     | KemScheme_Secp384r1_case  => *)
(*       tlserr v_UNSUPPORTED_ALGORITHM *)
(*     | KemScheme_Secp521r1_case  => *)
(*       tlserr v_UNSUPPORTED_ALGORITHM *)
(*     | KemScheme_X25519Kyber768Draft00_case  => *)
(*       Result_Ok (f_into (array_from_list [ret_both (99 : int8); *)
(*         ret_both (153 : int8)])) *)
(*     end : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations sign {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (algorithm : both t_SignatureScheme) (sk : both t_Bytes) (input : both t_Bytes) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result t_Bytes int8) := *)
(*   sign algorithm sk input rng  := *)
(*     run (letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] '(rng,sig) := matchb algorithm with *)
(*     | SignatureScheme_EcdsaSecp256r1Sha256_case  => *)
(*       letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist49 := matchb f_branch (impl__SignatureScheme__libcrux_scheme algorithm) with *)
(*       | ControlFlow_Break_case residual => *)
(*         letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*         letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist48 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in *)
(*         ControlFlow_Continue (never_to_any hoist48) *)
(*       | ControlFlow_Continue_case val => *)
(*         letb val := ret_both ((val) : (t_Algorithm)) in *)
(*         ControlFlow_Continue val *)
(*       end in *)
(*       ControlFlow_Continue (letb '(tmp0,out) := sign hoist49 (f_deref (impl__Bytes__declassify input)) (f_deref (impl__Bytes__declassify sk)) rng in *)
(*       letb rng := tmp0 in *)
(*       prod_b (rng,out)) *)
(*     | SignatureScheme_ED25519_case  => *)
(*       letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist51 := matchb f_branch (impl__SignatureScheme__libcrux_scheme algorithm) with *)
(*       | ControlFlow_Break_case residual => *)
(*         letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*         letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist50 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in *)
(*         ControlFlow_Continue (never_to_any hoist50) *)
(*       | ControlFlow_Continue_case val => *)
(*         letb val := ret_both ((val) : (t_Algorithm)) in *)
(*         ControlFlow_Continue val *)
(*       end in *)
(*       ControlFlow_Continue (letb '(tmp0,out) := sign hoist51 (f_deref (impl__Bytes__declassify input)) (f_deref (impl__Bytes__declassify sk)) rng in *)
(*       letb rng := tmp0 in *)
(*       prod_b (rng,out)) *)
(*     | SignatureScheme_RsaPssRsaSha256_case  => *)
(*       ControlFlow_Continue (prod_b (rng,never_to_any (panic_fmt (impl_2__new_const (array_from_list [ret_both (wrong function, use sign_rsa : chString)]))))) *)
(*     end in *)
(*     ControlFlow_Continue (letb hax_temp_output := matchb sig with *)
(*     | Result_Ok_case Signature_Ed25519 sig => *)
(*       letb sig := ret_both ((((sig))) : (t_Signature)) in *)
(*       Result_Ok (f_into (impl__Ed25519Signature__as_bytes sig)) *)
(*     | Result_Ok_case Signature_EcDsaP256 sig => *)
(*       letb sig := ret_both ((((sig))) : (t_Signature)) in *)
(*       letb '(r,s) := impl__EcDsaP256Signature__as_bytes sig in *)
(*       Result_Ok (impl__Bytes__concat (f_from r) (f_from s)) *)
(*     | Result_Ok_case Signature_RsaPss sig => *)
(*       letb sig := ret_both ((((sig))) : (t_Signature)) in *)
(*       never_to_any (panic_fmt (impl_2__new_const (array_from_list [ret_both (wrong function, use sign_rsa : chString)]))) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (t_Error)) in *)
(*       tlserr v_CRYPTO_ERROR *)
(*     end in *)
(*     prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations supported_rsa_key_size (n : both t_Bytes) : both (t_Result t_RsaPssKeySize int8) := *)
(*   supported_rsa_key_size n  := *)
(*     run (letm[choice_typeMonad.result_bind_code (t_Result t_RsaPssKeySize int8)] key_size := matchb cast_int (WS2 := _) (impl__Bytes__len n) with *)
(*     | 257 => *)
(*       ControlFlow_Continue RsaPssKeySize_N2048 *)
(*     | 385 => *)
(*       ControlFlow_Continue RsaPssKeySize_N3072 *)
(*     | 513 => *)
(*       ControlFlow_Continue RsaPssKeySize_N4096 *)
(*     | 769 => *)
(*       ControlFlow_Continue RsaPssKeySize_N6144 *)
(*     | 1025 => *)
(*       ControlFlow_Continue RsaPssKeySize_N8192 *)
(*     | _ => *)
(*       letm[choice_typeMonad.result_bind_code (t_Result t_RsaPssKeySize int8)] hoist59 := ControlFlow_Break (tlserr v_UNSUPPORTED_ALGORITHM) in *)
(*       ControlFlow_Continue (never_to_any hoist59) *)
(*     end in *)
(*     ControlFlow_Continue (Result_Ok key_size)) : both (t_Result t_RsaPssKeySize int8). *)
(* Fail Next Obligation. *)

(* Equations sign_rsa {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (sk : both t_Bytes) (pk_modulus : both t_Bytes) (pk_exponent : both t_Bytes) (cert_scheme : both t_SignatureScheme) (input : both t_Bytes) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result t_Bytes int8) := *)
(*   sign_rsa sk pk_modulus pk_exponent cert_scheme input rng  := *)
(*     run (letb salt := repeat (ret_both (0 : int8)) (ret_both (32 : uint_size)) in *)
(*     letb '(tmp0,tmp1) := f_fill_bytes rng salt in *)
(*     letb rng := tmp0 in *)
(*     letb salt := tmp1 in *)
(*     letb _ := ret_both (tt : 'unit) in *)
(*     letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] _ := ifb not (matchb cert_scheme with *)
(*     | SignatureScheme_RsaPssRsaSha256_case  => *)
(*       ret_both (true : 'bool) *)
(*     | _ => *)
(*       ret_both (false : 'bool) *)
(*     end) *)
(*     then letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist60 := ControlFlow_Break (prod_b (rng,tlserr v_CRYPTO_ERROR)) in *)
(*     ControlFlow_Continue (never_to_any hoist60) *)
(*     else ControlFlow_Continue (ret_both (tt : 'unit)) in *)
(*     letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] _ := ifb not (valid_rsa_exponent (impl__Bytes__declassify pk_exponent)) *)
(*     then letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist61 := ControlFlow_Break (prod_b (rng,tlserr v_UNSUPPORTED_ALGORITHM)) in *)
(*     ControlFlow_Continue (never_to_any hoist61) *)
(*     else ControlFlow_Continue (ret_both (tt : 'unit)) in *)
(*     letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] key_size := matchb f_branch (supported_rsa_key_size pk_modulus) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist62 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist62) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_RsaPssKeySize)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] pk := matchb f_branch (impl__map_err (impl__RsaPssPublicKey__new key_size ((impl__Bytes__declassify pk_modulus).a[(Build_t_RangeFrom (f_start := ret_both (1 : uint_size)))])) (fun _ => *)
(*       v_CRYPTO_ERROR)) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist63 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist63) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_RsaPssPublicKey)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] sk := matchb f_branch (impl__map_err (impl_5__new pk (f_deref (impl__Bytes__declassify sk))) (fun _ => *)
(*       v_CRYPTO_ERROR)) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist64 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist64) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_RsaPssPrivateKey)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     ControlFlow_Continue (letb msg := impl__Bytes__declassify input in *)
(*     letb sig := impl_5__sign sk DigestAlgorithm_Sha256 (unsize salt) (f_deref msg) in *)
(*     letb hax_temp_output := impl__map_err (impl__map sig (fun sig => *)
(*       f_into (impl__RsaPssSignature__as_bytes sig))) (fun _ => *)
(*       v_CRYPTO_ERROR) in *)
(*     prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations encoding_prefix (alg : both t_KemScheme) : both t_Bytes := *)
(*   encoding_prefix alg  := *)
(*     ifb orb (orb (alg =.? KemScheme_Secp256r1) (alg =.? KemScheme_Secp384r1)) (alg =.? KemScheme_Secp521r1) *)
(*     then f_from (array_from_list [ret_both (4 : int8)]) *)
(*     else impl__Bytes__new : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations kem_keygen {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (alg : both t_KemScheme) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_Bytes × t_Bytes) int8) := *)
(*   kem_keygen alg rng  := *)
(*     run (letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes) int8)] hoist66 := matchb f_branch (impl__KemScheme__libcrux_kem_algorithm alg) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes) int8)] hoist65 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist65) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_Algorithm)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     ControlFlow_Continue (letb '(tmp0,out) := key_gen hoist66 rng in *)
(*     letb rng := tmp0 in *)
(*     letb res := out in *)
(*     letb hax_temp_output := matchb res with *)
(*     | Result_Ok_case (sk,pk) => *)
(*       letb '(sk,pk) := ret_both (((sk,pk)) : (t_PrivateKey × t_PublicKey)) in *)
(*       Result_Ok (prod_b (f_from (impl__PrivateKey__encode sk),impl__Bytes__concat (encoding_prefix alg) (f_from (impl__PublicKey__encode pk)))) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (t_Error)) in *)
(*       tlserr v_CRYPTO_ERROR *)
(*     end in *)
(*     prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result (t_Bytes × t_Bytes) int8). *)
(* Fail Next Obligation. *)

(* Equations into_raw (alg : both t_KemScheme) (point : both t_Bytes) : both t_Bytes := *)
(*   into_raw alg point  := *)
(*     ifb orb (orb (alg =.? KemScheme_Secp256r1) (alg =.? KemScheme_Secp384r1)) (alg =.? KemScheme_Secp521r1) *)
(*     then impl__Bytes__slice_range point (Build_t_Range (f_start := ret_both (1 : uint_size)) (f_end := impl__Bytes__len point)) *)
(*     else point : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations to_shared_secret (alg : both t_KemScheme) (shared_secret : both t_Bytes) : both t_Bytes := *)
(*   to_shared_secret alg shared_secret  := *)
(*     ifb alg =.? KemScheme_Secp256r1 *)
(*     then impl__Bytes__slice_range shared_secret (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := ret_both (32 : uint_size))) *)
(*     else ifb orb (alg =.? KemScheme_Secp384r1) (alg =.? KemScheme_Secp521r1) *)
(*     then never_to_any (panic_fmt (impl_2__new_v1 (array_from_list [ret_both (not implemented: not supported yet : chString)]) impl_1__none)) *)
(*     else shared_secret : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations kem_decap (alg : both t_KemScheme) (ct : both t_Bytes) (sk : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   kem_decap alg ct sk  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] librux_algorithm := impl__KemScheme__libcrux_kem_algorithm alg in *)
(*     Result_Ok (letb sk := impl__unwrap (impl__PrivateKey__decode librux_algorithm (f_deref (impl__Bytes__declassify sk))) in *)
(*     letb ct := impl__Bytes__declassify (into_raw alg (f_clone ct)) in *)
(*     letb ct := impl__unwrap (impl__Ct__decode librux_algorithm (f_deref ct)) in *)
(*     letb res := impl__Ct__decapsulate ct sk in *)
(*     matchb res with *)
(*     | Result_Ok_case shared_secret => *)
(*       letb shared_secret := ret_both ((shared_secret) : (t_Ss)) in *)
(*       letb (shared_secret : t_Bytes) := f_into (impl__Ss__encode shared_secret) in *)
(*       letb shared_secret := to_shared_secret alg shared_secret in *)
(*       Result_Ok shared_secret *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (t_Error)) in *)
(*       tlserr v_CRYPTO_ERROR *)
(*     end)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations kem_encap {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (alg : both t_KemScheme) (pk : both t_Bytes) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_Bytes × t_Bytes) int8) := *)
(*   kem_encap alg pk rng  := *)
(*     run (letb pk := into_raw alg (f_clone pk) in *)
(*     letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes) int8)] hoist75 := matchb f_branch (impl__KemScheme__libcrux_kem_algorithm alg) with *)
(*     | ControlFlow_Break_case residual => *)
(*       letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in *)
(*       letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_Bytes × t_Bytes) int8)] hoist74 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in *)
(*       ControlFlow_Continue (never_to_any hoist74) *)
(*     | ControlFlow_Continue_case val => *)
(*       letb val := ret_both ((val) : (t_Algorithm)) in *)
(*       ControlFlow_Continue val *)
(*     end in *)
(*     ControlFlow_Continue (letb hoist76 := impl__PublicKey__decode hoist75 (f_deref (impl__Bytes__declassify pk)) in *)
(*     letb pk := impl__unwrap hoist76 in *)
(*     letb '(tmp0,out) := impl__PublicKey__encapsulate pk rng in *)
(*     letb rng := tmp0 in *)
(*     letb res := out in *)
(*     letb hax_temp_output := matchb res with *)
(*     | Result_Ok_case (shared_secret,ct) => *)
(*       letb '(shared_secret,ct) := ret_both (((shared_secret,ct)) : (t_Ss × t_Ct)) in *)
(*       letb ct := impl__Bytes__concat (encoding_prefix alg) (f_from (impl__Ct__encode ct)) in *)
(*       letb shared_secret := to_shared_secret alg (f_from (impl__Ss__encode shared_secret)) in *)
(*       Result_Ok (prod_b (shared_secret,ct)) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (t_Error)) in *)
(*       tlserr v_CRYPTO_ERROR *)
(*     end in *)
(*     prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result (t_Bytes × t_Bytes) int8). *)
(* Fail Next Obligation. *)

(* Equations zero_key (alg : both t_HashAlgorithm) : both t_Bytes := *)
(*   zero_key alg  := *)
(*     impl__Bytes__zeroes (impl__HashAlgorithm__hash_len alg) : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations hmac_verify (alg : both t_HashAlgorithm) (mk : both t_Bytes) (input : both t_Bytes) (tag : both t_Bytes) : both (t_Result 'unit int8) := *)
(*   hmac_verify alg mk input tag  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist136 := hmac_tag alg mk input in *)
(*     Result_Ok (letb hoist137 := eq hoist136 tag in *)
(*     ifb hoist137 *)
(*     then Result_Ok (ret_both (tt : 'unit)) *)
(*     else tlserr v_CRYPTO_ERROR)) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* #[global] Program Instance t_Algorithms_t_TryFrom : t_TryFrom t_Algorithms chString := *)
(*   let f_Error := t_Error : choice_type in *)
(*   let f_try_from := fun  (s : both chString) => matchb s with *)
(*   | SHA256_Chacha20Poly1305_RsaPssRsaSha256_X25519 => *)
(*     Result_Ok v_SHA256_Chacha20Poly1305_RsaPssRsaSha256_X25519 *)
(*   | SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519 => *)
(*     Result_Ok v_SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519 *)
(*   | SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_P256 => *)
(*     Result_Ok v_SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_P256 *)
(*   | SHA256_Chacha20Poly1305_RsaPssRsaSha256_P256 => *)
(*     Result_Ok v_SHA256_Chacha20Poly1305_RsaPssRsaSha256_P256 *)
(*   | SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_P256 => *)
(*     Result_Ok v_SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_P256 *)
(*   | SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_X25519 => *)
(*     Result_Ok v_SHA256_Aes128Gcm_EcdsaSecp256r1Sha256_X25519 *)
(*   | SHA256_Aes128Gcm_RsaPssRsaSha256_P256 => *)
(*     Result_Ok v_SHA256_Aes128Gcm_RsaPssRsaSha256_P256 *)
(*   | SHA256_Aes128Gcm_RsaPssRsaSha256_X25519 => *)
(*     Result_Ok v_SHA256_Aes128Gcm_RsaPssRsaSha256_X25519 *)
(*   | SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_P256 => *)
(*     Result_Ok v_SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_P256 *)
(*   | SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_X25519 => *)
(*     Result_Ok v_SHA384_Aes256Gcm_EcdsaSecp256r1Sha256_X25519 *)
(*   | SHA384_Aes256Gcm_RsaPssRsaSha256_P256 => *)
(*     Result_Ok v_SHA384_Aes256Gcm_RsaPssRsaSha256_P256 *)
(*   | SHA384_Aes256Gcm_RsaPssRsaSha256_X25519 => *)
(*     Result_Ok v_SHA384_Aes256Gcm_RsaPssRsaSha256_X25519 *)
(*   | SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519Kyber768Draft00 => *)
(*     Result_Ok v_SHA256_Chacha20Poly1305_EcdsaSecp256r1Sha256_X25519Kyber768Draft00 *)
(*   | _ => *)
(*     letb res := format (impl_2__new_v1 (array_from_list [ret_both (Invalid ciphersuite description:  : chString)]) (array_from_list [impl_1__new_display s])) in *)
(*     Result_Err (Error_UnknownCiphersuite (must_use res)) *)
(*   end : both (t_Result t_Algorithms t_Error) in *)
(*   {| f_Error := (@f_Error); *)
(*   f_try_from := (@f_try_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Algorithms_t_TryFrom. *)

(* Definition t_AeadKey : choice_type := *)
(*   (t_Bytes × t_AeadAlgorithm). *)
(* Equations f_bytes (s : both t_AeadKey) : both t_Bytes := *)
(*   f_bytes s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (fst x : t_Bytes)) : both t_Bytes. *)
(* Fail Next Obligation. *)
(* Equations f_alg (s : both t_AeadKey) : both t_AeadAlgorithm := *)
(*   f_alg s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (snd x : t_AeadAlgorithm)) : both t_AeadAlgorithm. *)
(* Fail Next Obligation. *)
(* Equations Build_t_AeadKey {f_bytes : both t_Bytes} {f_alg : both t_AeadAlgorithm} : both (t_AeadKey) := *)
(*   Build_t_AeadKey  := *)
(*     bind_both f_alg (fun f_alg => *)
(*       bind_both f_bytes (fun f_bytes => *)
(*         ret_both ((f_bytes,f_alg) : (t_AeadKey)))) : both (t_AeadKey). *)
(* Fail Next Obligation. *)
(* Notation "'Build_t_AeadKey' '[' x ']' '(' 'f_bytes' ':=' y ')'" := (Build_t_AeadKey (f_bytes := y) (f_alg := f_alg x)). *)
(* Notation "'Build_t_AeadKey' '[' x ']' '(' 'f_alg' ':=' y ')'" := (Build_t_AeadKey (f_bytes := f_bytes x) (f_alg := y)). *)

(* Equations impl__AeadKey__as_libcrux_key (self : both t_AeadKey) : both (t_Result t_Key int8) := *)
(*   impl__AeadKey__as_libcrux_key self  := *)
(*     matchb f_alg self with *)
(*     | AeadAlgorithm_Chacha20Poly1305_case  => *)
(*       letb hoist143 := impl__Bytes__declassify_array (f_bytes self) in *)
(*       letb hoist144 := Chacha20Key hoist143 in *)
(*       letb hoist145 := Key_Chacha20Poly1305 hoist144 in *)
(*       Result_Ok hoist145 *)
(*     | AeadAlgorithm_Aes128Gcm_case  => *)
(*       letb hoist146 := impl__Bytes__declassify_array (f_bytes self) in *)
(*       letb hoist147 := Aes128Key hoist146 in *)
(*       letb hoist148 := Key_Aes128 hoist147 in *)
(*       Result_Ok hoist148 *)
(*     | AeadAlgorithm_Aes256Gcm_case  => *)
(*       letb hoist149 := impl__Bytes__declassify_array (f_bytes self) in *)
(*       letb hoist150 := Aes256Key hoist149 in *)
(*       letb hoist151 := Key_Aes256 hoist150 in *)
(*       Result_Ok hoist151 *)
(*     end : both (t_Result t_Key int8). *)
(* Fail Next Obligation. *)

(* Equations impl__AeadKey__new (bytes : both t_Bytes) (alg : both t_AeadAlgorithm) : both t_AeadKey := *)
(*   impl__AeadKey__new bytes alg  := *)
(*     Build_t_AeadKey (f_bytes := bytes) (f_alg := alg) : both t_AeadKey. *)
(* Fail Next Obligation. *)

(* Definition t_RsaVerificationKey : choice_type := *)
(*   (t_Bytes × t_Bytes). *)
(* Equations f_modulus (s : both t_RsaVerificationKey) : both t_Bytes := *)
(*   f_modulus s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (fst x : t_Bytes)) : both t_Bytes. *)
(* Fail Next Obligation. *)
(* Equations f_exponent (s : both t_RsaVerificationKey) : both t_Bytes := *)
(*   f_exponent s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (snd x : t_Bytes)) : both t_Bytes. *)
(* Fail Next Obligation. *)
(* Equations Build_t_RsaVerificationKey {f_modulus : both t_Bytes} {f_exponent : both t_Bytes} : both (t_RsaVerificationKey) := *)
(*   Build_t_RsaVerificationKey  := *)
(*     bind_both f_exponent (fun f_exponent => *)
(*       bind_both f_modulus (fun f_modulus => *)
(*         ret_both ((f_modulus,f_exponent) : (t_RsaVerificationKey)))) : both (t_RsaVerificationKey). *)
(* Fail Next Obligation. *)
(* Notation "'Build_t_RsaVerificationKey' '[' x ']' '(' 'f_modulus' ':=' y ')'" := (Build_t_RsaVerificationKey (f_modulus := y) (f_exponent := f_exponent x)). *)
(* Notation "'Build_t_RsaVerificationKey' '[' x ']' '(' 'f_exponent' ':=' y ')'" := (Build_t_RsaVerificationKey (f_modulus := f_modulus x) (f_exponent := y)). *)

(* Definition t_PublicVerificationKey : choice_type := *)
(*   (t_Bytes ∐ t_RsaVerificationKey). *)
(* Notation "'PublicVerificationKey_EcDsa_case' x" := (inl x) (at level 100). *)
(* Equations PublicVerificationKey_EcDsa (x : both t_Bytes) : both t_PublicVerificationKey := *)
(*   PublicVerificationKey_EcDsa x  := *)
(*     bind_both x (fun x => *)
(*       ret_both (inl x : t_PublicVerificationKey)) : both t_PublicVerificationKey. *)
(* Fail Next Obligation. *)
(* Notation "'PublicVerificationKey_Rsa_case' x" := (inr x) (at level 100). *)
(* Equations PublicVerificationKey_Rsa (x : both t_RsaVerificationKey) : both t_PublicVerificationKey := *)
(*   PublicVerificationKey_Rsa x  := *)
(*     bind_both x (fun x => *)
(*       ret_both (inr x : t_PublicVerificationKey)) : both t_PublicVerificationKey. *)
(* Fail Next Obligation. *)

(* Equations aead_decrypt (k : both t_AeadKey) (iv : both t_Bytes) (cip : both t_Bytes) (aad : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   aead_decrypt k iv cip aad  := *)
(*     run (letb tag := impl__Bytes__slice cip ((impl__Bytes__len cip) .- (ret_both (16 : uint_size))) (ret_both (16 : uint_size)) in *)
(*     letb cip := impl__Bytes__slice cip (ret_both (0 : uint_size)) ((impl__Bytes__len cip) .- (ret_both (16 : uint_size))) in *)
(*     letb (tag : nseq int8 16) := impl__Bytes__declassify_array tag in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist154 := impl__AeadKey__as_libcrux_key k in *)
(*     Result_Ok (letb hoist152 := impl__Bytes__declassify_array iv in *)
(*     letb hoist153 := Iv hoist152 in *)
(*     letb plain := decrypt_detached hoist154 (impl__Bytes__declassify cip) hoist153 (impl__Bytes__declassify aad) (f_from tag) in *)
(*     matchb plain with *)
(*     | Result_Ok_case plain => *)
(*       letb plain := ret_both ((plain) : (t_Vec int8 t_Global)) in *)
(*       Result_Ok (f_into plain) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (t_DecryptError)) in *)
(*       tlserr v_CRYPTO_ERROR *)
(*     end)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations aead_encrypt (k : both t_AeadKey) (iv : both t_Bytes) (plain : both t_Bytes) (aad : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   aead_encrypt k iv plain aad  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist157 := impl__AeadKey__as_libcrux_key k in *)
(*     Result_Ok (letb hoist155 := impl__Bytes__declassify_array iv in *)
(*     letb hoist156 := Iv hoist155 in *)
(*     letb res := encrypt_detached hoist157 (impl__Bytes__declassify plain) hoist156 (impl__Bytes__declassify aad) in *)
(*     matchb res with *)
(*     | Result_Ok_case (tag,cip) => *)
(*       letb '(tag,cip) := ret_both (((tag,cip)) : (t_Tag × t_Vec int8 t_Global)) in *)
(*       letb (cipby : t_Bytes) := f_into cip in *)
(*       letb (tagby : t_Bytes) := f_into (f_as_ref tag) in *)
(*       Result_Ok (impl__Bytes__concat cipby tagby) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (t_EncryptError)) in *)
(*       tlserr v_CRYPTO_ERROR *)
(*     end)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* (*item error backend*) *)

(* Definition t_AeadKeyIV : choice_type := *)
(*   (t_AeadKey × t_Bytes). *)
(* Equations f_key (s : both t_AeadKeyIV) : both t_AeadKey := *)
(*   f_key s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (fst x : t_AeadKey)) : both t_AeadKey. *)
(* Fail Next Obligation. *)
(* Equations f_iv (s : both t_AeadKeyIV) : both t_Bytes := *)
(*   f_iv s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (snd x : t_Bytes)) : both t_Bytes. *)
(* Fail Next Obligation. *)
(* Equations Build_t_AeadKeyIV {f_key : both t_AeadKey} {f_iv : both t_Bytes} : both (t_AeadKeyIV) := *)
(*   Build_t_AeadKeyIV  := *)
(*     bind_both f_iv (fun f_iv => *)
(*       bind_both f_key (fun f_key => *)
(*         ret_both ((f_key,f_iv) : (t_AeadKeyIV)))) : both (t_AeadKeyIV). *)
(* Fail Next Obligation. *)
(* Notation "'Build_t_AeadKeyIV' '[' x ']' '(' 'f_key' ':=' y ')'" := (Build_t_AeadKeyIV (f_key := y) (f_iv := f_iv x)). *)
(* Notation "'Build_t_AeadKeyIV' '[' x ']' '(' 'f_iv' ':=' y ')'" := (Build_t_AeadKeyIV (f_key := f_key x) (f_iv := y)). *)

(* Equations impl__AeadKeyIV__new (key : both t_AeadKey) (iv : both t_Bytes) : both t_AeadKeyIV := *)
(*   impl__AeadKeyIV__new key iv  := *)
(*     Build_t_AeadKeyIV (f_key := key) (f_iv := iv) : both t_AeadKeyIV. *)
(* Fail Next Obligation. *)
