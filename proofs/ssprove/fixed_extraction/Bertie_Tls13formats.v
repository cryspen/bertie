(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(* Require Import Declassify. *)
(* Export Declassify. *)

(* Require Import zero_key. *)
(* Export zero_key. *)

(* Require Import Algorithms. *)
(* Export Algorithms. *)

(* Require Import Digest. *)
(* Export Digest. *)

(* Require Import HashAlgorithm. *)
(* Export HashAlgorithm. *)

(* Require Import Hmac. *)
(* Export Hmac. *)

(* Require Import KemPk. *)
(* Export KemPk. *)

(* Require Import Random. *)
(* Export Random. *)

(* Require Import SignatureScheme. *)
(* Export SignatureScheme. *)

(* Require Import bytes1. *)
(* Export bytes1. *)

(* Require Import bytes2. *)
(* Export bytes2. *)

(* Require Import bytes_concat. *)
(* Export bytes_concat. *)

(* Require Import check. *)
(* Export check. *)

(* Require Import check_eq. *)
(* Export check_eq. *)

(* Require Import check_eq_slice. *)
(* Export check_eq_slice. *)

(* Require Import check_eq_with_slice. *)
(* Export check_eq_with_slice. *)

(* Require Import check_length_encoding_u16. *)
(* Export check_length_encoding_u16. *)

(* Require Import check_length_encoding_u16_slice. *)
(* Export check_length_encoding_u16_slice. *)

(* Require Import check_length_encoding_u24. *)
(* Export check_length_encoding_u24. *)

(* Require Import check_length_encoding_u8. *)
(* Export check_length_encoding_u8. *)

(* Require Import check_length_encoding_u8_slice. *)
(* Export check_length_encoding_u8_slice. *)

(* Require Import check_mem. *)
(* Export check_mem. *)

(* Require Import encode_length_u16. *)
(* Export encode_length_u16. *)

(* Require Import encode_length_u24. *)
(* Export encode_length_u24. *)

(* Require Import encode_length_u8. *)
(* Export encode_length_u8. *)

(* Require Import eq_slice. *)
(* Export eq_slice. *)

(* Require Import length_u16_encoded. *)
(* Export length_u16_encoded. *)

(* Require Import length_u16_encoded_slice. *)
(* Export length_u16_encoded_slice. *)

(* Require Import length_u24_encoded. *)
(* Export length_u24_encoded. *)

(* Require Import length_u8_encoded. *)
(* Export length_u8_encoded. *)

(* Require Import parse_failed. *)
(* Export parse_failed. *)

(* Require Import tlserr. *)
(* Export tlserr. *)

(* Require Import u32_as_be_bytes. *)
(* Export u32_as_be_bytes. *)

(* Require Import Bytes. *)
(* Export Bytes. *)

(* Require Import TLSError. *)
(* Export TLSError. *)

(* Require Import APPLICATION_DATA_INSTEAD_OF_HANDSHAKE. *)
(* Export APPLICATION_DATA_INSTEAD_OF_HANDSHAKE. *)

(* Require Import DECODE_ERROR. *)
(* Export DECODE_ERROR. *)

(* Require Import INVALID_COMPRESSION_LIST. *)
(* Export INVALID_COMPRESSION_LIST. *)

(* Require Import INVALID_SIGNATURE. *)
(* Export INVALID_SIGNATURE. *)

(* Require Import MISSING_KEY_SHARE. *)
(* Export MISSING_KEY_SHARE. *)

(* Require Import PROTOCOL_VERSION_ALERT. *)
(* Export PROTOCOL_VERSION_ALERT. *)

(* Require Import PSK_MODE_MISMATCH. *)
(* Export PSK_MODE_MISMATCH. *)

(* Require Import U32. *)
(* Export U32. *)

(* Require Import U8. *)
(* Export U8. *)

(* Require Import UNSUPPORTED_ALGORITHM. *)
(* Export UNSUPPORTED_ALGORITHM. *)

(* Require Import HandshakeData. *)
(* Export HandshakeData. *)

(* Require Import HandshakeType. *)
(* Export HandshakeType. *)

From BertieExtraction Require Import Bertie_Tls13utils.
From BertieExtraction Require Import Fixes.

Equations discriminant_AlertDescription_AccessDenied : both int8 :=
  discriminant_AlertDescription_AccessDenied  :=
    ret_both (49 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_BadCertificate : both int8 :=
  discriminant_AlertDescription_BadCertificate  :=
    ret_both (42 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_BadCertificateStatusResponse : both int8 :=
  discriminant_AlertDescription_BadCertificateStatusResponse  :=
    ret_both (113 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_BadRecordMac : both int8 :=
  discriminant_AlertDescription_BadRecordMac  :=
    ret_both (20 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_CertificateExpired : both int8 :=
  discriminant_AlertDescription_CertificateExpired  :=
    ret_both (45 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_CertificateRequired : both int8 :=
  discriminant_AlertDescription_CertificateRequired  :=
    ret_both (116 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_CertificateRevoked : both int8 :=
  discriminant_AlertDescription_CertificateRevoked  :=
    ret_both (44 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_CertificateUnknown : both int8 :=
  discriminant_AlertDescription_CertificateUnknown  :=
    ret_both (46 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_CloseNotify : both int8 :=
  discriminant_AlertDescription_CloseNotify  :=
    ret_both (0 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_DecodeError : both int8 :=
  discriminant_AlertDescription_DecodeError  :=
    ret_both (50 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_DecryptError : both int8 :=
  discriminant_AlertDescription_DecryptError  :=
    ret_both (51 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_HandshakeFailure : both int8 :=
  discriminant_AlertDescription_HandshakeFailure  :=
    ret_both (40 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_IllegalParameter : both int8 :=
  discriminant_AlertDescription_IllegalParameter  :=
    ret_both (47 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_InappropriateFallback : both int8 :=
  discriminant_AlertDescription_InappropriateFallback  :=
    ret_both (86 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_InsufficientSecurity : both int8 :=
  discriminant_AlertDescription_InsufficientSecurity  :=
    ret_both (71 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_InternalError : both int8 :=
  discriminant_AlertDescription_InternalError  :=
    ret_both (80 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_MissingExtension : both int8 :=
  discriminant_AlertDescription_MissingExtension  :=
    ret_both (109 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_NoApplicationProtocol : both int8 :=
  discriminant_AlertDescription_NoApplicationProtocol  :=
    ret_both (120 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_ProtocolVersion : both int8 :=
  discriminant_AlertDescription_ProtocolVersion  :=
    ret_both (70 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_RecordOverflow : both int8 :=
  discriminant_AlertDescription_RecordOverflow  :=
    ret_both (22 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_UnexpectedMessage : both int8 :=
  discriminant_AlertDescription_UnexpectedMessage  :=
    ret_both (10 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_UnknownCa : both int8 :=
  discriminant_AlertDescription_UnknownCa  :=
    ret_both (48 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_UnknownPskIdentity : both int8 :=
  discriminant_AlertDescription_UnknownPskIdentity  :=
    ret_both (115 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_UnrecognizedName : both int8 :=
  discriminant_AlertDescription_UnrecognizedName  :=
    ret_both (112 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_UnsupportedCertificate : both int8 :=
  discriminant_AlertDescription_UnsupportedCertificate  :=
    ret_both (43 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_AlertDescription_UnsupportedExtension : both int8 :=
  discriminant_AlertDescription_UnsupportedExtension  :=
    ret_both (110 : int8) : both int8.
Fail Next Obligation.

Definition t_AlertDescription : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'AlertDescription_CloseNotify_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl tt)))))))))))))))))))))))))) (at level 100).
Equations AlertDescription_CloseNotify : both t_AlertDescription :=
  AlertDescription_CloseNotify  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (tt : 'unit)))))))))))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_UnexpectedMessage_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))))))))))))) (at level 100).
Equations AlertDescription_UnexpectedMessage : both t_AlertDescription :=
  AlertDescription_UnexpectedMessage  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_BadRecordMac_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))))))))))))) (at level 100).
Equations AlertDescription_BadRecordMac : both t_AlertDescription :=
  AlertDescription_BadRecordMac  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_RecordOverflow_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))))))))))) (at level 100).
Equations AlertDescription_RecordOverflow : both t_AlertDescription :=
  AlertDescription_RecordOverflow  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_HandshakeFailure_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))))))))))) (at level 100).
Equations AlertDescription_HandshakeFailure : both t_AlertDescription :=
  AlertDescription_HandshakeFailure  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_BadCertificate_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))))))))) (at level 100).
Equations AlertDescription_BadCertificate : both t_AlertDescription :=
  AlertDescription_BadCertificate  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_UnsupportedCertificate_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))))))))) (at level 100).
Equations AlertDescription_UnsupportedCertificate : both t_AlertDescription :=
  AlertDescription_UnsupportedCertificate  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_CertificateRevoked_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))))))) (at level 100).
Equations AlertDescription_CertificateRevoked : both t_AlertDescription :=
  AlertDescription_CertificateRevoked  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_CertificateExpired_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))))))) (at level 100).
Equations AlertDescription_CertificateExpired : both t_AlertDescription :=
  AlertDescription_CertificateExpired  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_CertificateUnknown_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))))) (at level 100).
Equations AlertDescription_CertificateUnknown : both t_AlertDescription :=
  AlertDescription_CertificateUnknown  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_IllegalParameter_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))))) (at level 100).
Equations AlertDescription_IllegalParameter : both t_AlertDescription :=
  AlertDescription_IllegalParameter  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_UnknownCa_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))) (at level 100).
Equations AlertDescription_UnknownCa : both t_AlertDescription :=
  AlertDescription_UnknownCa  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_AccessDenied_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))) (at level 100).
Equations AlertDescription_AccessDenied : both t_AlertDescription :=
  AlertDescription_AccessDenied  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_DecodeError_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))) (at level 100).
Equations AlertDescription_DecodeError : both t_AlertDescription :=
  AlertDescription_DecodeError  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_DecryptError_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))) (at level 100).
Equations AlertDescription_DecryptError : both t_AlertDescription :=
  AlertDescription_DecryptError  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_ProtocolVersion_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))) (at level 100).
Equations AlertDescription_ProtocolVersion : both t_AlertDescription :=
  AlertDescription_ProtocolVersion  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_InsufficientSecurity_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))) (at level 100).
Equations AlertDescription_InsufficientSecurity : both t_AlertDescription :=
  AlertDescription_InsufficientSecurity  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_InternalError_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))) (at level 100).
Equations AlertDescription_InternalError : both t_AlertDescription :=
  AlertDescription_InternalError  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_InappropriateFallback_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))) (at level 100).
Equations AlertDescription_InappropriateFallback : both t_AlertDescription :=
  AlertDescription_InappropriateFallback  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_UserCanceled_case'" := (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))) (at level 100).
Equations AlertDescription_UserCanceled : both t_AlertDescription :=
  AlertDescription_UserCanceled  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_MissingExtension_case'" := (inl (inl (inl (inl (inl (inl (inr tt))))))) (at level 100).
Equations AlertDescription_MissingExtension : both t_AlertDescription :=
  AlertDescription_MissingExtension  :=
    ret_both (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_UnsupportedExtension_case'" := (inl (inl (inl (inl (inl (inr tt)))))) (at level 100).
Equations AlertDescription_UnsupportedExtension : both t_AlertDescription :=
  AlertDescription_UnsupportedExtension  :=
    ret_both (inl (inl (inl (inl (inl (inr (tt : 'unit)))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_UnrecognizedName_case'" := (inl (inl (inl (inl (inr tt))))) (at level 100).
Equations AlertDescription_UnrecognizedName : both t_AlertDescription :=
  AlertDescription_UnrecognizedName  :=
    ret_both (inl (inl (inl (inl (inr (tt : 'unit))))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_BadCertificateStatusResponse_case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations AlertDescription_BadCertificateStatusResponse : both t_AlertDescription :=
  AlertDescription_BadCertificateStatusResponse  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_UnknownPskIdentity_case'" := (inl (inl (inr tt))) (at level 100).
Equations AlertDescription_UnknownPskIdentity : both t_AlertDescription :=
  AlertDescription_UnknownPskIdentity  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_CertificateRequired_case'" := (inl (inr tt)) (at level 100).
Equations AlertDescription_CertificateRequired : both t_AlertDescription :=
  AlertDescription_CertificateRequired  :=
    ret_both (inl (inr (tt : 'unit)) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.
Notation "'AlertDescription_NoApplicationProtocol_case'" := (inr tt) (at level 100).
Equations AlertDescription_NoApplicationProtocol : both t_AlertDescription :=
  AlertDescription_NoApplicationProtocol  :=
    ret_both (inr (tt : 'unit) : t_AlertDescription) : both t_AlertDescription.
Fail Next Obligation.

Equations discriminant_AlertDescription_UserCanceled : both int8 :=
  discriminant_AlertDescription_UserCanceled  :=
    ret_both (90 : int8) : both int8.
Fail Next Obligation.

Equations t_AlertDescription_cast_to_repr (x : both t_AlertDescription) : both int8 :=
  t_AlertDescription_cast_to_repr x  :=
    matchb x with
    | AlertDescription_CloseNotify_case  =>
      discriminant_AlertDescription_CloseNotify
    | AlertDescription_UnexpectedMessage_case  =>
      discriminant_AlertDescription_UnexpectedMessage
    | AlertDescription_BadRecordMac_case  =>
      discriminant_AlertDescription_BadRecordMac
    | AlertDescription_RecordOverflow_case  =>
      discriminant_AlertDescription_RecordOverflow
    | AlertDescription_HandshakeFailure_case  =>
      discriminant_AlertDescription_HandshakeFailure
    | AlertDescription_BadCertificate_case  =>
      discriminant_AlertDescription_BadCertificate
    | AlertDescription_UnsupportedCertificate_case  =>
      discriminant_AlertDescription_UnsupportedCertificate
    | AlertDescription_CertificateRevoked_case  =>
      discriminant_AlertDescription_CertificateRevoked
    | AlertDescription_CertificateExpired_case  =>
      discriminant_AlertDescription_CertificateExpired
    | AlertDescription_CertificateUnknown_case  =>
      discriminant_AlertDescription_CertificateUnknown
    | AlertDescription_IllegalParameter_case  =>
      discriminant_AlertDescription_IllegalParameter
    | AlertDescription_UnknownCa_case  =>
      discriminant_AlertDescription_UnknownCa
    | AlertDescription_AccessDenied_case  =>
      discriminant_AlertDescription_AccessDenied
    | AlertDescription_DecodeError_case  =>
      discriminant_AlertDescription_DecodeError
    | AlertDescription_DecryptError_case  =>
      discriminant_AlertDescription_DecryptError
    | AlertDescription_ProtocolVersion_case  =>
      discriminant_AlertDescription_ProtocolVersion
    | AlertDescription_InsufficientSecurity_case  =>
      discriminant_AlertDescription_InsufficientSecurity
    | AlertDescription_InternalError_case  =>
      discriminant_AlertDescription_InternalError
    | AlertDescription_InappropriateFallback_case  =>
      discriminant_AlertDescription_InappropriateFallback
    | AlertDescription_UserCanceled_case  =>
      discriminant_AlertDescription_UserCanceled
    | AlertDescription_MissingExtension_case  =>
      discriminant_AlertDescription_MissingExtension
    | AlertDescription_UnsupportedExtension_case  =>
      discriminant_AlertDescription_UnsupportedExtension
    | AlertDescription_UnrecognizedName_case  =>
      discriminant_AlertDescription_UnrecognizedName
    | AlertDescription_BadCertificateStatusResponse_case  =>
      discriminant_AlertDescription_BadCertificateStatusResponse
    | AlertDescription_UnknownPskIdentity_case  =>
      discriminant_AlertDescription_UnknownPskIdentity
    | AlertDescription_CertificateRequired_case  =>
      discriminant_AlertDescription_CertificateRequired
    | AlertDescription_NoApplicationProtocol_case  =>
      discriminant_AlertDescription_NoApplicationProtocol
    end : both int8.
Fail Next Obligation.

Equations discriminant_AlertLevel_Fatal : both int8 :=
  discriminant_AlertLevel_Fatal  :=
    ret_both (2 : int8) : both int8.
Fail Next Obligation.

Definition t_AlertLevel : choice_type :=
  ('unit ∐ 'unit).
Notation "'AlertLevel_Warning_case'" := (inl tt) (at level 100).
Equations AlertLevel_Warning : both t_AlertLevel :=
  AlertLevel_Warning  :=
    ret_both (inl (tt : 'unit) : t_AlertLevel) : both t_AlertLevel.
Fail Next Obligation.
Notation "'AlertLevel_Fatal_case'" := (inr tt) (at level 100).
Equations AlertLevel_Fatal : both t_AlertLevel :=
  AlertLevel_Fatal  :=
    ret_both (inr (tt : 'unit) : t_AlertLevel) : both t_AlertLevel.
Fail Next Obligation.

Equations discriminant_AlertLevel_Warning : both int8 :=
  discriminant_AlertLevel_Warning  :=
    ret_both (1 : int8) : both int8.
Fail Next Obligation.

Equations t_AlertLevel_cast_to_repr (x : both t_AlertLevel) : both int8 :=
  t_AlertLevel_cast_to_repr x  :=
    matchb x with
    | AlertLevel_Warning_case  =>
      discriminant_AlertLevel_Warning
    | AlertLevel_Fatal_case  =>
      discriminant_AlertLevel_Fatal
    end : both int8.
Fail Next Obligation.

Equations discriminant_ContentType_Alert : both int8 :=
  discriminant_ContentType_Alert  :=
    ret_both (21 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_ContentType_ApplicationData : both int8 :=
  discriminant_ContentType_ApplicationData  :=
    ret_both (23 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_ContentType_ChangeCipherSpec : both int8 :=
  discriminant_ContentType_ChangeCipherSpec  :=
    ret_both (20 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_ContentType_Handshake : both int8 :=
  discriminant_ContentType_Handshake  :=
    ret_both (22 : int8) : both int8.
Fail Next Obligation.

Definition t_ContentType : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'ContentType_Invalid_case'" := (inl (inl (inl (inl tt)))) (at level 100).
Equations ContentType_Invalid : both t_ContentType :=
  ContentType_Invalid  :=
    ret_both (inl (inl (inl (inl (tt : 'unit)))) : t_ContentType) : both t_ContentType.
Fail Next Obligation.
Notation "'ContentType_ChangeCipherSpec_case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations ContentType_ChangeCipherSpec : both t_ContentType :=
  ContentType_ChangeCipherSpec  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_ContentType) : both t_ContentType.
Fail Next Obligation.
Notation "'ContentType_Alert_case'" := (inl (inl (inr tt))) (at level 100).
Equations ContentType_Alert : both t_ContentType :=
  ContentType_Alert  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_ContentType) : both t_ContentType.
Fail Next Obligation.
Notation "'ContentType_Handshake_case'" := (inl (inr tt)) (at level 100).
Equations ContentType_Handshake : both t_ContentType :=
  ContentType_Handshake  :=
    ret_both (inl (inr (tt : 'unit)) : t_ContentType) : both t_ContentType.
Fail Next Obligation.
Notation "'ContentType_ApplicationData_case'" := (inr tt) (at level 100).
Equations ContentType_ApplicationData : both t_ContentType :=
  ContentType_ApplicationData  :=
    ret_both (inr (tt : 'unit) : t_ContentType) : both t_ContentType.
Fail Next Obligation.

Equations discriminant_ContentType_Invalid : both int8 :=
  discriminant_ContentType_Invalid  :=
    ret_both (0 : int8) : both int8.
Fail Next Obligation.

Equations t_ContentType_cast_to_repr (x : both t_ContentType) : both int8 :=
  t_ContentType_cast_to_repr x  :=
    matchb x with
    | ContentType_Invalid_case  =>
      discriminant_ContentType_Invalid
    | ContentType_ChangeCipherSpec_case  =>
      discriminant_ContentType_ChangeCipherSpec
    | ContentType_Alert_case  =>
      discriminant_ContentType_Alert
    | ContentType_Handshake_case  =>
      discriminant_ContentType_Handshake
    | ContentType_ApplicationData_case  =>
      discriminant_ContentType_ApplicationData
    end : both int8.
Fail Next Obligation.

(*Not implemented yet? todo(item)*)

Equations v_LABEL_C_AP_TRAFFIC : both (nseq int8 12) :=
  v_LABEL_C_AP_TRAFFIC  :=
    array_from_list [ret_both (99 : int8);
      ret_both (32 : int8);
      ret_both (97 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)] : both (nseq int8 12).
Fail Next Obligation.

Equations v_LABEL_C_E_TRAFFIC : both (nseq int8 11) :=
  v_LABEL_C_E_TRAFFIC  :=
    array_from_list [ret_both (99 : int8);
      ret_both (32 : int8);
      ret_both (101 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)] : both (nseq int8 11).
Fail Next Obligation.

Equations v_LABEL_C_HS_TRAFFIC : both (nseq int8 12) :=
  v_LABEL_C_HS_TRAFFIC  :=
    array_from_list [ret_both (99 : int8);
      ret_both (32 : int8);
      ret_both (104 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)] : both (nseq int8 12).
Fail Next Obligation.

Equations v_LABEL_DERIVED : both (nseq int8 7) :=
  v_LABEL_DERIVED  :=
    array_from_list [ret_both (100 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (105 : int8);
      ret_both (118 : int8);
      ret_both (101 : int8);
      ret_both (100 : int8)] : both (nseq int8 7).
Fail Next Obligation.

Equations v_LABEL_EXP_MASTER : both (nseq int8 10) :=
  v_LABEL_EXP_MASTER  :=
    array_from_list [ret_both (101 : int8);
      ret_both (120 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (109 : int8);
      ret_both (97 : int8);
      ret_both (115 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)] : both (nseq int8 10).
Fail Next Obligation.

Equations v_LABEL_E_EXP_MASTER : both (nseq int8 12) :=
  v_LABEL_E_EXP_MASTER  :=
    array_from_list [ret_both (101 : int8);
      ret_both (32 : int8);
      ret_both (101 : int8);
      ret_both (120 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (109 : int8);
      ret_both (97 : int8);
      ret_both (115 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)] : both (nseq int8 12).
Fail Next Obligation.

Equations v_LABEL_FINISHED : both (nseq int8 8) :=
  v_LABEL_FINISHED  :=
    array_from_list [ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (110 : int8);
      ret_both (105 : int8);
      ret_both (115 : int8);
      ret_both (104 : int8);
      ret_both (101 : int8);
      ret_both (100 : int8)] : both (nseq int8 8).
Fail Next Obligation.

Equations v_LABEL_IV : both (nseq int8 2) :=
  v_LABEL_IV  :=
    array_from_list [ret_both (105 : int8);
      ret_both (118 : int8)] : both (nseq int8 2).
Fail Next Obligation.

Equations v_LABEL_KEY : both (nseq int8 3) :=
  v_LABEL_KEY  :=
    array_from_list [ret_both (107 : int8);
      ret_both (101 : int8);
      ret_both (121 : int8)] : both (nseq int8 3).
Fail Next Obligation.

Equations v_LABEL_RES_BINDER : both (nseq int8 10) :=
  v_LABEL_RES_BINDER  :=
    array_from_list [ret_both (114 : int8);
      ret_both (101 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (98 : int8);
      ret_both (105 : int8);
      ret_both (110 : int8);
      ret_both (100 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)] : both (nseq int8 10).
Fail Next Obligation.

Equations v_LABEL_RES_MASTER : both (nseq int8 10) :=
  v_LABEL_RES_MASTER  :=
    array_from_list [ret_both (114 : int8);
      ret_both (101 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (109 : int8);
      ret_both (97 : int8);
      ret_both (115 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)] : both (nseq int8 10).
Fail Next Obligation.

Equations v_LABEL_S_AP_TRAFFIC : both (nseq int8 12) :=
  v_LABEL_S_AP_TRAFFIC  :=
    array_from_list [ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (97 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)] : both (nseq int8 12).
Fail Next Obligation.

Equations v_LABEL_S_HS_TRAFFIC : both (nseq int8 12) :=
  v_LABEL_S_HS_TRAFFIC  :=
    array_from_list [ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (104 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)] : both (nseq int8 12).
Fail Next Obligation.

Equations v_LABEL_TLS13 : both (nseq int8 6) :=
  v_LABEL_TLS13  :=
    array_from_list [ret_both (116 : int8);
      ret_both (108 : int8);
      ret_both (115 : int8);
      ret_both (49 : int8);
      ret_both (51 : int8);
      ret_both (32 : int8)] : both (nseq int8 6).
Fail Next Obligation.

Equations v_PREFIX_SERVER_SIGNATURE : both (nseq int8 98) :=
  v_PREFIX_SERVER_SIGNATURE  :=
    array_from_list [ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (32 : int8);
      ret_both (84 : int8);
      ret_both (76 : int8);
      ret_both (83 : int8);
      ret_both (32 : int8);
      ret_both (49 : int8);
      ret_both (46 : int8);
      ret_both (51 : int8);
      ret_both (44 : int8);
      ret_both (32 : int8);
      ret_both (115 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (118 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (32 : int8);
      ret_both (67 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (116 : int8);
      ret_both (105 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8);
      ret_both (97 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (86 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (105 : int8);
      ret_both (102 : int8);
      ret_both (121 : int8);
      ret_both (0 : int8)] : both (nseq int8 98).
Fail Next Obligation.

Equations build_server_name__PREFIX1 : both (nseq int8 2) :=
  build_server_name__PREFIX1  :=
    array_from_list [v_U8 (ret_both (0 : int8));
      v_U8 (ret_both (0 : int8))] : both (nseq int8 2).
Fail Next Obligation.

Equations build_server_name__PREFIX2 : both (nseq int8 1) :=
  build_server_name__PREFIX2  :=
    array_from_list [v_U8 (ret_both (0 : int8))] : both (nseq int8 1).
Fail Next Obligation.

Equations key_shares__PREFIX : both (nseq int8 2) :=
  key_shares__PREFIX  :=
    array_from_list [v_U8 (ret_both (0 : int8));
      v_U8 (ret_both (51 : int8))] : both (nseq int8 2).
Fail Next Obligation.

Equations psk_key_exchange_modes__PSK_MODE_PREFIX : both (nseq int8 2) :=
  psk_key_exchange_modes__PSK_MODE_PREFIX  :=
    array_from_list [v_U8 (ret_both (0 : int8));
      v_U8 (ret_both (45 : int8))] : both (nseq int8 2).
Fail Next Obligation.

Equations server_supported_version__SUPPORTED_VERSION_PREFIX : both (nseq int8 2) :=
  server_supported_version__SUPPORTED_VERSION_PREFIX  :=
    array_from_list [v_U8 (ret_both (0 : int8));
      v_U8 (ret_both (43 : int8))] : both (nseq int8 2).
Fail Next Obligation.

Equations supported_groups__SUPPORTED_GROUPS_PREFIX : both (nseq int8 2) :=
  supported_groups__SUPPORTED_GROUPS_PREFIX  :=
    array_from_list [v_U8 (ret_both (0 : int8));
      v_U8 (ret_both (10 : int8))] : both (nseq int8 2).
Fail Next Obligation.

Equations application_data_instead_of_handshake (_ : both 'unit) : both (t_Result 'unit int8) :=
  application_data_instead_of_handshake _  :=
    Result_Err v_APPLICATION_DATA_INSTEAD_OF_HANDSHAKE : both (t_Result 'unit int8).
Fail Next Obligation.

Equations invalid_compression_list (_ : both 'unit) : both (t_Result 'unit int8) :=
  invalid_compression_list _  :=
    Result_Err v_INVALID_COMPRESSION_LIST : both (t_Result 'unit int8).
Fail Next Obligation.

Equations invalid_compression_method_alert (_ : both 'unit) : both (t_Result 'unit int8) :=
  invalid_compression_method_alert _  :=
    Result_Err v_DECODE_ERROR : both (t_Result 'unit int8).
Fail Next Obligation.

Equations protocol_version_alert (_ : both 'unit) : both (t_Result 'unit int8) :=
  protocol_version_alert _  :=
    Result_Err v_PROTOCOL_VERSION_ALERT : both (t_Result 'unit int8).
Fail Next Obligation.

Equations unsupported_cipher_alert (_ : both 'unit) : both (t_Result 'unit int8) :=
  unsupported_cipher_alert _  :=
    Result_Err v_UNSUPPORTED_ALGORITHM : both (t_Result 'unit int8).
Fail Next Obligation.

Equations impl__ContentType__try_from_u8 (t : both int8) : both (t_Result t_ContentType int8) :=
  impl__ContentType__try_from_u8 t  :=
    matchb (bind_both t (fun x => ret_both (Z.to_nat (urepr x) : 'nat))) with
    | 20%nat =>
      Result_Ok ContentType_ChangeCipherSpec
    | 21%nat =>
      Result_Ok ContentType_Alert
    | 22%nat =>
      Result_Ok ContentType_Handshake
    | 23%nat =>
      Result_Ok ContentType_ApplicationData
    | _ =>
      Result_Err (parse_failed (ret_both tt))
    end : both (t_Result t_ContentType int8).
Fail Next Obligation.

Equations check_r_len (rlen : both uint_size) : both (t_Result 'unit int8) :=
  check_r_len rlen  :=
    ifb orb (rlen <.? (ret_both (32 : uint_size))) (rlen >.? (ret_both (33 : uint_size)))
    then Result_Err v_INVALID_SIGNATURE
    else Result_Ok (ret_both (tt : 'unit)) : both (t_Result 'unit int8).
Fail Next Obligation.

(* Equations check_psk_key_exchange_modes (client_hello : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_psk_key_exchange_modes client_hello  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u8_slice client_hello in *)
(*     Result_Ok (check_eq_with_slice (unsize (array_from_list [v_U8 (ret_both (1 : int8))])) client_hello (ret_both (1 : uint_size)) (ret_both (2 : uint_size)))) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_supported_versions (client_hello : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_supported_versions client_hello  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u8_slice client_hello in *)
(*     Result_Ok (check_mem (unsize (array_from_list [v_U8 (ret_both (3 : int8)); *)
(*       v_U8 (ret_both (4 : int8))])) (client_hello.a[(Build_t_Range (f_start := ret_both (1 : uint_size)) (f_end := impl__len client_hello))]))) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations merge_opts {v_T : _} `{ t_Sized v_T} (o1 : both (t_Option v_T)) (o2 : both (t_Option v_T)) : both (t_Result (t_Option v_T) int8) := *)
(*   merge_opts o1 o2  := *)
(*     matchb prod_b (o1,o2) with *)
(*     | '(Option_None ,Option_Some o) => *)
(*       Result_Ok (Option_Some o) *)
(*     | '(Option_Some o,Option_None ) => *)
(*       Result_Ok (Option_Some o) *)
(*     | '(Option_None ,Option_None ) => *)
(*       Result_Ok Option_None *)
(*     | _ => *)
(*       tlserr parse_failed *)
(*     end : both (t_Result (t_Option v_T) int8). *)
(* Fail Next Obligation. *)

(* #[global] Program Instance t_AlertLevel_t_TryFrom : t_TryFrom t_AlertLevel int8 := *)
(*   let f_Error := int8 : choice_type in *)
(*   let f_try_from := fun  (value : both int8) => matchb value with *)
(*   | 1 => *)
(*     Result_Ok AlertLevel_Warning *)
(*   | 2 => *)
(*     Result_Ok AlertLevel_Fatal *)
(*   | _ => *)
(*     tlserr parse_failed *)
(*   end : both (t_Result t_AlertLevel int8) in *)
(*   {| f_Error := (@f_Error); *)
(*   f_try_from := (@f_try_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_AlertLevel_t_TryFrom. *)

#[global] (* Program *) Instance t_AlertDescription_t_TryFrom : t_TryFrom t_AlertDescription int8 :=
  let f_Error := int8 : choice_type in
  let f_try_from := fun  (value : both int8) => matchb (bind_both value (fun x => ret_both (Z.to_nat (urepr x) : 'nat))) with
  | 0%nat =>
    Result_Ok AlertDescription_CloseNotify
  | 10%nat =>
    Result_Ok AlertDescription_UnexpectedMessage
  | 20%nat =>
    Result_Ok AlertDescription_BadRecordMac
  | 22%nat =>
    Result_Ok AlertDescription_RecordOverflow
  | 40%nat =>
    Result_Ok AlertDescription_HandshakeFailure
  | 42%nat =>
    Result_Ok AlertDescription_BadCertificate
  | 43%nat =>
    Result_Ok AlertDescription_UnsupportedCertificate
  | 44%nat =>
    Result_Ok AlertDescription_CertificateRevoked
  | 45%nat =>
    Result_Ok AlertDescription_CertificateExpired
  | 46%nat =>
    Result_Ok AlertDescription_CertificateUnknown
  | 47%nat =>
    Result_Ok AlertDescription_IllegalParameter
  | 48%nat =>
    Result_Ok AlertDescription_UnknownCa
  | 49%nat =>
    Result_Ok AlertDescription_AccessDenied
  | 50%nat =>
    Result_Ok AlertDescription_DecodeError
  | 51%nat =>
    Result_Ok AlertDescription_DecryptError
  | 70%nat =>
    Result_Ok AlertDescription_ProtocolVersion
  | 71%nat =>
    Result_Ok AlertDescription_InsufficientSecurity
  | 80%nat =>
    Result_Ok AlertDescription_InternalError
  | 86%nat =>
    Result_Ok AlertDescription_InappropriateFallback
  | 90%nat =>
    Result_Ok AlertDescription_UserCanceled
  | 109%nat =>
    Result_Ok AlertDescription_MissingExtension
  | 110%nat =>
    Result_Ok AlertDescription_UnsupportedExtension
  | 112%nat =>
    Result_Ok AlertDescription_UnrecognizedName
  | 113%nat =>
    Result_Ok AlertDescription_BadCertificateStatusResponse
  | 115%nat =>
    Result_Ok AlertDescription_UnknownPskIdentity
  | 116%nat =>
    Result_Ok AlertDescription_CertificateRequired
  | 120%nat =>
    Result_Ok AlertDescription_NoApplicationProtocol
  | _ =>
    tlserr (parse_failed (ret_both tt))
  end : both (t_Result t_AlertDescription int8) in
  {| f_Error := (@f_Error);
  f_try_from := (@f_try_from)|}.
Fail Next Obligation.
Hint Unfold t_AlertDescription_t_TryFrom.

(* Equations check_psk_shared_key (algs : both t_Algorithms) (ch : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_psk_shared_key algs ch  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] len_id := length_u16_encoded ch in *)
(*     letm[choice_typeMonad.result_bind_code int8] len_tkt := length_u16_encoded (ch.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := (ret_both (2 : uint_size)) .+ len_id))]) in *)
(*     ifb len_id =.? (len_tkt .+ (ret_both (6 : uint_size))) *)
(*     then letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u16_slice (ch.a[(Build_t_Range (f_start := (ret_both (2 : uint_size)) .+ len_id) (f_end := impl__len ch))]) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u8_slice (ch.a[(Build_t_Range (f_start := (ret_both (4 : uint_size)) .+ len_id) (f_end := impl__len ch))]) in *)
(*     Result_Ok (ifb (((impl__len ch) .- (ret_both (5 : uint_size))) .- len_id) <> (impl__HashAlgorithm__hash_len (impl__Algorithms__hash algs)) *)
(*     then tlserr parse_failed *)
(*     else Result_Ok (ret_both (tt : 'unit))) *)
(*     else Result_Ok (tlserr parse_failed)) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_server_psk_shared_key (v__algs : both t_Algorithms) (b : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_server_psk_shared_key v__algs b  := *)
(*     check_eq_slice (unsize (array_from_list [v_U8 (ret_both (0 : int8)); *)
(*       v_U8 (ret_both (0 : int8))])) b : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_server_supported_version (v__algs : both t_Algorithms) (b : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_server_supported_version v__algs b  := *)
(*     check_eq_slice (unsize (array_from_list [v_U8 (ret_both (3 : int8)); *)
(*       v_U8 (ret_both (4 : int8))])) b : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_server_name (extension : both (seq int8)) : both (t_Result t_Bytes int8) := *)
(*   check_server_name extension  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u16_slice extension in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_eq_with_slice (unsize (array_from_list [v_U8 (ret_both (0 : int8))])) extension (ret_both (2 : uint_size)) (ret_both (3 : uint_size)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u16_slice (extension.a[(Build_t_Range (f_start := ret_both (3 : uint_size)) (f_end := impl__len extension))]) in *)
(*     Result_Ok (Result_Ok (f_into (extension.a[(Build_t_Range (f_start := ret_both (5 : uint_size)) (f_end := impl__len extension))])))) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations check_server_key_share (algs : both t_Algorithms) (b : both (seq int8)) : both (t_Result t_Bytes int8) := *)
(*   check_server_key_share algs b  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist39 := impl__Algorithms__supported_group algs in *)
(*     letb hoist40 := impl__Bytes__as_raw hoist39 in *)
(*     letb hoist41 := check_eq_with_slice hoist40 b (ret_both (0 : uint_size)) (ret_both (2 : uint_size)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := hoist41 in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u16_slice (b.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := impl__len b))]) in *)
(*     Result_Ok (Result_Ok (f_from (b.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := impl__len b))])))) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations check_server_extension (algs : both t_Algorithms) (b : both (seq int8)) : both (t_Result (uint_size × t_Option t_Bytes) int8) := *)
(*   check_server_extension algs b  := *)
(*     run (ifb (impl__len b) <.? (ret_both (4 : uint_size)) *)
(*     then Result_Ok (Result_Err parse_failed) *)
(*     else letb l0 := cast_int (WS2 := _) (f_declassify (b.a[(ret_both (0 : uint_size))])) in *)
(*     letb l1 := cast_int (WS2 := _) (f_declassify (b.a[(ret_both (1 : uint_size))])) in *)
(*     letm[choice_typeMonad.result_bind_code int8] len := length_u16_encoded (b.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := impl__len b))]) in *)
(*     letb out := Option_None in *)
(*     letm[choice_typeMonad.result_bind_code int8] out := matchb prod_b (cast_int (WS2 := _) l0,cast_int (WS2 := _) l1) with *)
(*     | '(0,43) => *)
(*       letm[choice_typeMonad.result_bind_code int8] _ := check_server_supported_version algs (b.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) in *)
(*       Result_Ok out *)
(*     | '(0,51) => *)
(*       letm[choice_typeMonad.result_bind_code int8] gx := check_server_key_share algs (b.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) in *)
(*       Result_Ok (Option_Some gx) *)
(*     | '(0,41) => *)
(*       letm[choice_typeMonad.result_bind_code int8] _ := check_server_psk_shared_key algs (b.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) in *)
(*       Result_Ok out *)
(*     | _ => *)
(*       Result_Ok out *)
(*     end in *)
(*     Result_Ok (Result_Ok (prod_b ((ret_both (4 : uint_size)) .+ len,out)))) : both (t_Result (uint_size × t_Option t_Bytes) int8). *)
(* Fail Next Obligation. *)

(* Equations check_signature_algorithms (algs : both t_Algorithms) (ch : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_signature_algorithms algs ch  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u16_slice ch in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist42 := impl__Algorithms__signature_algorithm algs in *)
(*     Result_Ok (letb hoist43 := impl__Bytes__as_raw hoist42 in *)
(*     check_mem hoist43 (ch.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := impl__len ch))]))) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_supported_groups (algs : both t_Algorithms) (ch : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_supported_groups algs ch  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u16_slice ch in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist44 := impl__Algorithms__supported_group algs in *)
(*     Result_Ok (letb hoist45 := impl__Bytes__as_raw hoist44 in *)
(*     check_mem hoist45 (ch.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := impl__len ch))]))) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations parse_ecdsa_signature (sig : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   parse_ecdsa_signature sig  := *)
(*     run (ifb (impl__Bytes__len sig) <.? (ret_both (4 : uint_size)) *)
(*     then Result_Ok (Result_Err parse_failed) *)
(*     else letm[choice_typeMonad.result_bind_code int8] _ := check_eq (bytes1 (ret_both (48 : int8))) (impl__Bytes__slice_range sig (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := ret_both (1 : uint_size)))) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u8 (impl__Bytes__slice_range sig (Build_t_Range (f_start := ret_both (1 : uint_size)) (f_end := impl__Bytes__len sig))) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_eq (bytes1 (ret_both (2 : int8))) (impl__Bytes__slice_range sig (Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := ret_both (3 : uint_size)))) in *)
(*     letm[choice_typeMonad.result_bind_code int8] rlen := length_u8_encoded (sig.a[(Build_t_Range (f_start := ret_both (3 : uint_size)) (f_end := impl__Bytes__len sig))]) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_r_len rlen in *)
(*     letb r := impl__Bytes__slice sig (((ret_both (4 : uint_size)) .+ rlen) .- (ret_both (32 : uint_size))) (ret_both (32 : uint_size)) in *)
(*     ifb (impl__Bytes__len sig) <.? (((ret_both (6 : uint_size)) .+ rlen) .+ (ret_both (32 : uint_size))) *)
(*     then Result_Ok (Result_Err v_INVALID_SIGNATURE) *)
(*     else letm[choice_typeMonad.result_bind_code int8] _ := check_eq (bytes1 (ret_both (2 : int8))) (impl__Bytes__slice_range sig (Build_t_Range (f_start := (ret_both (4 : uint_size)) .+ rlen) (f_end := (ret_both (5 : uint_size)) .+ rlen))) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u8 (impl__Bytes__slice_range sig (Build_t_Range (f_start := (ret_both (5 : uint_size)) .+ rlen) (f_end := impl__Bytes__len sig))) in *)
(*     Result_Ok (letb s := impl__Bytes__slice sig ((impl__Bytes__len sig) .- (ret_both (32 : uint_size))) (ret_both (32 : uint_size)) in *)
(*     Result_Ok (impl__Bytes__concat r s))) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations build_server_name (name : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   build_server_name name  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist77 := encode_length_u16 (f_clone name) in *)
(*     letb hoist78 := impl__Bytes__prefix hoist77 (unsize build_server_name__PREFIX2) in *)
(*     letb hoist79 := encode_length_u16 hoist78 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist80 := hoist79 in *)
(*     letb hoist81 := encode_length_u16 hoist80 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist82 := hoist81 in *)
(*     Result_Ok (letb hoist83 := impl__Bytes__prefix hoist82 (unsize build_server_name__PREFIX1) in *)
(*     Result_Ok hoist83)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations key_shares (algs : both t_Algorithms) (gx : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   key_shares algs gx  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist85 := impl__Algorithms__supported_group algs in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist84 := encode_length_u16 gx in *)
(*     letb ks := impl__Bytes__concat hoist85 hoist84 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist86 := encode_length_u16 ks in *)
(*     letb hoist87 := encode_length_u16 hoist86 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist88 := hoist87 in *)
(*     Result_Ok (letb hoist89 := impl__Bytes__prefix hoist88 (unsize key_shares__PREFIX) in *)
(*     Result_Ok hoist89)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations server_key_shares (algs : both t_Algorithms) (gx : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   server_key_shares algs gx  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist91 := impl__Algorithms__supported_group algs in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist90 := encode_length_u16 gx in *)
(*     letb ks := impl__Bytes__concat hoist91 hoist90 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist92 := encode_length_u16 ks in *)
(*     Result_Ok (letb hoist93 := impl__Bytes__concat (bytes2 (ret_both (0 : int8)) (ret_both (51 : int8))) hoist92 in *)
(*     Result_Ok hoist93)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations server_pre_shared_key (v__algs : both t_Algorithms) : both (t_Result t_Bytes int8) := *)
(*   server_pre_shared_key v__algs  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist94 := encode_length_u16 (bytes2 (ret_both (0 : int8)) (ret_both (0 : int8))) in *)
(*     Result_Ok (letb hoist95 := impl__Bytes__concat (bytes2 (ret_both (0 : int8)) (ret_both (41 : int8))) hoist94 in *)
(*     Result_Ok hoist95)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations server_supported_version (v__algorithms : both t_Algorithms) : both (t_Result t_Bytes int8) := *)
(*   server_supported_version v__algorithms  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist96 := encode_length_u16 (bytes2 (ret_both (3 : int8)) (ret_both (4 : int8))) in *)
(*     Result_Ok (letb hoist97 := impl__Bytes__prefix hoist96 (unsize server_supported_version__SUPPORTED_VERSION_PREFIX) in *)
(*     Result_Ok hoist97)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations signature_algorithms (algs : both t_Algorithms) : both (t_Result t_Bytes int8) := *)
(*   signature_algorithms algs  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist98 := impl__Algorithms__signature_algorithm algs in *)
(*     letb hoist99 := encode_length_u16 hoist98 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist100 := hoist99 in *)
(*     letb hoist101 := encode_length_u16 hoist100 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist102 := hoist101 in *)
(*     Result_Ok (letb hoist103 := impl__Bytes__concat (bytes2 (ret_both (0 : int8)) (ret_both (13 : int8))) hoist102 in *)
(*     Result_Ok hoist103)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations supported_groups (algs : both t_Algorithms) : both (t_Result t_Bytes int8) := *)
(*   supported_groups algs  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist104 := impl__Algorithms__supported_group algs in *)
(*     letb hoist105 := encode_length_u16 hoist104 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist106 := hoist105 in *)
(*     letb hoist107 := encode_length_u16 hoist106 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist108 := hoist107 in *)
(*     Result_Ok (letb hoist109 := impl__Bytes__prefix hoist108 (unsize supported_groups__SUPPORTED_GROUPS_PREFIX) in *)
(*     Result_Ok hoist109)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations ecdsa_signature (sv : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   ecdsa_signature sv  := *)
(*     run (ifb (impl__Bytes__len sv) <> (ret_both (64 : uint_size)) *)
(*     then Result_Ok (Result_Err parse_failed) *)
(*     else letb b0 := bytes1 (ret_both (0 : int8)) in *)
(*     letb b1 := bytes1 (ret_both (48 : int8)) in *)
(*     letb b2 := bytes1 (ret_both (2 : int8)) in *)
(*     letb (r : t_Bytes) := impl__Bytes__slice sv (ret_both (0 : uint_size)) (ret_both (32 : uint_size)) in *)
(*     letb (s : t_Bytes) := impl__Bytes__slice sv (ret_both (32 : uint_size)) (ret_both (32 : uint_size)) in *)
(*     letb r := ifb (f_declassify (r.a[(ret_both (0 : uint_size))])) >=.? (ret_both (128 : int8)) *)
(*     then letb r := impl__Bytes__concat (f_clone b0) r in *)
(*     r *)
(*     else r in *)
(*     letb s := ifb (f_declassify (s.a[(ret_both (0 : uint_size))])) >=.? (ret_both (128 : int8)) *)
(*     then letb s := impl__Bytes__concat b0 s in *)
(*     s *)
(*     else s in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist110 := encode_length_u8 (impl__Bytes__as_raw r) in *)
(*     letb hoist111 := impl__Bytes__concat (f_clone b2) hoist110 in *)
(*     letb hoist113 := impl__Bytes__concat hoist111 b2 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist112 := encode_length_u8 (impl__Bytes__as_raw s) in *)
(*     letb hoist114 := impl__Bytes__concat hoist113 hoist112 in *)
(*     letb hoist115 := impl__Bytes__as_raw hoist114 in *)
(*     letb hoist116 := encode_length_u8 hoist115 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist117 := hoist116 in *)
(*     Result_Ok (letb hoist118 := impl__Bytes__concat b1 hoist117 in *)
(*     Result_Ok hoist118)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations pre_shared_key (algs : both t_Algorithms) (session_ticket : both t_Bytes) : both (t_Result (t_Bytes × uint_size) int8) := *)
(*   pre_shared_key algs session_ticket  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist119 := encode_length_u16 (f_clone session_ticket) in *)
(*     letb hoist120 := impl__Bytes__concat_array hoist119 (u32_as_be_bytes (v_U32 (ret_both (4294967295 : int32)))) in *)
(*     letb hoist121 := encode_length_u16 hoist120 in *)
(*     letm[choice_typeMonad.result_bind_code int8] identities := hoist121 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist122 := encode_length_u8 (impl__Bytes__as_raw (zero_key (impl__Algorithms__hash algs))) in *)
(*     letb hoist123 := encode_length_u16 hoist122 in *)
(*     letm[choice_typeMonad.result_bind_code int8] binders := hoist123 in *)
(*     letb binders_len := impl__Bytes__len binders in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist124 := encode_length_u16 (impl__Bytes__concat identities binders) in *)
(*     Result_Ok (letb ext := impl__Bytes__concat (bytes2 (ret_both (0 : int8)) (ret_both (41 : int8))) hoist124 in *)
(*     Result_Ok (prod_b (ext,binders_len)))) : both (t_Result (t_Bytes × uint_size) int8). *)
(* Fail Next Obligation. *)

(* Equations psk_key_exchange_modes (_ : both 'unit) : both (t_Result t_Bytes int8) := *)
(*   psk_key_exchange_modes _  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist125 := encode_length_u8 (unsize (array_from_list [v_U8 (ret_both (1 : int8))])) in *)
(*     letb hoist126 := encode_length_u16 hoist125 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist127 := hoist126 in *)
(*     Result_Ok (letb hoist128 := impl__Bytes__prefix hoist127 (unsize psk_key_exchange_modes__PSK_MODE_PREFIX) in *)
(*     Result_Ok hoist128)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations get_psk_extensions (algorithms : both t_Algorithms) (session_ticket : both t_Bytes) (extensions : both t_Bytes) : both (t_Result (uint_size × t_Bytes) int8) := *)
(*   get_psk_extensions algorithms session_ticket extensions  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] pskm := psk_key_exchange_modes in *)
(*     letm[choice_typeMonad.result_bind_code int8] '(psk,len) := pre_shared_key algorithms session_ticket in *)
(*     Result_Ok (letb extensions := impl__Bytes__concat (impl__Bytes__concat extensions pskm) psk in *)
(*     Result_Ok (prod_b (len,extensions)))) : both (t_Result (uint_size × t_Bytes) int8). *)
(* Fail Next Obligation. *)

(* Equations supported_versions (_ : both 'unit) : both (t_Result t_Bytes int8) := *)
(*   supported_versions _  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist129 := encode_length_u8 (unsize (array_from_list [v_U8 (ret_both (3 : int8)); *)
(*       v_U8 (ret_both (4 : int8))])) in *)
(*     letb hoist130 := encode_length_u16 hoist129 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist131 := hoist130 in *)
(*     Result_Ok (letb hoist132 := impl__Bytes__concat (f_from (array_from_list [ret_both (0 : int8); *)
(*       ret_both (43 : int8)])) hoist131 in *)
(*     Result_Ok hoist132)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Definition t_Extensions : choice_type := *)
(*   (t_Option t_Bytes × t_Option t_Bytes × t_Option t_Bytes × t_Option t_Bytes). *)
(* Equations f_sni (s : both t_Extensions) : both (t_Option t_Bytes) := *)
(*   f_sni s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (fst (fst (fst x)) : (t_Option t_Bytes))) : both (t_Option t_Bytes). *)
(* Fail Next Obligation. *)
(* Equations f_key_share (s : both t_Extensions) : both (t_Option t_Bytes) := *)
(*   f_key_share s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (snd (fst (fst x)) : (t_Option t_Bytes))) : both (t_Option t_Bytes). *)
(* Fail Next Obligation. *)
(* Equations f_ticket (s : both t_Extensions) : both (t_Option t_Bytes) := *)
(*   f_ticket s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (snd (fst x) : (t_Option t_Bytes))) : both (t_Option t_Bytes). *)
(* Fail Next Obligation. *)
(* Equations f_binder (s : both t_Extensions) : both (t_Option t_Bytes) := *)
(*   f_binder s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (snd x : (t_Option t_Bytes))) : both (t_Option t_Bytes). *)
(* Fail Next Obligation. *)
(* Equations Build_t_Extensions {f_sni : both (t_Option t_Bytes)} {f_key_share : both (t_Option t_Bytes)} {f_ticket : both (t_Option t_Bytes)} {f_binder : both (t_Option t_Bytes)} : both (t_Extensions) := *)
(*   Build_t_Extensions  := *)
(*     bind_both f_binder (fun f_binder => *)
(*       bind_both f_ticket (fun f_ticket => *)
(*         bind_both f_key_share (fun f_key_share => *)
(*           bind_both f_sni (fun f_sni => *)
(*             ret_both ((f_sni,f_key_share,f_ticket,f_binder) : (t_Extensions)))))) : both (t_Extensions). *)
(* Fail Next Obligation. *)
(* Notation "'Build_t_Extensions' '[' x ']' '(' 'f_sni' ':=' y ')'" := (Build_t_Extensions (f_sni := y) (f_key_share := f_key_share x) (f_ticket := f_ticket x) (f_binder := f_binder x)). *)
(* Notation "'Build_t_Extensions' '[' x ']' '(' 'f_key_share' ':=' y ')'" := (Build_t_Extensions (f_sni := f_sni x) (f_key_share := y) (f_ticket := f_ticket x) (f_binder := f_binder x)). *)
(* Notation "'Build_t_Extensions' '[' x ']' '(' 'f_ticket' ':=' y ')'" := (Build_t_Extensions (f_sni := f_sni x) (f_key_share := f_key_share x) (f_ticket := y) (f_binder := f_binder x)). *)
(* Notation "'Build_t_Extensions' '[' x ']' '(' 'f_binder' ':=' y ')'" := (Build_t_Extensions (f_sni := f_sni x) (f_key_share := f_key_share x) (f_ticket := f_ticket x) (f_binder := y)). *)

(* Equations impl__Extensions__merge (self : both t_Extensions) (e2 : both t_Extensions) : both (t_Result t_Extensions int8) := *)
(*   impl__Extensions__merge self e2  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist167 := merge_opts (f_sni self) (f_sni e2) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist166 := merge_opts (f_key_share self) (f_key_share e2) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist165 := merge_opts (f_ticket self) (f_ticket e2) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist164 := merge_opts (f_binder self) (f_binder e2) in *)
(*     Result_Ok (letb hoist168 := Build_t_Extensions (f_sni := hoist167) (f_key_share := hoist166) (f_ticket := hoist165) (f_binder := hoist164) in *)
(*     Result_Ok hoist168)) : both (t_Result t_Extensions int8). *)
(* Fail Next Obligation. *)

(* Equations certificate_verify (algs : both t_Algorithms) (cv : both t_Bytes) : both (t_Result t_HandshakeData int8) := *)
(*   certificate_verify algs cv  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] sv := matchb f_signature algs with *)
(*     | SignatureScheme_RsaPssRsaSha256_case  => *)
(*       Result_Ok (f_clone cv) *)
(*     | SignatureScheme_EcdsaSecp256r1Sha256_case  => *)
(*       ifb (impl__Bytes__len cv) <> (ret_both (64 : uint_size)) *)
(*       then Result_Err parse_failed *)
(*       else ecdsa_signature cv *)
(*     | SignatureScheme_ED25519_case  => *)
(*       Result_Err v_UNSUPPORTED_ALGORITHM *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist173 := impl__Algorithms__signature_algorithm algs in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist172 := encode_length_u16 sv in *)
(*     Result_Ok (letb sig := impl__Bytes__concat hoist173 hoist172 in *)
(*     impl__HandshakeData__from_bytes HandshakeType_CertificateVerify sig)) : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations check_handshake_record (p : both t_Bytes) : both (t_Result (t_HandshakeData × uint_size) int8) := *)
(*   check_handshake_record p  := *)
(*     run (ifb (impl__Bytes__len p) <.? (ret_both (5 : uint_size)) *)
(*     then Result_Ok (Result_Err parse_failed) *)
(*     else letb ty := bytes1 (cast_int (WS2 := _) (discriminant_ContentType_Handshake .+ (ret_both (0 : int8)))) in *)
(*     letb ver := bytes2 (ret_both (3 : int8)) (ret_both (3 : int8)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := matchb check_eq ty (impl__Bytes__slice_range p (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := ret_both (1 : uint_size)))) with *)
(*     | Result_Ok_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : ('unit)) in *)
(*       Result_Ok (ret_both (tt : 'unit)) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (int8)) in *)
(*       application_data_instead_of_handshake *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := matchb check_eq ver (impl__Bytes__slice_range p (Build_t_Range (f_start := ret_both (1 : uint_size)) (f_end := ret_both (3 : uint_size)))) with *)
(*     | Result_Ok_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : ('unit)) in *)
(*       Result_Ok (ret_both (tt : 'unit)) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (int8)) in *)
(*       protocol_version_alert *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code int8] len := length_u16_encoded (p.a[(Build_t_Range (f_start := ret_both (3 : uint_size)) (f_end := impl__Bytes__len p))]) in *)
(*     Result_Ok (Result_Ok (prod_b (HandshakeData (impl__Bytes__slice_range p (Build_t_Range (f_start := ret_both (5 : uint_size)) (f_end := (ret_both (5 : uint_size)) .+ len))),(ret_both (5 : uint_size)) .+ len)))) : both (t_Result (t_HandshakeData × uint_size) int8). *)
(* Fail Next Obligation. *)

(* Equations check_server_extensions (algs : both t_Algorithms) (b : both (seq int8)) : both (t_Result (t_Option t_Bytes) int8) := *)
(*   check_server_extensions algs b  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] '(len,out) := check_server_extension algs b in *)
(*     ifb len =.? (impl__len b) *)
(*     then Result_Ok (Result_Ok out) *)
(*     else letm[choice_typeMonad.result_bind_code int8] out_rest := check_server_extensions algs (b.a[(Build_t_Range (f_start := len) (f_end := impl__len b))]) in *)
(*     Result_Ok (merge_opts out out_rest)) : both (t_Result (t_Option t_Bytes) int8). *)
(* Fail Next Obligation. *)

(* Equations client_hello (algorithms : both t_Algorithms) (client_random : both t_Bytes) (kem_pk : both t_Bytes) (server_name : both t_Bytes) (session_ticket : both (t_Option t_Bytes)) : both (t_Result (t_HandshakeData × uint_size) int8) := *)
(*   client_hello algorithms client_random kem_pk server_name session_ticket  := *)
(*     run (letb version := bytes2 (ret_both (3 : int8)) (ret_both (3 : int8)) in *)
(*     letb compression_methods := bytes2 (ret_both (1 : int8)) (ret_both (0 : int8)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] legacy_session_id := encode_length_u8 (unsize (repeat (v_U8 (ret_both (0 : int8))) (ret_both (32 : uint_size)))) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist174 := impl__Algorithms__ciphersuite algorithms in *)
(*     letb hoist175 := encode_length_u16 hoist174 in *)
(*     letm[choice_typeMonad.result_bind_code int8] cipher_suites := hoist175 in *)
(*     letm[choice_typeMonad.result_bind_code int8] server_name := build_server_name server_name in *)
(*     letm[choice_typeMonad.result_bind_code int8] supported_versions := supported_versions in *)
(*     letm[choice_typeMonad.result_bind_code int8] supported_groups := supported_groups algorithms in *)
(*     letm[choice_typeMonad.result_bind_code int8] signature_algorithms := signature_algorithms algorithms in *)
(*     letm[choice_typeMonad.result_bind_code int8] key_shares := key_shares algorithms (f_clone kem_pk) in *)
(*     letb len := (impl__Bytes__len server_name) .+ (impl__Bytes__len supported_versions) in *)
(*     letb len := len .+ (impl__Bytes__len supported_groups) in *)
(*     letb len := len .+ (impl__Bytes__len signature_algorithms) in *)
(*     letb len := len .+ (impl__Bytes__len key_shares) in *)
(*     letb out := impl__Bytes__new_alloc len in *)
(*     letb out := impl__Bytes__append out server_name in *)
(*     letb out := impl__Bytes__append out supported_versions in *)
(*     letb out := impl__Bytes__append out supported_groups in *)
(*     letb out := impl__Bytes__append out signature_algorithms in *)
(*     letb out := impl__Bytes__append out key_shares in *)
(*     letb extensions := out in *)
(*     letm[choice_typeMonad.result_bind_code int8] '(trunc_len,extensions) := matchb prod_b (impl__Algorithms__psk_mode algorithms,session_ticket) with *)
(*     | '(true,Option_Some session_ticket) => *)
(*       get_psk_extensions algorithms session_ticket extensions *)
(*     | '(false,Option_None ) => *)
(*       Result_Ok (prod_b (ret_both (0 : uint_size),extensions)) *)
(*     | _ => *)
(*       tlserr v_PSK_MODE_MISMATCH *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code int8] encoded_extensions := encode_length_u16 extensions in *)
(*     letb len := (impl__Bytes__len version) .+ (impl__Bytes__len client_random) in *)
(*     letb len := len .+ (impl__Bytes__len legacy_session_id) in *)
(*     letb len := len .+ (impl__Bytes__len cipher_suites) in *)
(*     letb len := len .+ (impl__Bytes__len compression_methods) in *)
(*     letb len := len .+ (impl__Bytes__len encoded_extensions) in *)
(*     letb out := impl__Bytes__new_alloc len in *)
(*     letb out := impl__Bytes__append out version in *)
(*     letb out := impl__Bytes__append out client_random in *)
(*     letb out := impl__Bytes__append out legacy_session_id in *)
(*     letb out := impl__Bytes__append out cipher_suites in *)
(*     letb out := impl__Bytes__append out compression_methods in *)
(*     letb out := impl__Bytes__append out encoded_extensions in *)
(*     letb handshake_bytes := out in *)
(*     letm[choice_typeMonad.result_bind_code int8] client_hello := impl__HandshakeData__from_bytes HandshakeType_ClientHello handshake_bytes in *)
(*     Result_Ok (Result_Ok (prod_b (client_hello,trunc_len)))) : both (t_Result (t_HandshakeData × uint_size) int8). *)
(* Fail Next Obligation. *)

(* Equations encrypted_extensions (v__algs : both t_Algorithms) : both (t_Result t_HandshakeData int8) := *)
(*   encrypted_extensions v__algs  := *)
(*     run (letb handshake_type := bytes1 (cast_int (WS2 := _) (discriminant_HandshakeType_EncryptedExtensions .+ (ret_both (0 : int8)))) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist176 := encode_length_u16 impl__Bytes__new in *)
(*     letb hoist177 := encode_length_u24 hoist176 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist178 := hoist177 in *)
(*     Result_Ok (letb hoist179 := impl__Bytes__concat handshake_type hoist178 in *)
(*     letb hoist180 := HandshakeData hoist179 in *)
(*     Result_Ok hoist180)) : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations find_key_share (g : both t_Bytes) (ch : both (seq int8)) : both (t_Result t_Bytes int8) := *)
(*   find_key_share g ch  := *)
(*     run (ifb (impl__len ch) <.? (ret_both (4 : uint_size)) *)
(*     then Result_Ok (tlserr parse_failed) *)
(*     else ifb eq_slice (impl__Bytes__as_raw g) (ch.a[(Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := ret_both (2 : uint_size)))]) *)
(*     then letm[choice_typeMonad.result_bind_code int8] len := length_u16_encoded_slice (ch.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := impl__len ch))]) in *)
(*     Result_Ok (Result_Ok (f_into (ch.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]))) *)
(*     else letm[choice_typeMonad.result_bind_code int8] len := length_u16_encoded_slice (ch.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := impl__len ch))]) in *)
(*     Result_Ok (find_key_share g (ch.a[(Build_t_Range (f_start := (ret_both (4 : uint_size)) .+ len) (f_end := impl__len ch))]))) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations check_key_shares (algs : both t_Algorithms) (ch : both (seq int8)) : both (t_Result t_Bytes int8) := *)
(*   check_key_shares algs ch  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u16_slice ch in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist181 := impl__Algorithms__supported_group algs in *)
(*     Result_Ok (find_key_share hoist181 (ch.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := impl__len ch))]))) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations check_extension (algs : both t_Algorithms) (bytes : both (seq int8)) : both (t_Result (uint_size × t_Extensions) int8) := *)
(*   check_extension algs bytes  := *)
(*     run (ifb (impl__len bytes) <.? (ret_both (4 : uint_size)) *)
(*     then Result_Ok (Result_Err parse_failed) *)
(*     else letb l0 := cast_int (WS2 := _) (f_declassify (bytes.a[(ret_both (0 : uint_size))])) in *)
(*     letb l1 := cast_int (WS2 := _) (f_declassify (bytes.a[(ret_both (1 : uint_size))])) in *)
(*     letm[choice_typeMonad.result_bind_code int8] len := length_u16_encoded_slice (bytes.a[(Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := impl__len bytes))]) in *)
(*     letb out := Build_t_Extensions (f_sni := Option_None) (f_key_share := Option_None) (f_ticket := Option_None) (f_binder := Option_None) in *)
(*     matchb prod_b (cast_int (WS2 := _) l0,cast_int (WS2 := _) l1) with *)
(*     | '(0,0) => *)
(*       letm[choice_typeMonad.result_bind_code int8] hoist182 := check_server_name (bytes.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) in *)
(*       Result_Ok (letb hoist183 := Option_Some hoist182 in *)
(*       letb hoist184 := Build_t_Extensions (f_sni := hoist183) (f_key_share := Option_None) (f_ticket := Option_None) (f_binder := Option_None) in *)
(*       letb hoist185 := prod_b ((ret_both (4 : uint_size)) .+ len,hoist184) in *)
(*       Result_Ok hoist185) *)
(*     | '(0,45) => *)
(*       letm[choice_typeMonad.result_bind_code int8] _ := check_psk_key_exchange_modes (bytes.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) in *)
(*       Result_Ok (Result_Ok (prod_b ((ret_both (4 : uint_size)) .+ len,out))) *)
(*     | '(0,43) => *)
(*       letm[choice_typeMonad.result_bind_code int8] _ := check_supported_versions (bytes.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) in *)
(*       Result_Ok (Result_Ok (prod_b ((ret_both (4 : uint_size)) .+ len,out))) *)
(*     | '(0,10) => *)
(*       letm[choice_typeMonad.result_bind_code int8] _ := check_supported_groups algs (bytes.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) in *)
(*       Result_Ok (Result_Ok (prod_b ((ret_both (4 : uint_size)) .+ len,out))) *)
(*     | '(0,13) => *)
(*       letm[choice_typeMonad.result_bind_code int8] _ := check_signature_algorithms algs (bytes.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) in *)
(*       Result_Ok (Result_Ok (prod_b ((ret_both (4 : uint_size)) .+ len,out))) *)
(*     | '(0,51) => *)
(*       Result_Ok (matchb check_key_shares algs (bytes.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) with *)
(*       | Result_Ok_case gx => *)
(*         letb gx := ret_both ((gx) : (t_Bytes)) in *)
(*         Result_Ok (prod_b ((ret_both (4 : uint_size)) .+ len,Build_t_Extensions (f_sni := Option_None) (f_key_share := Option_Some gx) (f_ticket := Option_None) (f_binder := Option_None))) *)
(*       | Result_Err_case _ => *)
(*         letb _ := ret_both (tt (* Empty tuple *) : (int8)) in *)
(*         tlserr v_MISSING_KEY_SHARE *)
(*       end) *)
(*     | '(0,41) => *)
(*       letm[choice_typeMonad.result_bind_code int8] _ := check_psk_shared_key algs (bytes.a[(Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len))]) in *)
(*       Result_Ok (Result_Ok (prod_b ((ret_both (4 : uint_size)) .+ len,out))) *)
(*     | _ => *)
(*       Result_Ok (Result_Ok (prod_b ((ret_both (4 : uint_size)) .+ len,out))) *)
(*     end) : both (t_Result (uint_size × t_Extensions) int8). *)
(* Fail Next Obligation. *)

(* Equations finished (vd : both t_Bytes) : both (t_Result t_HandshakeData int8) := *)
(*   finished vd  := *)
(*     impl__HandshakeData__from_bytes HandshakeType_Finished vd : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations get_handshake_record (p : both t_Bytes) : both (t_Result t_HandshakeData int8) := *)
(*   get_handshake_record p  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] '(hd,len) := check_handshake_record p in *)
(*     Result_Ok (ifb len =.? (impl__Bytes__len p) *)
(*     then Result_Ok hd *)
(*     else Result_Err parse_failed)) : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations handshake_record (p : both t_HandshakeData) : both (t_Result t_Bytes int8) := *)
(*   handshake_record p  := *)
(*     run (letb ty := bytes1 (cast_int (WS2 := _) (discriminant_ContentType_Handshake .+ (ret_both (0 : int8)))) in *)
(*     letb ver := bytes2 (ret_both (3 : int8)) (ret_both (3 : int8)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist186 := encode_length_u16 (0 p) in *)
(*     Result_Ok (letb hoist187 := impl__Bytes__concat (impl__Bytes__concat ty ver) hoist186 in *)
(*     Result_Ok hoist187)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations parse_certificate_verify (algs : both t_Algorithms) (certificate_verify : both t_HandshakeData) : both (t_Result t_Bytes int8) := *)
(*   parse_certificate_verify algs certificate_verify  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] HandshakeData cv := impl__HandshakeData__as_handshake_message certificate_verify HandshakeType_CertificateVerify in *)
(*     letb sa := impl__Algorithms__signature algs in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist188 := impl__Algorithms__signature_algorithm algs in *)
(*     letb hoist189 := impl__Bytes__as_raw hoist188 in *)
(*     letb hoist190 := check_eq_with_slice hoist189 (impl__Bytes__as_raw cv) (ret_both (0 : uint_size)) (ret_both (2 : uint_size)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := hoist190 in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u16 (impl__Bytes__slice_range cv (Build_t_Range (f_start := ret_both (2 : uint_size)) (f_end := impl__Bytes__len cv))) in *)
(*     Result_Ok (matchb sa with *)
(*     | SignatureScheme_EcdsaSecp256r1Sha256_case  => *)
(*       parse_ecdsa_signature (impl__Bytes__slice_range cv (Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := impl__Bytes__len cv))) *)
(*     | SignatureScheme_RsaPssRsaSha256_case  => *)
(*       Result_Ok (impl__Bytes__slice_range cv (Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := impl__Bytes__len cv))) *)
(*     | SignatureScheme_ED25519_case  => *)
(*       ifb ((impl__Bytes__len cv) .- (ret_both (4 : uint_size))) =.? (ret_both (64 : uint_size)) *)
(*       then Result_Ok (impl__Bytes__slice_range cv (Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := impl__Bytes__len cv))) *)
(*       else Result_Err v_INVALID_SIGNATURE *)
(*     end)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations parse_encrypted_extensions (v__algs : both t_Algorithms) (encrypted_extensions : both t_HandshakeData) : both (t_Result 'unit int8) := *)
(*   parse_encrypted_extensions v__algs encrypted_extensions  := *)
(*     run (letb HandshakeData encrypted_extension_bytes := encrypted_extensions in *)
(*     letb expected_handshake_type := bytes1 (cast_int (WS2 := _) (discriminant_HandshakeType_EncryptedExtensions .+ (ret_both (0 : int8)))) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_eq_with_slice (impl__Bytes__as_raw expected_handshake_type) (impl__Bytes__as_raw encrypted_extension_bytes) (ret_both (0 : uint_size)) (ret_both (1 : uint_size)) in *)
(*     Result_Ok (check_length_encoding_u24 (impl__Bytes__raw_slice encrypted_extension_bytes (Build_t_Range (f_start := ret_both (1 : uint_size)) (f_end := impl__Bytes__len encrypted_extension_bytes))))) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations parse_finished (finished : both t_HandshakeData) : both (t_Result t_Bytes int8) := *)
(*   parse_finished finished  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] HandshakeData fin := impl__HandshakeData__as_handshake_message finished HandshakeType_Finished in *)
(*     Result_Ok (Result_Ok fin)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations parse_server_certificate (certificate : both t_HandshakeData) : both (t_Result t_Bytes int8) := *)
(*   parse_server_certificate certificate  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] HandshakeData sc := impl__HandshakeData__as_handshake_message certificate HandshakeType_Certificate in *)
(*     letb next := ret_both (0 : uint_size) in *)
(*     letm[choice_typeMonad.result_bind_code int8] creqlen := length_u8_encoded (sc.a[(Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := impl__Bytes__len sc))]) in *)
(*     letb next := (next .+ (ret_both (1 : uint_size))) .+ creqlen in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u24 (impl__Bytes__raw_slice sc (Build_t_Range (f_start := next) (f_end := impl__Bytes__len sc))) in *)
(*     letb next := next .+ (ret_both (3 : uint_size)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] crtlen := length_u24_encoded (impl__Bytes__raw_slice sc (Build_t_Range (f_start := next) (f_end := impl__Bytes__len sc))) in *)
(*     letb next := next .+ (ret_both (3 : uint_size)) in *)
(*     letb crt := impl__Bytes__slice_range sc (Build_t_Range (f_start := next) (f_end := next .+ crtlen)) in *)
(*     letb next := next .+ crtlen in *)
(*     letm[choice_typeMonad.result_bind_code int8] v__extlen := length_u16_encoded (sc.a[(Build_t_Range (f_start := next) (f_end := impl__Bytes__len sc))]) in *)
(*     Result_Ok (Result_Ok crt)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations parse_server_hello (algs : both t_Algorithms) (server_hello : both t_HandshakeData) : both (t_Result (t_Bytes × t_Bytes) int8) := *)
(*   parse_server_hello algs server_hello  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] HandshakeData server_hello := impl__HandshakeData__as_handshake_message server_hello HandshakeType_ServerHello in *)
(*     letb ver := bytes2 (ret_both (3 : int8)) (ret_both (3 : int8)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] cip := impl__Algorithms__ciphersuite algs in *)
(*     letb comp := bytes1 (ret_both (0 : int8)) in *)
(*     letb next := ret_both (0 : uint_size) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := matchb check_eq_with_slice (impl__Bytes__as_raw ver) (impl__Bytes__as_raw server_hello) next (next .+ (ret_both (2 : uint_size))) with *)
(*     | Result_Ok_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : ('unit)) in *)
(*       Result_Ok (ret_both (tt : 'unit)) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (int8)) in *)
(*       protocol_version_alert *)
(*     end in *)
(*     letb next := next .+ (ret_both (2 : uint_size)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check ((impl__Bytes__len server_hello) >=.? (next .+ (ret_both (32 : uint_size)))) in *)
(*     letb srand := impl__Bytes__slice_range server_hello (Build_t_Range (f_start := next) (f_end := next .+ (ret_both (32 : uint_size)))) in *)
(*     letb next := next .+ (ret_both (32 : uint_size)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] sidlen := length_u8_encoded (server_hello.a[(Build_t_Range (f_start := next) (f_end := impl__Bytes__len server_hello))]) in *)
(*     letb next := (next .+ (ret_both (1 : uint_size))) .+ sidlen in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := matchb check_eq_with_slice (impl__Bytes__as_raw cip) (impl__Bytes__as_raw server_hello) next (next .+ (ret_both (2 : uint_size))) with *)
(*     | Result_Ok_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : ('unit)) in *)
(*       Result_Ok (ret_both (tt : 'unit)) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (int8)) in *)
(*       unsupported_cipher_alert *)
(*     end in *)
(*     letb next := next .+ (ret_both (2 : uint_size)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := matchb check_eq_with_slice (impl__Bytes__as_raw comp) (impl__Bytes__as_raw server_hello) next (next .+ (ret_both (1 : uint_size))) with *)
(*     | Result_Ok_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : ('unit)) in *)
(*       Result_Ok (ret_both (tt : 'unit)) *)
(*     | Result_Err_case _ => *)
(*       letb _ := ret_both (tt (* Empty tuple *) : (int8)) in *)
(*       invalid_compression_method_alert *)
(*     end in *)
(*     letb next := next .+ (ret_both (1 : uint_size)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] _ := check_length_encoding_u16 (impl__Bytes__slice_range server_hello (Build_t_Range (f_start := next) (f_end := impl__Bytes__len server_hello))) in *)
(*     letb next := next .+ (ret_both (2 : uint_size)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] gy := check_server_extensions algs (server_hello.a[(Build_t_Range (f_start := next) (f_end := impl__Bytes__len server_hello))]) in *)
(*     Result_Ok (matchb gy with *)
(*     | Option_Some_case gy => *)
(*       letb gy := ret_both ((gy) : (t_Bytes)) in *)
(*       Result_Ok (prod_b (srand,gy)) *)
(*     | _ => *)
(*       Result_Err v_MISSING_KEY_SHARE *)
(*     end)) : both (t_Result (t_Bytes × t_Bytes) int8). *)
(* Fail Next Obligation. *)

(* Equations server_certificate (v__algs : both t_Algorithms) (cert : both t_Bytes) : both (t_Result t_HandshakeData int8) := *)
(*   server_certificate v__algs cert  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] creq := encode_length_u8 (unsize !TODO empty array!) in *)
(*     letm[choice_typeMonad.result_bind_code int8] crt := encode_length_u24 cert in *)
(*     letm[choice_typeMonad.result_bind_code int8] ext := encode_length_u16 impl__Bytes__new in *)
(*     letm[choice_typeMonad.result_bind_code int8] crts := encode_length_u24 (impl__Bytes__concat crt ext) in *)
(*     Result_Ok (impl__HandshakeData__from_bytes HandshakeType_Certificate (impl__Bytes__concat creq crts))) : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations server_hello (algs : both t_Algorithms) (sr : both t_Bytes) (sid : both t_Bytes) (gy : both t_Bytes) : both (t_Result t_HandshakeData int8) := *)
(*   server_hello algs sr sid gy  := *)
(*     run (letb ver := bytes2 (ret_both (3 : int8)) (ret_both (3 : int8)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] sid := encode_length_u8 (impl__Bytes__as_raw sid) in *)
(*     letm[choice_typeMonad.result_bind_code int8] cip := impl__Algorithms__ciphersuite algs in *)
(*     letb comp := bytes1 (ret_both (0 : int8)) in *)
(*     letm[choice_typeMonad.result_bind_code int8] ks := server_key_shares algs (f_clone gy) in *)
(*     letm[choice_typeMonad.result_bind_code int8] sv := server_supported_version algs in *)
(*     letb exts := impl__Bytes__concat ks sv in *)
(*     letm[choice_typeMonad.result_bind_code int8] exts := matchb impl__Algorithms__psk_mode algs with *)
(*     | true => *)
(*       letm[choice_typeMonad.result_bind_code int8] hoist191 := server_pre_shared_key algs in *)
(*       Result_Ok (letb hoist192 := impl__Bytes__concat exts hoist191 in *)
(*       hoist192) *)
(*     | false => *)
(*       Result_Ok exts *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code int8] encoded_extensions := encode_length_u16 exts in *)
(*     letb len := (impl__Bytes__len ver) .+ (impl__Bytes__len sr) in *)
(*     letb len := len .+ (impl__Bytes__len sid) in *)
(*     letb len := len .+ (impl__Bytes__len cip) in *)
(*     letb len := len .+ (impl__Bytes__len comp) in *)
(*     letb len := len .+ (impl__Bytes__len encoded_extensions) in *)
(*     letb out := impl__Bytes__new_alloc len in *)
(*     letb out := impl__Bytes__append out ver in *)
(*     letb out := impl__Bytes__append out sr in *)
(*     letb out := impl__Bytes__append out sid in *)
(*     letb out := impl__Bytes__append out cip in *)
(*     letb out := impl__Bytes__append out comp in *)
(*     letb out := impl__Bytes__append out encoded_extensions in *)
(*     letb hoist193 := out in *)
(*     letb hoist194 := impl__HandshakeData__from_bytes HandshakeType_ServerHello hoist193 in *)
(*     letm[choice_typeMonad.result_bind_code int8] sh := hoist194 in *)
(*     Result_Ok (Result_Ok sh)) : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Equations set_client_hello_binder (ciphersuite : both t_Algorithms) (binder : both (t_Option t_Bytes)) (client_hello : both t_HandshakeData) (trunc_len : both (t_Option uint_size)) : both (t_Result t_HandshakeData int8) := *)
(*   set_client_hello_binder ciphersuite binder client_hello trunc_len  := *)
(*     letb HandshakeData ch := client_hello in *)
(*     letb chlen := impl__Bytes__len ch in *)
(*     letb hlen := impl__HashAlgorithm__hash_len (impl__Algorithms__hash ciphersuite) in *)
(*     matchb prod_b (binder,trunc_len) with *)
(*     | '(Option_Some m,Option_Some trunc_len) => *)
(*       ifb (chlen .- hlen) =.? trunc_len *)
(*       then Result_Ok (HandshakeData (impl__Bytes__update_slice ch trunc_len m (ret_both (0 : uint_size)) hlen)) *)
(*       else tlserr parse_failed *)
(*     | '(Option_None ,Option_None ) => *)
(*       Result_Ok (HandshakeData ch) *)
(*     | '(_,_) => *)
(*       tlserr parse_failed *)
(*     end : both (t_Result t_HandshakeData int8). *)
(* Fail Next Obligation. *)

(* Definition t_Transcript : choice_type := *)
(*   (t_HashAlgorithm × t_HandshakeData). *)
(* Equations f_hash_algorithm (s : both t_Transcript) : both t_HashAlgorithm := *)
(*   f_hash_algorithm s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (fst x : t_HashAlgorithm)) : both t_HashAlgorithm. *)
(* Fail Next Obligation. *)
(* Equations f_transcript (s : both t_Transcript) : both t_HandshakeData := *)
(*   f_transcript s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (snd x : t_HandshakeData)) : both t_HandshakeData. *)
(* Fail Next Obligation. *)
(* Equations Build_t_Transcript {f_hash_algorithm : both t_HashAlgorithm} {f_transcript : both t_HandshakeData} : both (t_Transcript) := *)
(*   Build_t_Transcript  := *)
(*     bind_both f_transcript (fun f_transcript => *)
(*       bind_both f_hash_algorithm (fun f_hash_algorithm => *)
(*         ret_both ((f_hash_algorithm,f_transcript) : (t_Transcript)))) : both (t_Transcript). *)
(* Fail Next Obligation. *)
(* Notation "'Build_t_Transcript' '[' x ']' '(' 'f_hash_algorithm' ':=' y ')'" := (Build_t_Transcript (f_hash_algorithm := y) (f_transcript := f_transcript x)). *)
(* Notation "'Build_t_Transcript' '[' x ']' '(' 'f_transcript' ':=' y ')'" := (Build_t_Transcript (f_hash_algorithm := f_hash_algorithm x) (f_transcript := y)). *)

(* Equations impl__Transcript__add (self : both t_Transcript) (msg : both t_HandshakeData) : both t_Transcript := *)
(*   impl__Transcript__add self msg  := *)
(*     letb self := Build_t_Transcript[self] (f_transcript := impl__HandshakeData__concat (f_transcript self) msg) in *)
(*     self : both t_Transcript. *)
(* Fail Next Obligation. *)

(* Equations impl__Transcript__new (hash_algorithm : both t_HashAlgorithm) : both t_Transcript := *)
(*   impl__Transcript__new hash_algorithm  := *)
(*     Build_t_Transcript (f_hash_algorithm := hash_algorithm) (f_transcript := HandshakeData impl__Bytes__new) : both t_Transcript. *)
(* Fail Next Obligation. *)

(* Equations impl__Transcript__transcript_hash (self : both t_Transcript) : both (t_Result t_Bytes int8) := *)
(*   impl__Transcript__transcript_hash self  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] th := impl__HashAlgorithm__hash (f_hash_algorithm self) (0 (f_transcript self)) in *)
(*     Result_Ok (Result_Ok th)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations impl__Transcript__transcript_hash_without_client_hello (self : both t_Transcript) (client_hello : both t_HandshakeData) (trunc_len : both uint_size) : both (t_Result t_Bytes int8) := *)
(*   impl__Transcript__transcript_hash_without_client_hello self client_hello trunc_len  := *)
(*     letb HandshakeData ch := client_hello in *)
(*     impl__HashAlgorithm__hash (f_hash_algorithm self) (impl__Bytes__concat (f_clone (0 (f_transcript self))) (impl__Bytes__slice_range (0 client_hello) (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := trunc_len)))) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations check_extensions_slice (algs : both t_Algorithms) (b : both (seq int8)) : both (t_Result t_Extensions int8) := *)
(*   check_extensions_slice algs b  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] '(len,out) := check_extension algs b in *)
(*     ifb len =.? (impl__len b) *)
(*     then Result_Ok (Result_Ok out) *)
(*     else letm[choice_typeMonad.result_bind_code int8] out_rest := check_extensions_slice algs (b.a[(Build_t_Range (f_start := len) (f_end := impl__len b))]) in *)
(*     Result_Ok (impl__Extensions__merge out out_rest)) : both (t_Result t_Extensions int8). *)
(* Fail Next Obligation. *)

(* Equations check_extensions (algs : both t_Algorithms) (b : both t_Bytes) : both (t_Result t_Extensions int8) := *)
(*   check_extensions algs b  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] '(len,out) := check_extension algs (impl__Bytes__as_raw b) in *)
(*     ifb len =.? (impl__Bytes__len b) *)
(*     then Result_Ok (Result_Ok out) *)
(*     else letm[choice_typeMonad.result_bind_code int8] out_rest := check_extensions_slice algs (impl__Bytes__raw_slice b (Build_t_Range (f_start := len) (f_end := impl__Bytes__len b))) in *)
(*     Result_Ok (impl__Extensions__merge out out_rest)) : both (t_Result t_Extensions int8). *)
(* Fail Next Obligation. *)

(* (*item error backend*) *)
