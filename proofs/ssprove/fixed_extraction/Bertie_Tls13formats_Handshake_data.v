(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import bytes1.
Export bytes1.

Require Import check_eq.
Export check_eq.

Require Import encode_length_u24.
Export encode_length_u24.

Require Import eq1.
Export eq1.

Require Import length_u24_encoded.
Export length_u24_encoded.

Require Import parse_failed.
Export parse_failed.

Require Import tlserr.
Export tlserr.

Require Import Bytes.
Export Bytes.

Require Import TLSError.
Export TLSError.

Require Import U8.
Export U8.

Equations discriminant_HandshakeType_Certificate : both int8 :=
  discriminant_HandshakeType_Certificate  :=
    ret_both (11 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_HandshakeType_CertificateRequest : both int8 :=
  discriminant_HandshakeType_CertificateRequest  :=
    ret_both (13 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_HandshakeType_CertificateVerify : both int8 :=
  discriminant_HandshakeType_CertificateVerify  :=
    ret_both (15 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_HandshakeType_ClientHello : both int8 :=
  discriminant_HandshakeType_ClientHello  :=
    ret_both (1 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_HandshakeType_EncryptedExtensions : both int8 :=
  discriminant_HandshakeType_EncryptedExtensions  :=
    ret_both (8 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_HandshakeType_EndOfEarlyData : both int8 :=
  discriminant_HandshakeType_EndOfEarlyData  :=
    ret_both (5 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_HandshakeType_Finished : both int8 :=
  discriminant_HandshakeType_Finished  :=
    ret_both (20 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_HandshakeType_KeyUpdate : both int8 :=
  discriminant_HandshakeType_KeyUpdate  :=
    ret_both (24 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_HandshakeType_MessageHash : both int8 :=
  discriminant_HandshakeType_MessageHash  :=
    ret_both (254 : int8) : both int8.
Fail Next Obligation.

Equations discriminant_HandshakeType_NewSessionTicket : both int8 :=
  discriminant_HandshakeType_NewSessionTicket  :=
    ret_both (4 : int8) : both int8.
Fail Next Obligation.

Definition t_HandshakeType : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'HandshakeType_ClientHello_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl tt)))))))))) (at level 100).
Equations HandshakeType_ClientHello : both t_HandshakeType :=
  HandshakeType_ClientHello  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (tt : 'unit)))))))))) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_ServerHello_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))) (at level 100).
Equations HandshakeType_ServerHello : both t_HandshakeType :=
  HandshakeType_ServerHello  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_NewSessionTicket_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))) (at level 100).
Equations HandshakeType_NewSessionTicket : both t_HandshakeType :=
  HandshakeType_NewSessionTicket  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_EndOfEarlyData_case'" := (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))) (at level 100).
Equations HandshakeType_EndOfEarlyData : both t_HandshakeType :=
  HandshakeType_EndOfEarlyData  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_EncryptedExtensions_case'" := (inl (inl (inl (inl (inl (inl (inr tt))))))) (at level 100).
Equations HandshakeType_EncryptedExtensions : both t_HandshakeType :=
  HandshakeType_EncryptedExtensions  :=
    ret_both (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_Certificate_case'" := (inl (inl (inl (inl (inl (inr tt)))))) (at level 100).
Equations HandshakeType_Certificate : both t_HandshakeType :=
  HandshakeType_Certificate  :=
    ret_both (inl (inl (inl (inl (inl (inr (tt : 'unit)))))) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_CertificateRequest_case'" := (inl (inl (inl (inl (inr tt))))) (at level 100).
Equations HandshakeType_CertificateRequest : both t_HandshakeType :=
  HandshakeType_CertificateRequest  :=
    ret_both (inl (inl (inl (inl (inr (tt : 'unit))))) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_CertificateVerify_case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations HandshakeType_CertificateVerify : both t_HandshakeType :=
  HandshakeType_CertificateVerify  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_Finished_case'" := (inl (inl (inr tt))) (at level 100).
Equations HandshakeType_Finished : both t_HandshakeType :=
  HandshakeType_Finished  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_KeyUpdate_case'" := (inl (inr tt)) (at level 100).
Equations HandshakeType_KeyUpdate : both t_HandshakeType :=
  HandshakeType_KeyUpdate  :=
    ret_both (inl (inr (tt : 'unit)) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.
Notation "'HandshakeType_MessageHash_case'" := (inr tt) (at level 100).
Equations HandshakeType_MessageHash : both t_HandshakeType :=
  HandshakeType_MessageHash  :=
    ret_both (inr (tt : 'unit) : t_HandshakeType) : both t_HandshakeType.
Fail Next Obligation.

Equations discriminant_HandshakeType_ServerHello : both int8 :=
  discriminant_HandshakeType_ServerHello  :=
    ret_both (2 : int8) : both int8.
Fail Next Obligation.

Equations t_HandshakeType_cast_to_repr (x : both t_HandshakeType) : both int8 :=
  t_HandshakeType_cast_to_repr x  :=
    matchb x with
    | HandshakeType_ClientHello_case  =>
      discriminant_HandshakeType_ClientHello
    | HandshakeType_ServerHello_case  =>
      discriminant_HandshakeType_ServerHello
    | HandshakeType_NewSessionTicket_case  =>
      discriminant_HandshakeType_NewSessionTicket
    | HandshakeType_EndOfEarlyData_case  =>
      discriminant_HandshakeType_EndOfEarlyData
    | HandshakeType_EncryptedExtensions_case  =>
      discriminant_HandshakeType_EncryptedExtensions
    | HandshakeType_Certificate_case  =>
      discriminant_HandshakeType_Certificate
    | HandshakeType_CertificateRequest_case  =>
      discriminant_HandshakeType_CertificateRequest
    | HandshakeType_CertificateVerify_case  =>
      discriminant_HandshakeType_CertificateVerify
    | HandshakeType_Finished_case  =>
      discriminant_HandshakeType_Finished
    | HandshakeType_KeyUpdate_case  =>
      discriminant_HandshakeType_KeyUpdate
    | HandshakeType_MessageHash_case  =>
      discriminant_HandshakeType_MessageHash
    end : both int8.
Fail Next Obligation.

Equations get_hs_type (t : both int8) : both (t_Result t_HandshakeType int8) :=
  get_hs_type t  :=
    matchb t with
    | 1 =>
      Result_Ok HandshakeType_ClientHello
    | 2 =>
      Result_Ok HandshakeType_ServerHello
    | 4 =>
      Result_Ok HandshakeType_NewSessionTicket
    | 5 =>
      Result_Ok HandshakeType_EndOfEarlyData
    | 8 =>
      Result_Ok HandshakeType_EncryptedExtensions
    | 11 =>
      Result_Ok HandshakeType_Certificate
    | 13 =>
      Result_Ok HandshakeType_CertificateRequest
    | 15 =>
      Result_Ok HandshakeType_CertificateVerify
    | 20 =>
      Result_Ok HandshakeType_Finished
    | 24 =>
      Result_Ok HandshakeType_KeyUpdate
    | 254 =>
      Result_Ok HandshakeType_MessageHash
    | _ =>
      tlserr parse_failed
    end : both (t_Result t_HandshakeType int8).
Fail Next Obligation.

Definition t_HandshakeData : choice_type :=
  (t_Bytes).
Equations 0 (s : both t_HandshakeData) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (x : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations Build_t_HandshakeData {0 : both t_Bytes} : both (t_HandshakeData) :=
  Build_t_HandshakeData  :=
    bind_both 0 (fun 0 =>
      ret_both ((0) : (t_HandshakeData))) : both (t_HandshakeData).
Fail Next Obligation.
Notation "'Build_t_HandshakeData' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_HandshakeData (0 := y)).

Equations impl__HandshakeData__len (self : both t_HandshakeData) : both uint_size :=
  impl__HandshakeData__len self  :=
    impl__Bytes__len (0 self) : both uint_size.
Fail Next Obligation.

Equations impl__HandshakeData__next_handshake_message (self : both t_HandshakeData) : both (t_Result (t_HandshakeData × t_HandshakeData) int8) :=
  impl__HandshakeData__next_handshake_message self  :=
    run (ifb (impl__HandshakeData__len self) <.? (ret_both (4 : uint_size))
    then Result_Ok (tlserr parse_failed)
    else letm[choice_typeMonad.result_bind_code int8] len := length_u24_encoded (impl__Bytes__raw_slice (0 self) (Build_t_Range (f_start := ret_both (1 : uint_size)) (f_end := impl__Bytes__len (0 self)))) in
    Result_Ok (letb message := impl__Bytes__slice_range (0 self) (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := (ret_both (4 : uint_size)) .+ len)) in
    letb rest := impl__Bytes__slice_range (0 self) (Build_t_Range (f_start := (ret_both (4 : uint_size)) .+ len) (f_end := impl__Bytes__len (0 self))) in
    Result_Ok (prod_b (HandshakeData message,HandshakeData rest)))) : both (t_Result (t_HandshakeData × t_HandshakeData) int8).
Fail Next Obligation.

Equations impl__HandshakeData__as_handshake_message (self : both t_HandshakeData) (expected_type : both t_HandshakeType) : both (t_Result t_HandshakeData int8) :=
  impl__HandshakeData__as_handshake_message self expected_type  :=
    run (letm[choice_typeMonad.result_bind_code int8] '(message,payload_rest) := impl__HandshakeData__next_handshake_message self in
    letm[choice_typeMonad.result_bind_code int8] HandshakeData tagged_message_bytes := ifb (impl__HandshakeData__len payload_rest) <> (ret_both (0 : uint_size))
    then tlserr parse_failed
    else Result_Ok message in
    letb expected_bytes := bytes1 (t_HandshakeType_cast_to_repr expected_type) in
    letm[choice_typeMonad.result_bind_code int8] _ := check_eq expected_bytes (impl__Bytes__slice_range tagged_message_bytes (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := ret_both (1 : uint_size)))) in
    Result_Ok (Result_Ok (HandshakeData (impl__Bytes__slice_range tagged_message_bytes (Build_t_Range (f_start := ret_both (4 : uint_size)) (f_end := impl__Bytes__len tagged_message_bytes)))))) : both (t_Result t_HandshakeData int8).
Fail Next Obligation.

Equations impl__HandshakeData__to_bytes (self : both t_HandshakeData) : both t_Bytes :=
  impl__HandshakeData__to_bytes self  :=
    f_clone (0 self) : both t_Bytes.
Fail Next Obligation.

Equations impl__HandshakeData__to_four (self : both t_HandshakeData) : both (t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_HandshakeData) int8) :=
  impl__HandshakeData__to_four self  :=
    run (letm[choice_typeMonad.result_bind_code int8] '(message1,payload_rest) := impl__HandshakeData__next_handshake_message self in
    letm[choice_typeMonad.result_bind_code int8] '(message2,payload_rest) := impl__HandshakeData__next_handshake_message payload_rest in
    letm[choice_typeMonad.result_bind_code int8] '(message3,payload_rest) := impl__HandshakeData__next_handshake_message payload_rest in
    letm[choice_typeMonad.result_bind_code int8] '(message4,payload_rest) := impl__HandshakeData__next_handshake_message payload_rest in
    Result_Ok (ifb (impl__HandshakeData__len payload_rest) <> (ret_both (0 : uint_size))
    then tlserr parse_failed
    else Result_Ok (prod_b (message1,message2,message3,message4)))) : both (t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_HandshakeData) int8).
Fail Next Obligation.

Equations impl__HandshakeData__to_two (self : both t_HandshakeData) : both (t_Result (t_HandshakeData × t_HandshakeData) int8) :=
  impl__HandshakeData__to_two self  :=
    run (letm[choice_typeMonad.result_bind_code int8] '(message1,payload_rest) := impl__HandshakeData__next_handshake_message self in
    letm[choice_typeMonad.result_bind_code int8] '(message2,payload_rest) := impl__HandshakeData__next_handshake_message payload_rest in
    Result_Ok (ifb (impl__HandshakeData__len payload_rest) <> (ret_both (0 : uint_size))
    then tlserr parse_failed
    else Result_Ok (prod_b (message1,message2)))) : both (t_Result (t_HandshakeData × t_HandshakeData) int8).
Fail Next Obligation.

#[global] Program Instance t_HandshakeData_t_From : t_From t_HandshakeData t_Bytes :=
  let f_from := fun  (value : both t_Bytes) => HandshakeData value : both t_HandshakeData in
  {| f_from := (@f_from)|}.
Fail Next Obligation.
Hint Unfold t_HandshakeData_t_From.

Equations impl__HandshakeData__concat (self : both t_HandshakeData) (other : both t_HandshakeData) : both t_HandshakeData :=
  impl__HandshakeData__concat self other  :=
    letb message1 := impl__HandshakeData__to_bytes self in
    letb message2 := impl__HandshakeData__to_bytes other in
    letb message1 := impl__Bytes__extend_from_slice message1 message2 in
    f_from message1 : both t_HandshakeData.
Fail Next Obligation.

Equations impl__HandshakeData__from_bytes (handshake_type : both t_HandshakeType) (handshake_bytes : both t_Bytes) : both (t_Result t_HandshakeData int8) :=
  impl__HandshakeData__from_bytes handshake_type handshake_bytes  :=
    run (letm[choice_typeMonad.result_bind_code int8] hoist169 := encode_length_u24 handshake_bytes in
    Result_Ok (letb hoist170 := impl__Bytes__prefix hoist169 (unsize (array_from_list [v_U8 (t_HandshakeType_cast_to_repr handshake_type)])) in
    letb hoist171 := f_from hoist170 in
    Result_Ok hoist171)) : both (t_Result t_HandshakeData int8).
Fail Next Obligation.

Equations impl__HandshakeData__find_handshake_message (self : both t_HandshakeData) (handshake_type : both t_HandshakeType) (start : both uint_size) : both 'bool :=
  impl__HandshakeData__find_handshake_message self handshake_type start  :=
    ifb (impl__HandshakeData__len self) <.? (start .+ (ret_both (4 : uint_size)))
    then ret_both (false : 'bool)
    else matchb length_u24_encoded (impl__Bytes__raw_slice (0 self) (Build_t_Range (f_start := start .+ (ret_both (1 : uint_size))) (f_end := impl__Bytes__len (0 self)))) with
    | Result_Err_case _ =>
      letb _ := ret_both (tt (* Empty tuple *) : (int8)) in
      ret_both (false : 'bool)
    | Result_Ok_case len =>
      letb len := ret_both ((len) : (uint_size)) in
      ifb eq1 ((0 self).a[start]) (v_U8 (t_HandshakeType_cast_to_repr handshake_type))
      then ret_both (true : 'bool)
      else impl__HandshakeData__find_handshake_message self handshake_type ((start .+ (ret_both (4 : uint_size))) .+ len)
    end : both 'bool.
Fail Next Obligation.
