(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import CryptoRng.
Export CryptoRng.

Require Import RngCore.
Export RngCore.

Require Import lookup_db.
Export lookup_db.

Require Import ServerDB.
Export ServerDB.

Require Import ServerInfo.
Export ServerInfo.

Require Import cert_public_key.
Export cert_public_key.

Require Import rsa_public_key.
Export rsa_public_key.

Require Import verification_key_from_cert.
Export verification_key_from_cert.

Require Import hmac_tag.
Export hmac_tag.

Require Import hmac_verify.
Export hmac_verify.

Require Import kem_decap.
Export kem_decap.

Require Import kem_encap.
Export kem_encap.

Require Import kem_keygen.
Export kem_keygen.

Require Import sign.
Export sign.

Require Import sign_rsa.
Export sign_rsa.

Require Import verify.
Export verify.

Require Import Algorithms.
Export Algorithms.

Require Import Digest.
Export Digest.

Require Import KemSk.
Export KemSk.

Require Import Key.
Export Key.

Require Import MacKey.
Export MacKey.

Require Import Psk.
Export Psk.

Require Import Random.
Export Random.

Require Import SignatureScheme.
Export SignatureScheme.

Require Import HandshakeData.
Export HandshakeData.

Require Import Crate_Tls13formats.
Export Crate_Tls13formats.

Require Import Crate_Tls13keyscheduler.
Export Crate_Tls13keyscheduler.

Require Import Crate_Tls13record.
Export Crate_Tls13record.

Require Import Crate_Tls13utils.
Export Crate_Tls13utils.

Equations get_rsa_signature {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (cert : both t_Bytes) (sk : both t_Bytes) (sigval : both t_Bytes) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result t_Bytes int8) :=
  get_rsa_signature cert sk sigval rng  :=
    run (letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] '(cert_scheme,cert_slice) := matchb f_branch (verification_key_from_cert cert) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist195 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist195)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_SignatureScheme × t_CertificateKey)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] pk := matchb f_branch (rsa_public_key cert cert_slice) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result t_Bytes int8)] hoist196 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist196)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_RsaVerificationKey)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb '(tmp0,out) := sign_rsa sk (f_modulus pk) (f_exponent pk) cert_scheme sigval rng in
    letb rng := tmp0 in
    letb hax_temp_output := out in
    prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result t_Bytes int8).
Fail Next Obligation.

Definition t_ClientPostCertificateVerify : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_TagKey × t_Bytes × t_Bytes × t_Transcript).
Equations 0 (s : both t_ClientPostCertificateVerify) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostCertificateVerify) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostCertificateVerify) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostCertificateVerify) : both t_TagKey :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations 4 (s : both t_ClientPostCertificateVerify) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ClientPostCertificateVerify) : both t_Bytes :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 6 (s : both t_ClientPostCertificateVerify) : both t_Transcript :=
  6 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostCertificateVerify {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_TagKey} {4 : both t_Bytes} {5 : both t_Bytes} {6 : both t_Transcript} : both (t_ClientPostCertificateVerify) :=
  Build_t_ClientPostCertificateVerify  :=
    bind_both 6 (fun 6 =>
      bind_both 5 (fun 5 =>
        bind_both 4 (fun 4 =>
          bind_both 3 (fun 3 =>
            bind_both 2 (fun 2 =>
              bind_both 1 (fun 1 =>
                bind_both 0 (fun 0 =>
                  ret_both ((0,1,2,3,4,5,6) : (t_ClientPostCertificateVerify))))))))) : both (t_ClientPostCertificateVerify).
Fail Next Obligation.
Notation "'Build_t_ClientPostCertificateVerify' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ClientPostCertificateVerify (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostCertificateVerify' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_ClientPostCertificateVerify (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostCertificateVerify' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_ClientPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostCertificateVerify' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_ClientPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostCertificateVerify' '[' x ']' '(' '4' ':=' y ')'" := (Build_t_ClientPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := y) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostCertificateVerify' '[' x ']' '(' '5' ':=' y ')'" := (Build_t_ClientPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := y) (6 := 6 x)).
Notation "'Build_t_ClientPostCertificateVerify' '[' x ']' '(' '6' ':=' y ')'" := (Build_t_ClientPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := y)).

Definition t_ClientPostClientFinished : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_TagKey × t_Transcript).
Equations 0 (s : both t_ClientPostClientFinished) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostClientFinished) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostClientFinished) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostClientFinished) : both t_TagKey :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations 4 (s : both t_ClientPostClientFinished) : both t_Transcript :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostClientFinished {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_TagKey} {4 : both t_Transcript} : both (t_ClientPostClientFinished) :=
  Build_t_ClientPostClientFinished  :=
    bind_both 4 (fun 4 =>
      bind_both 3 (fun 3 =>
        bind_both 2 (fun 2 =>
          bind_both 1 (fun 1 =>
            bind_both 0 (fun 0 =>
              ret_both ((0,1,2,3,4) : (t_ClientPostClientFinished))))))) : both (t_ClientPostClientFinished).
Fail Next Obligation.
Notation "'Build_t_ClientPostClientFinished' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ClientPostClientFinished (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x)).
Notation "'Build_t_ClientPostClientFinished' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_ClientPostClientFinished (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x) (4 := 4 x)).
Notation "'Build_t_ClientPostClientFinished' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_ClientPostClientFinished (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x) (4 := 4 x)).
Notation "'Build_t_ClientPostClientFinished' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_ClientPostClientFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y) (4 := 4 x)).
Notation "'Build_t_ClientPostClientFinished' '[' x ']' '(' '4' ':=' y ')'" := (Build_t_ClientPostClientFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := y)).

Definition t_ClientPostClientHello : choice_type :=
  (t_Bytes × t_Algorithms × t_Bytes × t_Option t_Bytes × t_Transcript).
Equations 0 (s : both t_ClientPostClientHello) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostClientHello) : both t_Algorithms :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostClientHello) : both t_Bytes :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostClientHello) : both (t_Option t_Bytes) :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : (t_Option t_Bytes))) : both (t_Option t_Bytes).
Fail Next Obligation.
Equations 4 (s : both t_ClientPostClientHello) : both t_Transcript :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostClientHello {0 : both t_Bytes} {1 : both t_Algorithms} {2 : both t_Bytes} {3 : both (t_Option t_Bytes)} {4 : both t_Transcript} : both (t_ClientPostClientHello) :=
  Build_t_ClientPostClientHello  :=
    bind_both 4 (fun 4 =>
      bind_both 3 (fun 3 =>
        bind_both 2 (fun 2 =>
          bind_both 1 (fun 1 =>
            bind_both 0 (fun 0 =>
              ret_both ((0,1,2,3,4) : (t_ClientPostClientHello))))))) : both (t_ClientPostClientHello).
Fail Next Obligation.
Notation "'Build_t_ClientPostClientHello' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ClientPostClientHello (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x)).
Notation "'Build_t_ClientPostClientHello' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_ClientPostClientHello (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x) (4 := 4 x)).
Notation "'Build_t_ClientPostClientHello' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_ClientPostClientHello (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x) (4 := 4 x)).
Notation "'Build_t_ClientPostClientHello' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_ClientPostClientHello (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y) (4 := 4 x)).
Notation "'Build_t_ClientPostClientHello' '[' x ']' '(' '4' ':=' y ')'" := (Build_t_ClientPostClientHello (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := y)).

Definition t_ClientPostServerFinished : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_TagKey × t_Bytes × t_Transcript).
Equations 0 (s : both t_ClientPostServerFinished) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostServerFinished) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostServerFinished) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostServerFinished) : both t_TagKey :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations 4 (s : both t_ClientPostServerFinished) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ClientPostServerFinished) : both t_Transcript :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostServerFinished {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_TagKey} {4 : both t_Bytes} {5 : both t_Transcript} : both (t_ClientPostServerFinished) :=
  Build_t_ClientPostServerFinished  :=
    bind_both 5 (fun 5 =>
      bind_both 4 (fun 4 =>
        bind_both 3 (fun 3 =>
          bind_both 2 (fun 2 =>
            bind_both 1 (fun 1 =>
              bind_both 0 (fun 0 =>
                ret_both ((0,1,2,3,4,5) : (t_ClientPostServerFinished)))))))) : both (t_ClientPostServerFinished).
Fail Next Obligation.
Notation "'Build_t_ClientPostServerFinished' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ClientPostServerFinished (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_ClientPostServerFinished' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_ClientPostServerFinished (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_ClientPostServerFinished' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_ClientPostServerFinished (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_ClientPostServerFinished' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_ClientPostServerFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_ClientPostServerFinished' '[' x ']' '(' '4' ':=' y ')'" := (Build_t_ClientPostServerFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := y) (5 := 5 x)).
Notation "'Build_t_ClientPostServerFinished' '[' x ']' '(' '5' ':=' y ')'" := (Build_t_ClientPostServerFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := y)).

Definition t_ClientPostServerHello : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_TagKey × t_Bytes × t_Bytes × t_Transcript).
Equations 0 (s : both t_ClientPostServerHello) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ClientPostServerHello) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ClientPostServerHello) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ClientPostServerHello) : both t_TagKey :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations 4 (s : both t_ClientPostServerHello) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ClientPostServerHello) : both t_Bytes :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 6 (s : both t_ClientPostServerHello) : both t_Transcript :=
  6 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ClientPostServerHello {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_TagKey} {4 : both t_Bytes} {5 : both t_Bytes} {6 : both t_Transcript} : both (t_ClientPostServerHello) :=
  Build_t_ClientPostServerHello  :=
    bind_both 6 (fun 6 =>
      bind_both 5 (fun 5 =>
        bind_both 4 (fun 4 =>
          bind_both 3 (fun 3 =>
            bind_both 2 (fun 2 =>
              bind_both 1 (fun 1 =>
                bind_both 0 (fun 0 =>
                  ret_both ((0,1,2,3,4,5,6) : (t_ClientPostServerHello))))))))) : both (t_ClientPostServerHello).
Fail Next Obligation.
Notation "'Build_t_ClientPostServerHello' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ClientPostServerHello (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostServerHello' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_ClientPostServerHello (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostServerHello' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_ClientPostServerHello (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostServerHello' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_ClientPostServerHello (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostServerHello' '[' x ']' '(' '4' ':=' y ')'" := (Build_t_ClientPostServerHello (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := y) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ClientPostServerHello' '[' x ']' '(' '5' ':=' y ')'" := (Build_t_ClientPostServerHello (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := y) (6 := 6 x)).
Notation "'Build_t_ClientPostServerHello' '[' x ']' '(' '6' ':=' y ')'" := (Build_t_ClientPostServerHello (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := y)).

Definition t_ServerPostCertificateVerify : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_TagKey × t_Bytes × t_Bytes × t_Transcript).
Equations 0 (s : both t_ServerPostCertificateVerify) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ServerPostCertificateVerify) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst x))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ServerPostCertificateVerify) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ServerPostCertificateVerify) : both t_TagKey :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations 4 (s : both t_ServerPostCertificateVerify) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ServerPostCertificateVerify) : both t_Bytes :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 6 (s : both t_ServerPostCertificateVerify) : both t_Transcript :=
  6 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostCertificateVerify {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_TagKey} {4 : both t_Bytes} {5 : both t_Bytes} {6 : both t_Transcript} : both (t_ServerPostCertificateVerify) :=
  Build_t_ServerPostCertificateVerify  :=
    bind_both 6 (fun 6 =>
      bind_both 5 (fun 5 =>
        bind_both 4 (fun 4 =>
          bind_both 3 (fun 3 =>
            bind_both 2 (fun 2 =>
              bind_both 1 (fun 1 =>
                bind_both 0 (fun 0 =>
                  ret_both ((0,1,2,3,4,5,6) : (t_ServerPostCertificateVerify))))))))) : both (t_ServerPostCertificateVerify).
Fail Next Obligation.
Notation "'Build_t_ServerPostCertificateVerify' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ServerPostCertificateVerify (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ServerPostCertificateVerify' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_ServerPostCertificateVerify (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ServerPostCertificateVerify' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_ServerPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ServerPostCertificateVerify' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_ServerPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y) (4 := 4 x) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ServerPostCertificateVerify' '[' x ']' '(' '4' ':=' y ')'" := (Build_t_ServerPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := y) (5 := 5 x) (6 := 6 x)).
Notation "'Build_t_ServerPostCertificateVerify' '[' x ']' '(' '5' ':=' y ')'" := (Build_t_ServerPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := y) (6 := 6 x)).
Notation "'Build_t_ServerPostCertificateVerify' '[' x ']' '(' '6' ':=' y ')'" := (Build_t_ServerPostCertificateVerify (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x) (6 := y)).

Definition t_ServerPostClientFinished : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_TagKey × t_Transcript).
Equations 0 (s : both t_ServerPostClientFinished) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ServerPostClientFinished) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ServerPostClientFinished) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ServerPostClientFinished) : both t_TagKey :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations 4 (s : both t_ServerPostClientFinished) : both t_Transcript :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostClientFinished {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_TagKey} {4 : both t_Transcript} : both (t_ServerPostClientFinished) :=
  Build_t_ServerPostClientFinished  :=
    bind_both 4 (fun 4 =>
      bind_both 3 (fun 3 =>
        bind_both 2 (fun 2 =>
          bind_both 1 (fun 1 =>
            bind_both 0 (fun 0 =>
              ret_both ((0,1,2,3,4) : (t_ServerPostClientFinished))))))) : both (t_ServerPostClientFinished).
Fail Next Obligation.
Notation "'Build_t_ServerPostClientFinished' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ServerPostClientFinished (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x)).
Notation "'Build_t_ServerPostClientFinished' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_ServerPostClientFinished (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x) (4 := 4 x)).
Notation "'Build_t_ServerPostClientFinished' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_ServerPostClientFinished (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x) (4 := 4 x)).
Notation "'Build_t_ServerPostClientFinished' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_ServerPostClientFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y) (4 := 4 x)).
Notation "'Build_t_ServerPostClientFinished' '[' x ']' '(' '4' ':=' y ')'" := (Build_t_ServerPostClientFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := y)).

Definition t_ServerPostClientHello : choice_type :=
  (t_Bytes × t_Algorithms × t_Bytes × t_Bytes × t_ServerInfo × t_Transcript).
Equations f_client_randomness (s : both t_ServerPostClientHello) : both t_Bytes :=
  f_client_randomness s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_ciphersuite (s : both t_ServerPostClientHello) : both t_Algorithms :=
  f_ciphersuite s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations f_session_id (s : both t_ServerPostClientHello) : both t_Bytes :=
  f_session_id s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_gx (s : both t_ServerPostClientHello) : both t_Bytes :=
  f_gx s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_server (s : both t_ServerPostClientHello) : both t_ServerInfo :=
  f_server s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_ServerInfo)) : both t_ServerInfo.
Fail Next Obligation.
Equations f_transcript (s : both t_ServerPostClientHello) : both t_Transcript :=
  f_transcript s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostClientHello {f_client_randomness : both t_Bytes} {f_ciphersuite : both t_Algorithms} {f_session_id : both t_Bytes} {f_gx : both t_Bytes} {f_server : both t_ServerInfo} {f_transcript : both t_Transcript} : both (t_ServerPostClientHello) :=
  Build_t_ServerPostClientHello  :=
    bind_both f_transcript (fun f_transcript =>
      bind_both f_server (fun f_server =>
        bind_both f_gx (fun f_gx =>
          bind_both f_session_id (fun f_session_id =>
            bind_both f_ciphersuite (fun f_ciphersuite =>
              bind_both f_client_randomness (fun f_client_randomness =>
                ret_both ((f_client_randomness,f_ciphersuite,f_session_id,f_gx,f_server,f_transcript) : (t_ServerPostClientHello)))))))) : both (t_ServerPostClientHello).
Fail Next Obligation.
Notation "'Build_t_ServerPostClientHello' '[' x ']' '(' 'f_client_randomness' ':=' y ')'" := (Build_t_ServerPostClientHello (f_client_randomness := y) (f_ciphersuite := f_ciphersuite x) (f_session_id := f_session_id x) (f_gx := f_gx x) (f_server := f_server x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostClientHello' '[' x ']' '(' 'f_ciphersuite' ':=' y ')'" := (Build_t_ServerPostClientHello (f_client_randomness := f_client_randomness x) (f_ciphersuite := y) (f_session_id := f_session_id x) (f_gx := f_gx x) (f_server := f_server x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostClientHello' '[' x ']' '(' 'f_session_id' ':=' y ')'" := (Build_t_ServerPostClientHello (f_client_randomness := f_client_randomness x) (f_ciphersuite := f_ciphersuite x) (f_session_id := y) (f_gx := f_gx x) (f_server := f_server x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostClientHello' '[' x ']' '(' 'f_gx' ':=' y ')'" := (Build_t_ServerPostClientHello (f_client_randomness := f_client_randomness x) (f_ciphersuite := f_ciphersuite x) (f_session_id := f_session_id x) (f_gx := y) (f_server := f_server x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostClientHello' '[' x ']' '(' 'f_server' ':=' y ')'" := (Build_t_ServerPostClientHello (f_client_randomness := f_client_randomness x) (f_ciphersuite := f_ciphersuite x) (f_session_id := f_session_id x) (f_gx := f_gx x) (f_server := y) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostClientHello' '[' x ']' '(' 'f_transcript' ':=' y ')'" := (Build_t_ServerPostClientHello (f_client_randomness := f_client_randomness x) (f_ciphersuite := f_ciphersuite x) (f_session_id := f_session_id x) (f_gx := f_gx x) (f_server := f_server x) (f_transcript := y)).

Definition t_ServerPostServerFinished : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_TagKey × t_Bytes × t_Transcript).
Equations 0 (s : both t_ServerPostServerFinished) : both t_Bytes :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 1 (s : both t_ServerPostServerFinished) : both t_Bytes :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 2 (s : both t_ServerPostServerFinished) : both t_Algorithms :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations 3 (s : both t_ServerPostServerFinished) : both t_TagKey :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations 4 (s : both t_ServerPostServerFinished) : both t_Bytes :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations 5 (s : both t_ServerPostServerFinished) : both t_Transcript :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostServerFinished {0 : both t_Bytes} {1 : both t_Bytes} {2 : both t_Algorithms} {3 : both t_TagKey} {4 : both t_Bytes} {5 : both t_Transcript} : both (t_ServerPostServerFinished) :=
  Build_t_ServerPostServerFinished  :=
    bind_both 5 (fun 5 =>
      bind_both 4 (fun 4 =>
        bind_both 3 (fun 3 =>
          bind_both 2 (fun 2 =>
            bind_both 1 (fun 1 =>
              bind_both 0 (fun 0 =>
                ret_both ((0,1,2,3,4,5) : (t_ServerPostServerFinished)))))))) : both (t_ServerPostServerFinished).
Fail Next Obligation.
Notation "'Build_t_ServerPostServerFinished' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ServerPostServerFinished (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_ServerPostServerFinished' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_ServerPostServerFinished (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_ServerPostServerFinished' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_ServerPostServerFinished (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_ServerPostServerFinished' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_ServerPostServerFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_ServerPostServerFinished' '[' x ']' '(' '4' ':=' y ')'" := (Build_t_ServerPostServerFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := y) (5 := 5 x)).
Notation "'Build_t_ServerPostServerFinished' '[' x ']' '(' '5' ':=' y ')'" := (Build_t_ServerPostServerFinished (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := y)).

Definition t_ServerPostServerHello : choice_type :=
  (t_Bytes × t_Bytes × t_Algorithms × t_ServerInfo × t_TagKey × t_Bytes × t_Bytes × t_Transcript).
Equations f_client_random (s : both t_ServerPostServerHello) : both t_Bytes :=
  f_client_random s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst (fst (fst x)))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_server_random (s : both t_ServerPostServerHello) : both t_Bytes :=
  f_server_random s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst (fst x)))))) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_ciphersuite (s : both t_ServerPostServerHello) : both t_Algorithms :=
  f_ciphersuite s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst (fst x))))) : t_Algorithms)) : both t_Algorithms.
Fail Next Obligation.
Equations f_server (s : both t_ServerPostServerHello) : both t_ServerInfo :=
  f_server s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_ServerInfo)) : both t_ServerInfo.
Fail Next Obligation.
Equations f_master_secret (s : both t_ServerPostServerHello) : both t_TagKey :=
  f_master_secret s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations f_cfk (s : both t_ServerPostServerHello) : both t_Bytes :=
  f_cfk s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_sfk (s : both t_ServerPostServerHello) : both t_Bytes :=
  f_sfk s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_transcript (s : both t_ServerPostServerHello) : both t_Transcript :=
  f_transcript s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Transcript)) : both t_Transcript.
Fail Next Obligation.
Equations Build_t_ServerPostServerHello {f_client_random : both t_Bytes} {f_server_random : both t_Bytes} {f_ciphersuite : both t_Algorithms} {f_server : both t_ServerInfo} {f_master_secret : both t_TagKey} {f_cfk : both t_Bytes} {f_sfk : both t_Bytes} {f_transcript : both t_Transcript} : both (t_ServerPostServerHello) :=
  Build_t_ServerPostServerHello  :=
    bind_both f_transcript (fun f_transcript =>
      bind_both f_sfk (fun f_sfk =>
        bind_both f_cfk (fun f_cfk =>
          bind_both f_master_secret (fun f_master_secret =>
            bind_both f_server (fun f_server =>
              bind_both f_ciphersuite (fun f_ciphersuite =>
                bind_both f_server_random (fun f_server_random =>
                  bind_both f_client_random (fun f_client_random =>
                    ret_both ((f_client_random,f_server_random,f_ciphersuite,f_server,f_master_secret,f_cfk,f_sfk,f_transcript) : (t_ServerPostServerHello)))))))))) : both (t_ServerPostServerHello).
Fail Next Obligation.
Notation "'Build_t_ServerPostServerHello' '[' x ']' '(' 'f_client_random' ':=' y ')'" := (Build_t_ServerPostServerHello (f_client_random := y) (f_server_random := f_server_random x) (f_ciphersuite := f_ciphersuite x) (f_server := f_server x) (f_master_secret := f_master_secret x) (f_cfk := f_cfk x) (f_sfk := f_sfk x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostServerHello' '[' x ']' '(' 'f_server_random' ':=' y ')'" := (Build_t_ServerPostServerHello (f_client_random := f_client_random x) (f_server_random := y) (f_ciphersuite := f_ciphersuite x) (f_server := f_server x) (f_master_secret := f_master_secret x) (f_cfk := f_cfk x) (f_sfk := f_sfk x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostServerHello' '[' x ']' '(' 'f_ciphersuite' ':=' y ')'" := (Build_t_ServerPostServerHello (f_client_random := f_client_random x) (f_server_random := f_server_random x) (f_ciphersuite := y) (f_server := f_server x) (f_master_secret := f_master_secret x) (f_cfk := f_cfk x) (f_sfk := f_sfk x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostServerHello' '[' x ']' '(' 'f_server' ':=' y ')'" := (Build_t_ServerPostServerHello (f_client_random := f_client_random x) (f_server_random := f_server_random x) (f_ciphersuite := f_ciphersuite x) (f_server := y) (f_master_secret := f_master_secret x) (f_cfk := f_cfk x) (f_sfk := f_sfk x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostServerHello' '[' x ']' '(' 'f_master_secret' ':=' y ')'" := (Build_t_ServerPostServerHello (f_client_random := f_client_random x) (f_server_random := f_server_random x) (f_ciphersuite := f_ciphersuite x) (f_server := f_server x) (f_master_secret := y) (f_cfk := f_cfk x) (f_sfk := f_sfk x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostServerHello' '[' x ']' '(' 'f_cfk' ':=' y ')'" := (Build_t_ServerPostServerHello (f_client_random := f_client_random x) (f_server_random := f_server_random x) (f_ciphersuite := f_ciphersuite x) (f_server := f_server x) (f_master_secret := f_master_secret x) (f_cfk := y) (f_sfk := f_sfk x) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostServerHello' '[' x ']' '(' 'f_sfk' ':=' y ')'" := (Build_t_ServerPostServerHello (f_client_random := f_client_random x) (f_server_random := f_server_random x) (f_ciphersuite := f_ciphersuite x) (f_server := f_server x) (f_master_secret := f_master_secret x) (f_cfk := f_cfk x) (f_sfk := y) (f_transcript := f_transcript x)).
Notation "'Build_t_ServerPostServerHello' '[' x ']' '(' 'f_transcript' ':=' y ')'" := (Build_t_ServerPostServerHello (f_client_random := f_client_random x) (f_server_random := f_server_random x) (f_ciphersuite := f_ciphersuite x) (f_server := f_server x) (f_master_secret := f_master_secret x) (f_cfk := f_cfk x) (f_sfk := f_sfk x) (f_transcript := y)).

Equations algs_post_client_finished (st : both t_ClientPostClientFinished) : both t_Algorithms :=
  algs_post_client_finished st  :=
    2 st : both t_Algorithms.
Fail Next Obligation.

Equations algs_post_client_hello (st : both t_ClientPostClientHello) : both t_Algorithms :=
  algs_post_client_hello st  :=
    1 st : both t_Algorithms.
Fail Next Obligation.

Equations algs_post_server_hello (st : both t_ClientPostServerHello) : both t_Algorithms :=
  algs_post_server_hello st  :=
    2 st : both t_Algorithms.
Fail Next Obligation.

Equations get_client_finished (handshake_state : both t_ClientPostServerFinished) : both (t_Result (t_HandshakeData × t_ClientPostClientFinished) int8) :=
  get_client_finished handshake_state  :=
    run (letb ClientPostServerFinished (client_random,server_random,algorithms,master_secret,client_finished_key,transcript) := handshake_state in
    letm[choice_typeMonad.result_bind_code int8] transcript_hash := impl__Transcript__transcript_hash transcript in
    letm[choice_typeMonad.result_bind_code int8] verify_data := hmac_tag (impl__Algorithms__hash algorithms) client_finished_key transcript_hash in
    letm[choice_typeMonad.result_bind_code int8] client_finished := finished verify_data in
    letb transcript := impl__Transcript__add transcript client_finished in
    letm[choice_typeMonad.result_bind_code int8] transcript_hash := impl__Transcript__transcript_hash transcript in
    letm[choice_typeMonad.result_bind_code int8] resumption_master_secret := derive_rms (impl__Algorithms__hash algorithms) master_secret transcript_hash in
    Result_Ok (Result_Ok (prod_b (client_finished,ClientPostClientFinished client_random server_random algorithms resumption_master_secret transcript)))) : both (t_Result (t_HandshakeData × t_ClientPostClientFinished) int8).
Fail Next Obligation.

Equations get_server_signature_no_psk {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (state : both t_ServerPostServerHello) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8) :=
  get_server_signature_no_psk state rng  :=
    run (letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] ee := matchb f_branch (encrypted_extensions (f_ciphersuite state)) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist205 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist205)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    letb transcript := impl__Transcript__add (f_transcript state) ee in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] sc := matchb f_branch (server_certificate (f_ciphersuite state) (f_cert (f_server state))) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist206 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist206)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    letb transcript := impl__Transcript__add transcript sc in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] transcript_hash := matchb f_branch (impl__Transcript__transcript_hash transcript) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist207 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist207)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letb sigval := impl__Bytes__concat (impl__Bytes__from_slice (unsize v_PREFIX_SERVER_SIGNATURE)) transcript_hash in
    letb '(rng,hoist209) := matchb impl__Algorithms__signature (f_ciphersuite state) with
    | SignatureScheme_EcdsaSecp256r1Sha256_case  =>
      letb '(tmp0,out) := sign (impl__Algorithms__signature (f_ciphersuite state)) (f_sk (f_server state)) sigval rng in
      letb rng := tmp0 in
      prod_b (rng,out)
    | SignatureScheme_RsaPssRsaSha256_case  =>
      letb '(tmp0,out) := get_rsa_signature (f_cert (f_server state)) (f_sk (f_server state)) sigval rng in
      letb rng := tmp0 in
      prod_b (rng,out)
    | SignatureScheme_ED25519_case  =>
      prod_b (rng,Result_Err v_UNSUPPORTED_ALGORITHM)
    end in
    letb hoist210 := f_branch hoist209 in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] sig := matchb hoist210 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist208 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist208)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] scv := matchb f_branch (certificate_verify (f_ciphersuite state) sig) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8)] hoist211 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist211)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb transcript := impl__Transcript__add transcript scv in
    letb hax_temp_output := Result_Ok (prod_b (ee,sc,scv,ServerPostCertificateVerify (f_client_random state) (f_server_random state) (f_ciphersuite state) (f_master_secret state) (f_cfk state) (f_sfk state) transcript)) in
    prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8).
Fail Next Obligation.

Equations get_server_signature {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (state : both t_ServerPostServerHello) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8) :=
  get_server_signature state rng  :=
    letb '(rng,hax_temp_output) := ifb not (impl__Algorithms__psk_mode (f_ciphersuite state))
    then letb '(tmp0,out) := get_server_signature_no_psk state rng in
    letb rng := tmp0 in
    prod_b (rng,out)
    else prod_b (rng,Result_Err v_PSK_MODE_MISMATCH) in
    prod_b (rng,hax_temp_output) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify) int8).
Fail Next Obligation.

(*item error backend*)

(*item error backend*)

Equations put_client_finished (cfin : both t_HandshakeData) (st : both t_ServerPostServerFinished) : both (t_Result t_ServerPostClientFinished int8) :=
  put_client_finished cfin st  :=
    run (letb ServerPostServerFinished (cr,sr,algs,ms,cfk,tx) := st in
    letm[choice_typeMonad.result_bind_code int8] th := impl__Transcript__transcript_hash tx in
    letm[choice_typeMonad.result_bind_code int8] vd := parse_finished cfin in
    letm[choice_typeMonad.result_bind_code int8] _ := hmac_verify (impl__Algorithms__hash algs) cfk th vd in
    letb tx := impl__Transcript__add tx cfin in
    letm[choice_typeMonad.result_bind_code int8] th := impl__Transcript__transcript_hash tx in
    letm[choice_typeMonad.result_bind_code int8] rms := derive_rms (impl__Algorithms__hash algs) ms th in
    Result_Ok (Result_Ok (ServerPostClientFinished cr sr algs rms tx))) : both (t_Result t_ServerPostClientFinished int8).
Fail Next Obligation.

Equations put_psk_skip_server_signature (encrypted_extensions : both t_HandshakeData) (handshake_state : both t_ClientPostServerHello) : both (t_Result t_ClientPostCertificateVerify int8) :=
  put_psk_skip_server_signature encrypted_extensions handshake_state  :=
    run (letb ClientPostServerHello (client_random,server_random,algorithms,master_secret,client_finished_key,server_finished_key,transcript) := handshake_state in
    ifb impl__Algorithms__psk_mode algorithms
    then letm[choice_typeMonad.result_bind_code int8] _ := parse_encrypted_extensions algorithms encrypted_extensions in
    Result_Ok (letb transcript := impl__Transcript__add transcript encrypted_extensions in
    Result_Ok (ClientPostCertificateVerify client_random server_random algorithms master_secret client_finished_key server_finished_key transcript))
    else Result_Ok (Result_Err v_PSK_MODE_MISMATCH)) : both (t_Result t_ClientPostCertificateVerify int8).
Fail Next Obligation.

Equations put_server_signature (encrypted_extensions : both t_HandshakeData) (server_certificate : both t_HandshakeData) (server_certificate_verify : both t_HandshakeData) (handshake_state : both t_ClientPostServerHello) : both (t_Result t_ClientPostCertificateVerify int8) :=
  put_server_signature encrypted_extensions server_certificate server_certificate_verify handshake_state  :=
    run (letb ClientPostServerHello (client_random,server_random,algorithms,master_secret,client_finished_key,server_finished_key,transcript) := handshake_state in
    ifb not (impl__Algorithms__psk_mode algorithms)
    then letm[choice_typeMonad.result_bind_code int8] _ := parse_encrypted_extensions algorithms encrypted_extensions in
    letb transcript := impl__Transcript__add transcript encrypted_extensions in
    letm[choice_typeMonad.result_bind_code int8] certificate := parse_server_certificate server_certificate in
    letb transcript := impl__Transcript__add transcript server_certificate in
    letm[choice_typeMonad.result_bind_code int8] transcript_hash_server_certificate := impl__Transcript__transcript_hash transcript in
    letm[choice_typeMonad.result_bind_code int8] spki := verification_key_from_cert certificate in
    letm[choice_typeMonad.result_bind_code int8] cert_pk := cert_public_key certificate spki in
    letm[choice_typeMonad.result_bind_code int8] cert_signature := parse_certificate_verify algorithms server_certificate_verify in
    letb sigval := impl__Bytes__concat (impl__Bytes__from_slice (unsize v_PREFIX_SERVER_SIGNATURE)) transcript_hash_server_certificate in
    letm[choice_typeMonad.result_bind_code int8] _ := verify (impl__Algorithms__signature algorithms) cert_pk sigval cert_signature in
    Result_Ok (letb transcript := impl__Transcript__add transcript server_certificate_verify in
    Result_Ok (ClientPostCertificateVerify client_random server_random algorithms master_secret client_finished_key server_finished_key transcript))
    else Result_Ok (Result_Err v_PSK_MODE_MISMATCH)) : both (t_Result t_ClientPostCertificateVerify int8).
Fail Next Obligation.

Equations server_finish (cf : both t_HandshakeData) (st : both t_ServerPostServerFinished) : both (t_Result t_ServerPostClientFinished int8) :=
  server_finish cf st  :=
    put_client_finished cf st : both (t_Result t_ServerPostClientFinished int8).
Fail Next Obligation.

Equations get_server_hello {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (state : both t_ServerPostClientHello) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8) :=
  get_server_hello state rng  :=
    run (letb server_random := repeat (ret_both (0 : int8)) (ret_both (32 : uint_size)) in
    letb '(tmp0,tmp1) := f_fill_bytes rng server_random in
    letb rng := tmp0 in
    letb server_random := tmp1 in
    letb _ := ret_both (tt : 'unit) in
    letb '(tmp0,out) := kem_encap (f_kem (f_ciphersuite state)) (f_gx state) rng in
    letb rng := tmp0 in
    letb hoist213 := out in
    letb hoist214 := f_branch hoist213 in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] '(shared_secret,gy) := matchb hoist214 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] hoist212 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist212)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes × t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] sh := matchb f_branch (server_hello (f_ciphersuite state) (f_into server_random) (f_session_id state) gy) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] hoist215 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist215)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData)) in
      ControlFlow_Continue val
    end in
    letb transcript := impl__Transcript__add (f_transcript state) sh in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] transcript_hash := matchb f_branch (impl__Transcript__transcript_hash transcript) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] hoist216 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist216)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] '(chk,shk,cfk,sfk,ms) := matchb f_branch (derive_hk_ms (f_hash (f_ciphersuite state)) (f_aead (f_ciphersuite state)) (Build_t_TagKey (f_tag := TLSnames_DH) (f_val := shared_secret)) (impl__map (f_clone (f_psk_opt (f_server state))) (fun x =>
      Build_t_TagKey (f_tag := TLSnames_PSK) (f_val := x))) transcript_hash) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8)] hoist217 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist217)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes × t_TagKey)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (sh,impl__DuplexCipherStateH__new shk (ret_both (0 : int64)) chk (ret_both (0 : int64)),Build_t_ServerPostServerHello (f_client_random := f_client_randomness state) (f_server_random := f_into server_random) (f_ciphersuite := f_ciphersuite state) (f_server := f_server state) (f_master_secret := ms) (f_cfk := cfk) (f_sfk := sfk) (f_transcript := transcript))) in
    prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello) int8).
Fail Next Obligation.

Equations put_server_hello (handshake : both t_HandshakeData) (state : both t_ClientPostClientHello) : both (t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8) :=
  put_server_hello handshake state  :=
    run (letb ClientPostClientHello (client_random,ciphersuite,sk,psk,tx) := state in
    letm[choice_typeMonad.result_bind_code int8] '(sr,ct) := parse_server_hello ciphersuite handshake in
    letb tx := impl__Transcript__add tx handshake in
    letm[choice_typeMonad.result_bind_code int8] shared_secret := kem_decap (f_kem ciphersuite) ct sk in
    letm[choice_typeMonad.result_bind_code int8] th := impl__Transcript__transcript_hash tx in
    letm[choice_typeMonad.result_bind_code int8] '(chk,shk,cfk,sfk,ms) := derive_hk_ms (f_hash ciphersuite) (f_aead ciphersuite) (Build_t_TagKey (f_tag := TLSnames_DH) (f_val := shared_secret)) (impl__map psk (fun x =>
      Build_t_TagKey (f_tag := TLSnames_PSK) (f_val := x))) th in
    Result_Ok (Result_Ok (prod_b (impl__DuplexCipherStateH__new chk (ret_both (0 : int64)) shk (ret_both (0 : int64)),ClientPostServerHello client_random sr ciphersuite ms cfk sfk tx)))) : both (t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8).
Fail Next Obligation.

Equations client_set_params (payload : both t_HandshakeData) (st : both t_ClientPostClientHello) : both (t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8) :=
  client_set_params payload st  :=
    put_server_hello payload st : both (t_Result (t_DuplexCipherStateH × t_ClientPostServerHello) int8).
Fail Next Obligation.

(*item error backend*)

Equations build_client_hello {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (ciphersuite : both t_Algorithms) (sn : both t_Bytes) (tkt : both (t_Option t_Bytes)) (psk : both (t_Option t_Bytes)) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8) :=
  build_client_hello ciphersuite sn tkt psk rng  :=
    run (letb tx := impl__Transcript__new (impl__Algorithms__hash ciphersuite) in
    letb client_random := repeat (ret_both (0 : int8)) (ret_both (32 : uint_size)) in
    letb '(tmp0,tmp1) := f_fill_bytes rng client_random in
    letb rng := tmp0 in
    letb client_random := tmp1 in
    letb _ := ret_both (tt : 'unit) in
    letb '(tmp0,out) := kem_keygen (impl__Algorithms__kem ciphersuite) rng in
    letb rng := tmp0 in
    letb hoist219 := out in
    letb hoist220 := f_branch hoist219 in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] '(kem_sk,kem_pk) := matchb hoist220 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] hoist218 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist218)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Bytes × t_Bytes)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] '(client_hello,trunc_len) := matchb f_branch (client_hello ciphersuite (f_into client_random) kem_pk sn tkt) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] hoist221 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist221)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × uint_size)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] '(nch,cipher0,tx_ch) := matchb f_branch (compute_psk_binder_zero_rtt ciphersuite client_hello trunc_len psk tx) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8)] hoist222 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist222)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_Option t_ClientCipherState0 × t_Transcript)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb hax_temp_output := Result_Ok (prod_b (nch,cipher0,ClientPostClientHello (f_into client_random) ciphersuite kem_sk psk tx_ch)) in
    prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8).
Fail Next Obligation.

Equations client_init {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (algs : both t_Algorithms) (sn : both t_Bytes) (tkt : both (t_Option t_Bytes)) (psk : both (t_Option t_Bytes)) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8) :=
  client_init algs sn tkt psk rng  :=
    letb '(tmp0,out) := build_client_hello algs sn tkt psk rng in
    letb rng := tmp0 in
    letb hax_temp_output := out in
    prod_b (rng,hax_temp_output) : both (impl_916461611_ × t_Result (t_HandshakeData × t_Option t_ClientCipherState0 × t_ClientPostClientHello) int8).
Fail Next Obligation.

(*item error backend*)

(*item error backend*)

Equations client_finish (payload : both t_HandshakeData) (handshake_state : both t_ClientPostServerHello) : both (t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8) :=
  client_finish payload handshake_state  :=
    run (matchb impl__Algorithms__psk_mode (algs_post_server_hello handshake_state) with
    | false =>
      letm[choice_typeMonad.result_bind_code int8] '(encrypted_extensions,server_certificate,server_certificate_verify,server_finished) := impl__HandshakeData__to_four payload in
      letm[choice_typeMonad.result_bind_code int8] client_state_certificate_verify := put_server_signature encrypted_extensions server_certificate server_certificate_verify handshake_state in
      letm[choice_typeMonad.result_bind_code int8] '(cipher,client_state_server_finished) := put_server_finished server_finished client_state_certificate_verify in
      letm[choice_typeMonad.result_bind_code int8] '(client_finished,client_state) := get_client_finished client_state_server_finished in
      Result_Ok (Result_Ok (prod_b (client_finished,cipher,client_state)))
    | true =>
      letm[choice_typeMonad.result_bind_code int8] '(encrypted_extensions,server_finished) := impl__HandshakeData__to_two payload in
      letm[choice_typeMonad.result_bind_code int8] client_state_certificate_verify := put_psk_skip_server_signature encrypted_extensions handshake_state in
      letm[choice_typeMonad.result_bind_code int8] '(cipher,client_state_server_finished) := put_server_finished server_finished client_state_certificate_verify in
      letm[choice_typeMonad.result_bind_code int8] '(client_finished,client_state) := get_client_finished client_state_server_finished in
      Result_Ok (Result_Ok (prod_b (client_finished,cipher,client_state)))
    end) : both (t_Result (t_HandshakeData × t_DuplexCipherState1 × t_ClientPostClientFinished) int8).
Fail Next Obligation.

Equations process_psk_binder_zero_rtt (ciphersuite : both t_Algorithms) (th_trunc : both t_Bytes) (th : both t_Bytes) (psko : both (t_Option t_Bytes)) (bindero : both (t_Option t_Bytes)) : both (t_Result (t_Option t_ServerCipherState0) int8) :=
  process_psk_binder_zero_rtt ciphersuite th_trunc th psko bindero  :=
    run (matchb prod_b (f_psk_mode ciphersuite,psko,bindero) with
    | '(true,Option_Some k,Option_Some binder) =>
      letm[choice_typeMonad.result_bind_code int8] mk := derive_binder_key (f_hash ciphersuite) (Build_t_TagKey (f_tag := TLSnames_PSK) (f_val := f_clone k)) in
      letm[choice_typeMonad.result_bind_code int8] _ := hmac_verify (f_hash ciphersuite) mk th_trunc binder in
      ifb f_zero_rtt ciphersuite
      then letm[choice_typeMonad.result_bind_code int8] '(key_iv,early_exporter_ms) := derive_0rtt_keys (f_hash ciphersuite) (f_aead ciphersuite) (Build_t_TagKey (f_tag := TLSnames_PSK) (f_val := f_clone k)) th in
      Result_Ok (letb cipher0 := Option_Some (server_cipher_state0 key_iv (ret_both (0 : int64)) early_exporter_ms) in
      Result_Ok cipher0)
      else Result_Ok (Result_Ok Option_None)
    | '(false,Option_None ,Option_None ) =>
      Result_Ok (Result_Ok Option_None)
    | _ =>
      Result_Ok (Result_Err v_PSK_MODE_MISMATCH)
    end) : both (t_Result (t_Option t_ServerCipherState0) int8).
Fail Next Obligation.

Equations put_client_hello (ciphersuite : both t_Algorithms) (ch : both t_HandshakeData) (db : both t_ServerDB) : both (t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8) :=
  put_client_hello ciphersuite ch db  :=
    run (letm[choice_typeMonad.result_bind_code int8] '(client_randomness,session_id,sni,gx,tkto,bindero,trunc_len) := parse_client_hello ciphersuite ch in
    letb tx := impl__Transcript__new (impl__Algorithms__hash ciphersuite) in
    letm[choice_typeMonad.result_bind_code int8] th_trunc := impl__Transcript__transcript_hash_without_client_hello tx ch trunc_len in
    letb transcript := impl__Transcript__add tx ch in
    letm[choice_typeMonad.result_bind_code int8] th := impl__Transcript__transcript_hash transcript in
    letm[choice_typeMonad.result_bind_code int8] server := lookup_db ciphersuite db sni tkto in
    letm[choice_typeMonad.result_bind_code int8] cipher0 := process_psk_binder_zero_rtt ciphersuite th_trunc th (f_psk_opt server) bindero in
    Result_Ok (Result_Ok (prod_b (cipher0,Build_t_ServerPostClientHello (f_client_randomness := client_randomness) (f_ciphersuite := ciphersuite) (f_session_id := session_id) (f_gx := gx) (f_server := server) (f_transcript := transcript))))) : both (t_Result (t_Option t_ServerCipherState0 × t_ServerPostClientHello) int8).
Fail Next Obligation.

Equations server_init_no_psk {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (algs : both t_Algorithms) (ch : both t_HandshakeData) (db : both t_ServerDB) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8) :=
  server_init_no_psk algs ch db rng  :=
    run (letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(cipher0,st) := matchb f_branch (put_client_hello algs ch db) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist227 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist227)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Option t_ServerCipherState0 × t_ServerPostClientHello)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := get_server_hello st rng in
    letb rng := tmp0 in
    letb hoist229 := out in
    letb hoist230 := f_branch hoist229 in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(sh,cipher_hs,st) := matchb hoist230 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist228 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist228)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := get_server_signature st rng in
    letb rng := tmp0 in
    letb hoist232 := out in
    letb hoist233 := f_branch hoist232 in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(ee,sc,scv,st) := matchb hoist233 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist231 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist231)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_HandshakeData × t_HandshakeData × t_ServerPostCertificateVerify)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(sfin,cipher1,st) := matchb f_branch (get_server_finished st) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist234 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist234)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_DuplexCipherState1 × t_ServerPostServerFinished)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb flight := impl__HandshakeData__concat (impl__HandshakeData__concat (impl__HandshakeData__concat ee sc) scv) sfin in
    letb hax_temp_output := Result_Ok (prod_b (sh,flight,cipher0,cipher_hs,cipher1,st)) in
    prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8).
Fail Next Obligation.

Equations server_init_psk {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (algs : both t_Algorithms) (ch : both t_HandshakeData) (db : both t_ServerDB) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8) :=
  server_init_psk algs ch db rng  :=
    run (letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(cipher0,st) := matchb f_branch (put_client_hello algs ch db) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist235 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist235)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_Option t_ServerCipherState0 × t_ServerPostClientHello)) in
      ControlFlow_Continue val
    end in
    letb '(tmp0,out) := get_server_hello st rng in
    letb rng := tmp0 in
    letb hoist237 := out in
    letb hoist238 := f_branch hoist237 in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(sh,cipher_hs,st) := matchb hoist238 with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist236 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist236)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_DuplexCipherStateH × t_ServerPostServerHello)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(ee,st) := matchb f_branch (get_skip_server_signature st) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist239 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist239)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_ServerPostCertificateVerify)) in
      ControlFlow_Continue val
    end in
    letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] '(sfin,cipher1,st) := matchb f_branch (get_server_finished st) with
    | ControlFlow_Break_case residual =>
      letb residual := ret_both ((residual) : (t_Result t_Infallible int8)) in
      letm[choice_typeMonad.result_bind_code (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8)] hoist240 := ControlFlow_Break (prod_b (rng,f_from_residual residual)) in
      ControlFlow_Continue (never_to_any hoist240)
    | ControlFlow_Continue_case val =>
      letb val := ret_both ((val) : (t_HandshakeData × t_DuplexCipherState1 × t_ServerPostServerFinished)) in
      ControlFlow_Continue val
    end in
    ControlFlow_Continue (letb flight := impl__HandshakeData__concat ee sfin in
    letb hax_temp_output := Result_Ok (prod_b (sh,flight,cipher0,cipher_hs,cipher1,st)) in
    prod_b (rng,hax_temp_output))) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8).
Fail Next Obligation.

Equations server_init {impl_916461611_ : _} `{ t_Sized impl_916461611_} `{ t_CryptoRng impl_916461611_} `{ t_RngCore impl_916461611_} (algs : both t_Algorithms) (ch : both t_HandshakeData) (db : both t_ServerDB) (rng : both impl_916461611_) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8) :=
  server_init algs ch db rng  :=
    letb '(rng,hax_temp_output) := matchb impl__Algorithms__psk_mode algs with
    | false =>
      letb '(tmp0,out) := server_init_no_psk algs ch db rng in
      letb rng := tmp0 in
      prod_b (rng,out)
    | true =>
      letb '(tmp0,out) := server_init_psk algs ch db rng in
      letb rng := tmp0 in
      prod_b (rng,out)
    end in
    prod_b (rng,hax_temp_output) : both (impl_916461611_ × t_Result (t_HandshakeData × t_HandshakeData × t_Option t_ServerCipherState0 × t_DuplexCipherStateH × t_DuplexCipherState1 × t_ServerPostServerFinished) int8).
Fail Next Obligation.
