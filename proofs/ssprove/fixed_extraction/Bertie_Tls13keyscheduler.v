(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(* Require Import hkdf_expand. *)
(* Export hkdf_expand. *)

(* Require Import hkdf_extract. *)
(* Export hkdf_extract. *)

(* Require Import hmac_tag. *)
(* Export hmac_tag. *)

(* Require Import AeadAlgorithm. *)
(* Export AeadAlgorithm. *)

(* Require Import AeadKey. *)
(* Export AeadKey. *)

(* Require Import AeadKeyIV. *)
(* Export AeadKeyIV. *)

(* Require Import Algorithms. *)
(* Export Algorithms. *)

(* Require Import Digest. *)
(* Export Digest. *)

(* Require Import HashAlgorithm. *)
(* Export HashAlgorithm. *)

(* Require Import Key. *)
(* Export Key. *)

(* Require Import MacKey. *)
(* Export MacKey. *)

(* Require Import Psk. *)
(* Export Psk. *)

From BertieExtraction Require Import Bertie_Tls13formats.
(* Export Bertie_Tls13formats. *)

From BertieExtraction Require Import Bertie_Tls13utils.
(* Export _Tls13utils. *)

(* Require Import TLSnames. *)
(* Export TLSnames. *)

(* Require Import Label. *)
(* Export Label. *)

From BertieExtraction Require Import Bertie_Tls13crypto.

From BertieExtraction Require Import Fixes.

Definition t_Label : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'Label_RES_BINDER_____case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl tt))))))))))) (at level 100).
Equations Label_RES_BINDER____ : both t_Label :=
  Label_RES_BINDER____  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (tt : 'unit))))))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_EXT_BINDER_____case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))) (at level 100).
Equations Label_EXT_BINDER____ : both t_Label :=
  Label_EXT_BINDER____  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_C_E_TRAFFIC____case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))) (at level 100).
Equations Label_C_E_TRAFFIC___ : both t_Label :=
  Label_C_E_TRAFFIC___  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_E_EXP_MASTER_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))) (at level 100).
Equations Label_E_EXP_MASTER : both t_Label :=
  Label_E_EXP_MASTER  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_EXP_MASTER_____case'" := (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))) (at level 100).
Equations Label_EXP_MASTER____ : both t_Label :=
  Label_EXP_MASTER____  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_RES_MASTER_____case'" := (inl (inl (inl (inl (inl (inl (inr tt))))))) (at level 100).
Equations Label_RES_MASTER____ : both t_Label :=
  Label_RES_MASTER____  :=
    ret_both (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_C_HS_TRAFFIC_case'" := (inl (inl (inl (inl (inl (inr tt)))))) (at level 100).
Equations Label_C_HS_TRAFFIC : both t_Label :=
  Label_C_HS_TRAFFIC  :=
    ret_both (inl (inl (inl (inl (inl (inr (tt : 'unit)))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_S_HS_TRAFFIC_case'" := (inl (inl (inl (inl (inr tt))))) (at level 100).
Equations Label_S_HS_TRAFFIC : both t_Label :=
  Label_S_HS_TRAFFIC  :=
    ret_both (inl (inl (inl (inl (inr (tt : 'unit))))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_DERIVED__________case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations Label_DERIVED_________ : both t_Label :=
  Label_DERIVED_________  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_C_AP_TRAFFIC_case'" := (inl (inl (inr tt))) (at level 100).
Equations Label_C_AP_TRAFFIC : both t_Label :=
  Label_C_AP_TRAFFIC  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_S_AP_TRAFFIC_case'" := (inl (inr tt)) (at level 100).
Equations Label_S_AP_TRAFFIC : both t_Label :=
  Label_S_AP_TRAFFIC  :=
    ret_both (inl (inr (tt : 'unit)) : t_Label) : both t_Label.
Fail Next Obligation.
Notation "'Label_RESUMPTION_____case'" := (inr tt) (at level 100).
Equations Label_RESUMPTION____ : both t_Label :=
  Label_RESUMPTION____  :=
    ret_both (inr (tt : 'unit) : t_Label) : both t_Label.
Fail Next Obligation.

Equations t_Label_cast_to_repr (x : both t_Label) : both uint_size :=
  t_Label_cast_to_repr x  :=
    matchb x with
    | Label_RES_BINDER_____case  =>
      ret_both (0 : uint_size)
    | Label_EXT_BINDER_____case  =>
      ret_both (1 : uint_size)
    | Label_C_E_TRAFFIC____case  =>
      ret_both (3 : uint_size)
    | Label_E_EXP_MASTER_case  =>
      ret_both (6 : uint_size)
    | Label_EXP_MASTER_____case  =>
      ret_both (10 : uint_size)
    | Label_RES_MASTER_____case  =>
      ret_both (15 : uint_size)
    | Label_C_HS_TRAFFIC_case  =>
      ret_both (21 : uint_size)
    | Label_S_HS_TRAFFIC_case  =>
      ret_both (28 : uint_size)
    | Label_DERIVED__________case  =>
      ret_both (36 : uint_size)
    | Label_C_AP_TRAFFIC_case  =>
      ret_both (45 : uint_size)
    | Label_S_AP_TRAFFIC_case  =>
      ret_both (55 : uint_size)
    | Label_RESUMPTION_____case  =>
      ret_both (66 : uint_size)
    end : both uint_size.
Fail Next Obligation.

Definition t_TLSnames : choice_type :=
  ('unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit ∐ 'unit).
Notation "'TLSnames_ES_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl tt)))))))))))))))))) (at level 100).
Equations TLSnames_ES : both t_TLSnames :=
  TLSnames_ES  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (tt : 'unit)))))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_EEM_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))))) (at level 100).
Equations TLSnames_EEM : both t_TLSnames :=
  TLSnames_EEM  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_CET_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))))) (at level 100).
Equations TLSnames_CET : both t_TLSnames :=
  TLSnames_CET  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_Bind_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))))) (at level 100).
Equations TLSnames_Bind : both t_TLSnames :=
  TLSnames_Bind  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_Binder_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))))) (at level 100).
Equations TLSnames_Binder : both t_TLSnames :=
  TLSnames_Binder  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_HS_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))))) (at level 100).
Equations TLSnames_HS : both t_TLSnames :=
  TLSnames_HS  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_SHT_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))))) (at level 100).
Equations TLSnames_SHT : both t_TLSnames :=
  TLSnames_SHT  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_CHT_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))))) (at level 100).
Equations TLSnames_CHT : both t_TLSnames :=
  TLSnames_CHT  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_HSalt_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))))) (at level 100).
Equations TLSnames_HSalt : both t_TLSnames :=
  TLSnames_HSalt  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_AS_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))))) (at level 100).
Equations TLSnames_AS : both t_TLSnames :=
  TLSnames_AS  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_RM_case'" := (inl (inl (inl (inl (inl (inl (inl (inl (inr tt))))))))) (at level 100).
Equations TLSnames_RM : both t_TLSnames :=
  TLSnames_RM  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_CAT_case'" := (inl (inl (inl (inl (inl (inl (inl (inr tt)))))))) (at level 100).
Equations TLSnames_CAT : both t_TLSnames :=
  TLSnames_CAT  :=
    ret_both (inl (inl (inl (inl (inl (inl (inl (inr (tt : 'unit)))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_SAT_case'" := (inl (inl (inl (inl (inl (inl (inr tt))))))) (at level 100).
Equations TLSnames_SAT : both t_TLSnames :=
  TLSnames_SAT  :=
    ret_both (inl (inl (inl (inl (inl (inl (inr (tt : 'unit))))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_EAM_case'" := (inl (inl (inl (inl (inl (inr tt)))))) (at level 100).
Equations TLSnames_EAM : both t_TLSnames :=
  TLSnames_EAM  :=
    ret_both (inl (inl (inl (inl (inl (inr (tt : 'unit)))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_PSK_case'" := (inl (inl (inl (inl (inr tt))))) (at level 100).
Equations TLSnames_PSK : both t_TLSnames :=
  TLSnames_PSK  :=
    ret_both (inl (inl (inl (inl (inr (tt : 'unit))))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_ZeroSalt_case'" := (inl (inl (inl (inr tt)))) (at level 100).
Equations TLSnames_ZeroSalt : both t_TLSnames :=
  TLSnames_ZeroSalt  :=
    ret_both (inl (inl (inl (inr (tt : 'unit)))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_ESalt_case'" := (inl (inl (inr tt))) (at level 100).
Equations TLSnames_ESalt : both t_TLSnames :=
  TLSnames_ESalt  :=
    ret_both (inl (inl (inr (tt : 'unit))) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_DH_case'" := (inl (inr tt)) (at level 100).
Equations TLSnames_DH : both t_TLSnames :=
  TLSnames_DH  :=
    ret_both (inl (inr (tt : 'unit)) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.
Notation "'TLSnames_ZeroIKM_case'" := (inr tt) (at level 100).
Equations TLSnames_ZeroIKM : both t_TLSnames :=
  TLSnames_ZeroIKM  :=
    ret_both (inr (tt : 'unit) : t_TLSnames) : both t_TLSnames.
Fail Next Obligation.

Equations t_TLSnames_cast_to_repr (x : both t_TLSnames) : both uint_size :=
  t_TLSnames_cast_to_repr x  :=
    (* matchb x with *)
    bind_both x (fun y => match y with
    | TLSnames_ES_case  =>
      ret_both (0 : uint_size)
    | TLSnames_EEM_case  =>
      ret_both (1 : uint_size)
    | TLSnames_CET_case  =>
      ret_both (3 : uint_size)
    | TLSnames_Bind_case  =>
      ret_both (6 : uint_size)
    | TLSnames_Binder_case  =>
      ret_both (10 : uint_size)
    | TLSnames_HS_case  =>
      ret_both (15 : uint_size)
    | TLSnames_SHT_case  =>
      ret_both (21 : uint_size)
    | TLSnames_CHT_case  =>
      ret_both (28 : uint_size)
    | TLSnames_HSalt_case  =>
      ret_both (36 : uint_size)
    | TLSnames_AS_case  =>
      ret_both (45 : uint_size)
    | TLSnames_RM_case  =>
      ret_both (55 : uint_size)
    | TLSnames_CAT_case  =>
      ret_both (66 : uint_size)
    | TLSnames_SAT_case  =>
      ret_both (78 : uint_size)
    | TLSnames_EAM_case  =>
      ret_both (91 : uint_size)
    | TLSnames_PSK_case  =>
      ret_both (105 : uint_size)
    | TLSnames_ZeroSalt_case  =>
      ret_both (120 : uint_size)
    | TLSnames_ESalt_case  =>
      ret_both (136 : uint_size)
    | TLSnames_DH_case  =>
      ret_both (153 : uint_size)
    | TLSnames_ZeroIKM_case  =>
      ret_both (171 : uint_size)
    end) : both uint_size.
Fail Next Obligation.

Definition t_TLSkeyscheduler : choice_type :=
  'unit.
Equations Build_t_TLSkeyscheduler : both (t_TLSkeyscheduler) :=
  Build_t_TLSkeyscheduler  :=
    ret_both (tt (* Empty tuple *) : (t_TLSkeyscheduler)) : both (t_TLSkeyscheduler).
Fail Next Obligation.

Class t_KeySchedule (v_Self : choice_type) {v_N : _} `{ t_Sized v_N} := {
  f_labels : (both v_N -> both 'bool -> both (t_Result t_Bytes int8)) ;
  f_prnt_n : (both v_N -> both (t_Option v_N × t_Option v_N)) ;
}.

Equations convert_label (label : both t_Bytes) : both (t_Option t_Label) :=
  convert_label label  :=
    letb l := (impl__Bytes__declassify label)(* .a[RangeFull] *) in
    ifb l =.? array_to_list (array_from_list [ret_both (101 : int8);
      ret_both (120 : int8);
      ret_both (116 : int8);
      ret_both (32 : int8);
      ret_both (98 : int8);
      ret_both (105 : int8);
      ret_both (110 : int8);
      ret_both (100 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_EXT_BINDER____
    else ifb l =.? array_to_list (array_from_list [ret_both (114 : int8);
      ret_both (101 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (98 : int8);
      ret_both (105 : int8);
      ret_both (110 : int8);
      ret_both (100 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_RES_BINDER____
    else ifb l =.? array_to_list (array_from_list [ret_both (99 : int8);
      ret_both (32 : int8);
      ret_both (101 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_C_E_TRAFFIC___
    else ifb l =.? array_to_list (array_from_list [ret_both (101 : int8);
      ret_both (32 : int8);
      ret_both (101 : int8);
      ret_both (120 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (109 : int8);
      ret_both (97 : int8);
      ret_both (115 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_E_EXP_MASTER
    else ifb l =.? array_to_list (array_from_list [ret_both (99 : int8);
      ret_both (32 : int8);
      ret_both (97 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_C_AP_TRAFFIC
    else ifb l =.? array_to_list (array_from_list [ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (97 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_S_AP_TRAFFIC
    else ifb l =.? array_to_list (array_from_list [ret_both (101 : int8);
      ret_both (120 : int8);
      ret_both (112 : int8);
      ret_both (32 : int8);
      ret_both (109 : int8);
      ret_both (97 : int8);
      ret_both (115 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_EXP_MASTER____
    else ifb l =.? array_to_list (array_from_list [ret_both (114 : int8);
      ret_both (101 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (109 : int8);
      ret_both (97 : int8);
      ret_both (115 : int8);
      ret_both (116 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8)])
    then Option_Some Label_RES_MASTER____
    else ifb l =.? array_to_list (array_from_list [ret_both (100 : int8);
      ret_both (101 : int8);
      ret_both (114 : int8);
      ret_both (105 : int8);
      ret_both (118 : int8);
      ret_both (101 : int8);
      ret_both (100 : int8)])
    then Option_Some Label_DERIVED_________
    else ifb l =.? array_to_list (array_from_list [ret_both (99 : int8);
      ret_both (32 : int8);
      ret_both (104 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_C_HS_TRAFFIC
    else ifb l =.? array_to_list (array_from_list [ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (104 : int8);
      ret_both (115 : int8);
      ret_both (32 : int8);
      ret_both (116 : int8);
      ret_both (114 : int8);
      ret_both (97 : int8);
      ret_both (102 : int8);
      ret_both (102 : int8);
      ret_both (105 : int8);
      ret_both (99 : int8)])
    then Option_Some Label_S_HS_TRAFFIC
    else Option_Some Label_RESUMPTION____ : both (t_Option t_Label).
Fail Next Obligation.

#[global] Program Instance t_TLSkeyscheduler_t_KeySchedule : @t_KeySchedule t_TLSkeyscheduler t_TLSnames _ :=
  let f_prnt_n := fun  (a : both t_TLSnames) => matchb a with
  | TLSnames_ES_case  =>
    prod_b (Option_Some TLSnames_ZeroSalt,Option_Some TLSnames_PSK)
               | TLSnames_EEM_case => prod_b (Option_Some TLSnames_ES,Option_None)
               | TLSnames_CET_case => prod_b (Option_Some TLSnames_ES,Option_None)
               | TLSnames_Bind_case  =>
    prod_b (Option_Some TLSnames_ES,Option_None)
  | TLSnames_Binder_case  =>
    prod_b (Option_Some TLSnames_Bind,Option_None)
  | TLSnames_HS_case  =>
    prod_b (Option_Some TLSnames_ESalt,Option_Some TLSnames_DH)
               | TLSnames_SHT_case => prod_b (Option_Some TLSnames_HS,Option_None)
               | TLSnames_CHT_case => prod_b (Option_Some TLSnames_HS,Option_None)
               | TLSnames_HSalt_case  =>
    prod_b (Option_Some TLSnames_HS,Option_None)
  | TLSnames_AS_case  =>
    prod_b (Option_Some TLSnames_HSalt,Option_Some TLSnames_ZeroIKM)
               | TLSnames_RM_case => prod_b (Option_Some TLSnames_AS,Option_None)
               | TLSnames_CAT_case => prod_b (Option_Some TLSnames_AS,Option_None)
               | TLSnames_SAT_case => prod_b (Option_Some TLSnames_AS,Option_None) | TLSnames_EAM_case  =>
    prod_b (Option_Some TLSnames_AS,Option_None)
  | TLSnames_PSK_case  =>
    prod_b (Option_Some TLSnames_RM,Option_None)
  | TLSnames_ZeroSalt_case => prod_b (Option_None,Option_None) | TLSnames_DH_case => prod_b (Option_None,Option_None) | TLSnames_ZeroIKM_case  =>
    prod_b (Option_None,Option_None)
  | TLSnames_ESalt_case  =>
    prod_b (never_to_any ((* panic *) _ (* (ret_both (not yet implemented : chString)) *)),Option_None)
  end : both (t_Option t_TLSnames × t_Option t_TLSnames) in
  let f_labels := fun  (a : both t_TLSnames) (b : both 'bool) => run (letm[choice_typeMonad.result_bind_code int8] hoist46 := matchb a with
  | TLSnames_SHT_case  =>
    Result_Ok v_LABEL_S_HS_TRAFFIC
  | TLSnames_CHT_case  =>
    Result_Ok v_LABEL_C_HS_TRAFFIC
  | TLSnames_CAT_case  =>
    Result_Ok v_LABEL_C_AP_TRAFFIC
  | TLSnames_SAT_case  =>
    Result_Ok v_LABEL_S_AP_TRAFFIC
  | _ =>
    Result_Err v_INCORRECT_STATE
  end in
  Result_Ok (letb hoist47 := f_into hoist46 in
  Result_Ok hoist47)) : both (t_Result t_Bytes int8) in
  {| f_prnt_n := (@f_prnt_n);
  f_labels := (@f_labels)|}.
Next Obligation.
  intros.
Admitted.
Next Obligation.
  intros.
Admitted.
Next Obligation.
  intros.
Admitted.
Next Obligation.
  intros.
Admitted.
Fail Next Obligation.
Hint Unfold t_TLSkeyscheduler_t_KeySchedule.

Equations hash_empty (algorithm : both t_HashAlgorithm) : both (t_Result t_Bytes int8) :=
  hash_empty algorithm  :=
    impl__HashAlgorithm__hash algorithm (impl__Bytes__new (ret_both tt)) : both (t_Result t_Bytes int8).
Fail Next Obligation.

(* Definition unsize {A} (x : both (t_Seq A)) : both (nseq_ A _). *)

Equations hkdf_expand_label (hash_algorithm : both t_HashAlgorithm) (key : both t_Bytes) (label : both t_Bytes) (context : both t_Bytes) (len : both uint_size) : both (t_Result t_Bytes int8) :=
  hkdf_expand_label hash_algorithm key label context len  :=
    (* run *) (ifb len >=.? (ret_both (65536 : uint_size))
    then (* Result_Ok *) (Result_Err v_PAYLOAD_TOO_LONG)
    else letb lenb := u16_as_be_bytes (v_U16 (cast_int (WS2 := _) len)) in
    letb tls13_label := impl__Bytes__concat (impl__Bytes__from_slice (seq_from_list (f_into_iter (unsize v_LABEL_TLS13)))) label in
    letm[choice_typeMonad.result_bind_code int8] hoist134 := encode_length_u8 (impl__Bytes__as_raw tls13_label) in
    letm[choice_typeMonad.result_bind_code int8] hoist133 := encode_length_u8 (impl__Bytes__as_raw context) in
    (* Result_Ok *) (letb hoist135 := impl__Bytes__concat hoist134 hoist133 in
    letb info := impl__Bytes__prefix hoist135 (seq_from_list (f_into_iter (unsize lenb))) in
      hkdf_expand hash_algorithm key info len)) : both (t_Result t_Bytes int8).
Fail Next Obligation.

(* Equations derive_finished_key (ha : both t_HashAlgorithm) (k : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   derive_finished_key ha k  := *)
(*     hkdf_expand_label ha k (bytes (unsize v_LABEL_FINISHED)) impl__Bytes__new (impl__HashAlgorithm__hmac_tag_len ha) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

Definition t_Handle : choice_type :=
  (t_TLSnames × t_Bytes × t_HashAlgorithm × int8).
Equations f_name (s : both t_Handle) : both t_TLSnames :=
  f_name s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst x)) : t_TLSnames)) : both t_TLSnames.
Fail Next Obligation.
Equations f_key (s : both t_Handle) : both t_Bytes :=
  f_key s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations f_alg (s : both t_Handle) : both t_HashAlgorithm :=
  f_alg s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_HashAlgorithm)) : both t_HashAlgorithm.
Fail Next Obligation.
Equations f_level (s : both t_Handle) : both int8 :=
  f_level s  :=
    bind_both s (fun x =>
      ret_both (snd x : int8)) : both int8.
Fail Next Obligation.
Equations Build_t_Handle {f_name : both t_TLSnames} {f_key : both t_Bytes} {f_alg : both t_HashAlgorithm} {f_level : both int8} : both (t_Handle) :=
  Build_t_Handle  :=
    bind_both f_level (fun f_level =>
      bind_both f_alg (fun f_alg =>
        bind_both f_key (fun f_key =>
          bind_both f_name (fun f_name =>
            ret_both ((f_name,f_key,f_alg,f_level) : (t_Handle)))))) : both (t_Handle).
Fail Next Obligation.
Notation "'Build_t_Handle' '[' x ']' '(' 'f_name' ':=' y ')'" := (Build_t_Handle (f_name := y) (f_key := f_key x) (f_alg := f_alg x) (f_level := f_level x)).
Notation "'Build_t_Handle' '[' x ']' '(' 'f_key' ':=' y ')'" := (Build_t_Handle (f_name := f_name x) (f_key := y) (f_alg := f_alg x) (f_level := f_level x)).
Notation "'Build_t_Handle' '[' x ']' '(' 'f_alg' ':=' y ')'" := (Build_t_Handle (f_name := f_name x) (f_key := f_key x) (f_alg := y) (f_level := f_level x)).
Notation "'Build_t_Handle' '[' x ']' '(' 'f_level' ':=' y ')'" := (Build_t_Handle (f_name := f_name x) (f_key := f_key x) (f_alg := f_alg x) (f_level := y)).

Definition t_TagKey : choice_type :=
  (t_TLSnames × t_Bytes).
Equations f_tag (s : both t_TagKey) : both t_TLSnames :=
  f_tag s  :=
    bind_both s (fun x =>
      ret_both (fst x : t_TLSnames)) : both t_TLSnames.
Fail Next Obligation.
Equations f_val (s : both t_TagKey) : both t_Bytes :=
  f_val s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_Bytes)) : both t_Bytes.
Fail Next Obligation.
Equations Build_t_TagKey {f_tag : both t_TLSnames} {f_val : both t_Bytes} : both (t_TagKey) :=
  Build_t_TagKey  :=
    bind_both f_val (fun f_val =>
      bind_both f_tag (fun f_tag =>
        ret_both ((f_tag,f_val) : (t_TagKey)))) : both (t_TagKey).
Fail Next Obligation.
Notation "'Build_t_TagKey' '[' x ']' '(' 'f_tag' ':=' y ')'" := (Build_t_TagKey (f_tag := y) (f_val := f_val x)).
Notation "'Build_t_TagKey' '[' x ']' '(' 'f_val' ':=' y ')'" := (Build_t_TagKey (f_tag := f_tag x) (f_val := y)).

(* Equations no_psk (alg : both t_HashAlgorithm) : both t_TagKey := *)
(*   no_psk alg  := *)
(*     Build_t_TagKey (f_tag := TLSnames_PSK) (f_val := impl__Bytes__zeroes (impl__HashAlgorithm__hash_len alg)) : both t_TagKey. *)
(* Fail Next Obligation. *)

(* Definition xpd (hash_algorithm : both t_HashAlgorithm) (key : both t_TagKey) (label : both t_Bytes) (transcript_hash : both t_Bytes) : both (t_Result t_TagKey int8). *)
(* Proof. *)
(*   refine (run (_) : both (t_Result t_TagKey int8)). *)
(*   refine ( *)
(*     letm[choice_typeMonad.result_bind_code _ (* int8 *)] (n : t_TLSnames) := matchb prod_b (f_tag key,convert_label (f_clone label)) with *)
(*     | (TLSnames_ES , (* Option_ *)Some (Label_EXT_BINDER_____case)) => *)
(*       Result_Ok TLSnames_Bind *)
(*     | ( TLSnames_ES , (* Option_ *)Some (Label_RES_BINDER_____case) ) => *)
(*       Result_Ok TLSnames_Bind *)
(*     | (TLSnames_Bind ,(* Option_ *)None ) => *)
(*       Result_Ok TLSnames_Binder *)
(*     | (TLSnames_ES ,(* Option_ *)Some (Label_C_E_TRAFFIC____case) ) => *)
(*       Result_Ok TLSnames_CET *)
(*     | (TLSnames_ES ,(* Option_ *)Some (Label_E_EXP_MASTER_case) ) => *)
(*       Result_Ok TLSnames_EEM *)
(*     | (TLSnames_ES ,(* Option_ *)Some (Label_DERIVED__________case) ) => *)
(*       Result_Ok TLSnames_ESalt *)
(*     | (TLSnames_HS ,(* Option_ *)Some (Label_C_HS_TRAFFIC_case) ) => *)
(*       Result_Ok TLSnames_CHT *)
(*     | (TLSnames_HS ,(* Option_ *)Some (Label_S_HS_TRAFFIC_case) ) => *)
(*       Result_Ok TLSnames_SHT *)
(*     (* | (TLSnames_HS ,(* Option_ *)Some (Label_DERIVED__________case) ) => *) *)
(*     (*   Result_Ok TLSnames_HSalt *) *)
(*     | (TLSnames_AS ,(* Option_ *)Some (Label_C_AP_TRAFFIC_case) ) => *)
(*       Result_Ok TLSnames_CAT *)
(*     | (TLSnames_AS ,(* Option_ *)Some (Label_S_AP_TRAFFIC_case) ) => *)
(*       Result_Ok TLSnames_SAT *)
(*     | (TLSnames_AS ,(* Option_ *)Some (Label_EXP_MASTER_____case) ) => *)
(*       Result_Ok TLSnames_EAM *)
(*     | (TLSnames_AS ,(* Option_ *)Some (Label_RES_MASTER_____case) ) => *)
(*       Result_Ok TLSnames_RM *)
(*     | (TLSnames_RM ,(* Option_ *)Some (Label_RESUMPTION_____case) ) => *)
(*       Result_Ok TLSnames_PSK *)
(*     (* | _ => *) *)
(*     (*   Result_Err v_INCORRECT_STATE *) *)
(*     end in *)
(*       _). *)
(*   refine ( *)
(*       letm[choice_typeMonad.result_bind_code _ (* int8 *)] hoist197 := Result_Ok (hkdf_expand_label hash_algorithm (f_val key) label transcript_hash (impl__HashAlgorithm__hash_len hash_algorithm)) in _). *)
(*   refine (Result_Ok (letb hoist198 := Build_t_TagKey (f_tag := n) (f_val := hoist197 ) in *)
(*     Result_Ok hoist198)). *)
(* Qed. *)

Equations xpd (hash_algorithm : both t_HashAlgorithm) (key : both t_TagKey) (label : both t_Bytes) (transcript_hash : both t_Bytes) : both (t_Result t_TagKey int8) :=
  xpd hash_algorithm key label transcript_hash  :=
    (* run *) (letm[choice_typeMonad.result_bind_code _ (* int8 *)] (n : t_TLSnames) :=
    matchb prod_b (f_tag key,convert_label (f_clone label)) with
    | (TLSnames_ES , (* Option_ *)Some (Label_EXT_BINDER_____case)) =>
      Result_Ok TLSnames_Bind
    | ( TLSnames_ES , (* Option_ *)Some (Label_RES_BINDER_____case) ) =>
      Result_Ok TLSnames_Bind
    | (TLSnames_Bind ,(* Option_ *)None ) =>
      Result_Ok TLSnames_Binder
    | (TLSnames_ES ,(* Option_ *)Some (Label_C_E_TRAFFIC____case) ) =>
      Result_Ok TLSnames_CET
    | (TLSnames_ES ,(* Option_ *)Some (Label_E_EXP_MASTER_case) ) =>
      Result_Ok TLSnames_EEM
    | (TLSnames_ES ,(* Option_ *)Some (Label_DERIVED__________case) ) =>
      Result_Ok TLSnames_ESalt
    | (TLSnames_HS ,(* Option_ *)Some (Label_C_HS_TRAFFIC_case) ) =>
      Result_Ok TLSnames_CHT
    | (TLSnames_HS ,(* Option_ *)Some (Label_S_HS_TRAFFIC_case) ) =>
      Result_Ok TLSnames_SHT
    (* | (TLSnames_HS ,(* Option_ *)Some (Label_DERIVED__________case) ) => *)
    (*   Result_Ok TLSnames_HSalt *)
    | (TLSnames_AS ,(* Option_ *)Some (Label_C_AP_TRAFFIC_case) ) =>
      Result_Ok TLSnames_CAT
    | (TLSnames_AS ,(* Option_ *)Some (Label_S_AP_TRAFFIC_case) ) =>
      Result_Ok TLSnames_SAT
    | (TLSnames_AS ,(* Option_ *)Some (Label_EXP_MASTER_____case) ) =>
      Result_Ok TLSnames_EAM
    | (TLSnames_AS ,(* Option_ *)Some (Label_RES_MASTER_____case) ) =>
      Result_Ok TLSnames_RM
    | (TLSnames_RM ,(* Option_ *)Some (Label_RESUMPTION_____case) ) =>
      Result_Ok TLSnames_PSK
    (* | _ => *)
    (*   Result_Err v_INCORRECT_STATE *)
    end in
    letm[choice_typeMonad.result_bind_code _ (* int8 *)] hoist197 := Result_Ok (hkdf_expand_label hash_algorithm (f_val key) label transcript_hash (impl__HashAlgorithm__hash_len hash_algorithm)) in
    (* Result_Ok *) (letb hoist198 := Build_t_TagKey (f_tag := n) (f_val := _ (* hoist197 *)) in
    Result_Ok hoist198)) : both (t_Result t_TagKey int8).
Fail Next Obligation.

(* Equations derive_rms (ha : both t_HashAlgorithm) (master_secret : both t_TagKey) (tx : both t_Bytes) : both (t_Result t_TagKey int8) := *)
(*   derive_rms ha master_secret tx  := *)
(*     xpd ha master_secret (bytes (unsize v_LABEL_RES_MASTER)) tx : both (t_Result t_TagKey int8). *)
(* Fail Next Obligation. *)

Equations xpd_angle (name : both t_TLSnames) (label : both t_Bytes) (parrent_handle : both t_Handle) (args : both t_Bytes) : both (t_Result t_Handle int8) :=
  xpd_angle name label parrent_handle args  :=
    (* run *) (letm[choice_typeMonad.result_bind_code _ (* int8 *)] k := xpd (f_alg parrent_handle) (Build_t_TagKey (f_tag := f_name parrent_handle) (f_val := f_clone (f_key parrent_handle))) label args in
    (* Result_Ok *) (Result_Ok (Build_t_Handle (f_name := f_tag k) (f_key := f_val k) (f_alg := f_alg parrent_handle) (f_level := f_level parrent_handle)))) : both (t_Result t_Handle int8).
Fail Next Obligation.

(* Equations xtr (alg : both t_HashAlgorithm) (ikm : both t_TagKey) (salt : both t_TagKey) : both (t_Result t_TagKey int8) := *)
(*   xtr alg ikm salt  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] k_n := matchb prod_b (f_tag ikm,f_tag salt) with *)
(*     | '(TLSnames_PSK ,TLSnames_ZeroSalt ) => *)
(*       Result_Ok TLSnames_ES *)
(*     | '(TLSnames_DH ,TLSnames_ESalt ) => *)
(*       Result_Ok TLSnames_HS *)
(*     | '(TLSnames_ZeroIKM ,TLSnames_HSalt ) => *)
(*       Result_Ok TLSnames_AS *)
(*     | _ => *)
(*       Result_Err v_INCORRECT_STATE *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist199 := hkdf_extract alg (f_val ikm) (f_val salt) in *)
(*     Result_Ok (letb hoist200 := Build_t_TagKey (f_tag := k_n) (f_val := hoist199) in *)
(*     Result_Ok hoist200)) : both (t_Result t_TagKey int8). *)
(* Fail Next Obligation. *)

(* Equations zero_ikm (alg : both t_HashAlgorithm) : both t_TagKey := *)
(*   zero_ikm alg  := *)
(*     Build_t_TagKey (f_tag := TLSnames_ZeroIKM) (f_val := impl__Bytes__zeroes (impl__HashAlgorithm__hash_len alg)) : both t_TagKey. *)
(* Fail Next Obligation. *)

(* Equations zero_salt (alg : both t_HashAlgorithm) : both t_TagKey := *)
(*   zero_salt alg  := *)
(*     Build_t_TagKey (f_tag := TLSnames_ZeroSalt) (f_val := impl__Bytes__zeroes (impl__HashAlgorithm__hash_len alg)) : both t_TagKey. *)
(* Fail Next Obligation. *)

(* Equations derive_binder_key (ha : both t_HashAlgorithm) (k : both t_TagKey) : both (t_Result t_Bytes int8) := *)
(*   derive_binder_key ha k  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] early_secret := xtr ha k (zero_salt ha) in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist201 := hash_empty ha in *)
(*     letb hoist202 := xpd ha early_secret (bytes (unsize v_LABEL_RES_BINDER)) hoist201 in *)
(*     letm[choice_typeMonad.result_bind_code int8] hoist203 := hoist202 in *)
(*     Result_Ok (letb hoist204 := f_val hoist203 in *)
(*     Result_Ok hoist204)) : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations next_keys_c_2_ (hash_algorithm : both t_HashAlgorithm) (aead_algorithm : both t_AeadAlgorithm) (key : both t_TagKey) (tx : both t_Bytes) : both (t_Result (t_TagKey × t_TagKey × t_TagKey) int8) := *)
(*   next_keys_c_2_ hash_algorithm aead_algorithm key tx  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] early_secret := xtr hash_algorithm key (zero_salt hash_algorithm) in *)
(*     letm[choice_typeMonad.result_bind_code int8] digest_emp := hash_empty hash_algorithm in *)
(*     letm[choice_typeMonad.result_bind_code int8] derived_secret := xpd hash_algorithm early_secret (bytes (unsize v_LABEL_DERIVED)) digest_emp in *)
(*     letm[choice_typeMonad.result_bind_code int8] client_early_traffic_secret := xpd hash_algorithm early_secret (bytes (unsize v_LABEL_C_E_TRAFFIC)) tx in *)
(*     letm[choice_typeMonad.result_bind_code int8] early_exporter_master_secret := xpd hash_algorithm early_secret (bytes (unsize v_LABEL_E_EXP_MASTER)) tx in *)
(*     Result_Ok (Result_Ok (prod_b (early_exporter_master_secret,client_early_traffic_secret,derived_secret)))) : both (t_Result (t_TagKey × t_TagKey × t_TagKey) int8). *)
(* Fail Next Obligation. *)

(* Equations derive_aead_key_iv (hash_algorithm : both t_HashAlgorithm) (aead_algorithm : both t_AeadAlgorithm) (key : both t_Bytes) : both (t_Result t_AeadKeyIV int8) := *)
(*   derive_aead_key_iv hash_algorithm aead_algorithm key  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] sender_write_key := hkdf_expand_label hash_algorithm key (bytes (unsize v_LABEL_KEY)) impl__Bytes__new (impl__AeadAlgorithm__key_len aead_algorithm) in *)
(*     letm[choice_typeMonad.result_bind_code int8] sender_write_iv := hkdf_expand_label hash_algorithm key (bytes (unsize v_LABEL_IV)) impl__Bytes__new (impl__AeadAlgorithm__iv_len aead_algorithm) in *)
(*     Result_Ok (Result_Ok (impl__AeadKeyIV__new (impl__AeadKey__new sender_write_key aead_algorithm) sender_write_iv))) : both (t_Result t_AeadKeyIV int8). *)
(* Fail Next Obligation. *)

(* Equations derive_0rtt_keys (hash_algorithm : both t_HashAlgorithm) (aead_algorithm : both t_AeadAlgorithm) (key : both t_TagKey) (tx : both t_Bytes) : both (t_Result (t_AeadKeyIV × t_TagKey) int8) := *)
(*   derive_0rtt_keys hash_algorithm aead_algorithm key tx  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] '(early_exporter_master_secret,client_early_traffic_secret,derived_secret) := next_keys_c_2_ hash_algorithm aead_algorithm key tx in *)
(*     letm[choice_typeMonad.result_bind_code int8] sender_write_key_iv := derive_aead_key_iv hash_algorithm aead_algorithm (f_val client_early_traffic_secret) in *)
(*     Result_Ok (Result_Ok (prod_b (sender_write_key_iv,early_exporter_master_secret)))) : both (t_Result (t_AeadKeyIV × t_TagKey) int8). *)
(* Fail Next Obligation. *)

(* Equations derive_app_keys (ha : both t_HashAlgorithm) (ae : both t_AeadAlgorithm) (master_secret : both t_TagKey) (tx : both t_Bytes) : both (t_Result (t_AeadKeyIV × t_AeadKeyIV × t_TagKey) int8) := *)
(*   derive_app_keys ha ae master_secret tx  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] client_application_traffic_secret_0_ := xpd ha master_secret (bytes (unsize v_LABEL_C_AP_TRAFFIC)) tx in *)
(*     letm[choice_typeMonad.result_bind_code int8] server_application_traffic_secret_0_ := xpd ha master_secret (bytes (unsize v_LABEL_S_AP_TRAFFIC)) tx in *)
(*     letm[choice_typeMonad.result_bind_code int8] client_write_key_iv := derive_aead_key_iv ha ae (f_val client_application_traffic_secret_0_) in *)
(*     letm[choice_typeMonad.result_bind_code int8] server_write_key_iv := derive_aead_key_iv ha ae (f_val server_application_traffic_secret_0_) in *)
(*     letm[choice_typeMonad.result_bind_code int8] exporter_master_secret := xpd ha master_secret (bytes (unsize v_LABEL_EXP_MASTER)) tx in *)
(*     Result_Ok (Result_Ok (prod_b (client_write_key_iv,server_write_key_iv,exporter_master_secret)))) : both (t_Result (t_AeadKeyIV × t_AeadKeyIV × t_TagKey) int8). *)
(* Fail Next Obligation. *)

(* Equations derive_hk_ms (ha : both t_HashAlgorithm) (ae : both t_AeadAlgorithm) (shared_secret : both t_TagKey) (psko : both (t_Option t_TagKey)) (transcript_hash : both t_Bytes) : both (t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes × t_TagKey) int8) := *)
(*   derive_hk_ms ha ae shared_secret psko transcript_hash  := *)
(*     run (letb psk := matchb psko with *)
(*     | Option_Some_case k => *)
(*       letb k := ret_both ((k) : (t_TagKey)) in *)
(*       f_clone k *)
(*     | _ => *)
(*       no_psk ha *)
(*     end in *)
(*     letm[choice_typeMonad.result_bind_code int8] early_secret := xtr ha psk (zero_salt ha) in *)
(*     letm[choice_typeMonad.result_bind_code int8] digest_emp := hash_empty ha in *)
(*     letm[choice_typeMonad.result_bind_code int8] derived_secret := xpd ha early_secret (bytes (unsize v_LABEL_DERIVED)) digest_emp in *)
(*     letm[choice_typeMonad.result_bind_code int8] handshake_secret := xtr ha shared_secret derived_secret in *)
(*     letm[choice_typeMonad.result_bind_code int8] client_handshake_traffic_secret := xpd ha handshake_secret (bytes (unsize v_LABEL_C_HS_TRAFFIC)) transcript_hash in *)
(*     letm[choice_typeMonad.result_bind_code int8] server_handshake_traffic_secret := xpd ha handshake_secret (bytes (unsize v_LABEL_S_HS_TRAFFIC)) transcript_hash in *)
(*     letm[choice_typeMonad.result_bind_code int8] client_finished_key := derive_finished_key ha (f_val client_handshake_traffic_secret) in *)
(*     letm[choice_typeMonad.result_bind_code int8] server_finished_key := derive_finished_key ha (f_val server_handshake_traffic_secret) in *)
(*     letm[choice_typeMonad.result_bind_code int8] client_write_key_iv := derive_aead_key_iv ha ae (f_val client_handshake_traffic_secret) in *)
(*     letm[choice_typeMonad.result_bind_code int8] server_write_key_iv := derive_aead_key_iv ha ae (f_val server_handshake_traffic_secret) in *)
(*     letm[choice_typeMonad.result_bind_code int8] master_secret___ := xpd ha handshake_secret (bytes (unsize v_LABEL_DERIVED)) digest_emp in *)
(*     letm[choice_typeMonad.result_bind_code int8] master_secret := xtr ha (zero_ikm ha) master_secret___ in *)
(*     Result_Ok (Result_Ok (prod_b (client_write_key_iv,server_write_key_iv,client_finished_key,server_finished_key,master_secret)))) : both (t_Result (t_AeadKeyIV × t_AeadKeyIV × t_Bytes × t_Bytes × t_TagKey) int8). *)
(* Fail Next Obligation. *)
