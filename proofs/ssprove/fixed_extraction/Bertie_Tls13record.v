(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Crate_Tls13crypto.
Export Crate_Tls13crypto.

Require Import Crate_Tls13formats.
Export Crate_Tls13formats.

Require Import Crate_Tls13utils.
Export Crate_Tls13utils.

Require Import TagKey.
Export TagKey.

Equations derive_iv_ctr (iv : both t_Bytes) (n : both int64) : both t_Bytes :=
  derive_iv_ctr iv n  :=
    letb (counter : t_Bytes) := f_into (impl__u64__to_be_bytes n) in
    letb iv_ctr := impl__Bytes__zeroes (impl__Bytes__len iv) in
    letb iv_ctr := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := (impl__Bytes__len iv) .- (ret_both (8 : uint_size))))) (fun i =>
      ssp (fun iv_ctr =>
        update_at iv_ctr i (iv.a[i]) : (both t_Bytes))) iv_ctr in
    letb iv_ctr := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := ret_both (8 : uint_size)))) (fun i =>
      ssp (fun iv_ctr =>
        update_at iv_ctr ((i .+ (impl__Bytes__len iv)) .- (ret_both (8 : uint_size))) ((iv.a[((i .+ (impl__Bytes__len iv)) .- (ret_both (8 : uint_size)))]) .^ (counter.a[i])) : (both t_Bytes))) iv_ctr in
    iv_ctr : both t_Bytes.
Fail Next Obligation.

Equations padlen (b : both t_Bytes) (n : both uint_size) : both uint_size :=
  padlen b n  :=
    ifb andb (n >.? (ret_both (0 : uint_size))) ((f_declassify (b.a[(n .- (ret_both (1 : uint_size)))])) =.? (ret_both (0 : int8)))
    then (ret_both (1 : uint_size)) .+ (padlen b (n .- (ret_both (1 : uint_size))))
    else ret_both (0 : uint_size) : both uint_size.
Fail Next Obligation.

Equations decrypt_record_payload (kiv : both t_AeadKeyIV) (n : both int64) (ciphertext : both t_Bytes) : both (t_Result (t_ContentType × t_Bytes) int8) :=
  decrypt_record_payload kiv n ciphertext  :=
    run (letb iv_ctr := derive_iv_ctr (f_iv kiv) n in
    letb clen := (impl__Bytes__len ciphertext) .- (ret_both (5 : uint_size)) in
    ifb andb (clen <=.? (ret_both (65536 : uint_size))) (clen >.? (ret_both (16 : uint_size)))
    then letb clen_bytes := impl__u16__to_be_bytes (cast_int (WS2 := _) clen) in
    letb ad := f_into (array_from_list [ret_both (23 : int8);
      ret_both (3 : int8);
      ret_both (3 : int8);
      clen_bytes.a[(ret_both (0 : uint_size))];
      clen_bytes.a[(ret_both (1 : uint_size))]]) in
    letm[choice_typeMonad.result_bind_code int8] _ := check_eq ad (impl__Bytes__slice_range ciphertext (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := ret_both (5 : uint_size)))) in
    letb cip := impl__Bytes__slice_range ciphertext (Build_t_Range (f_start := ret_both (5 : uint_size)) (f_end := impl__Bytes__len ciphertext)) in
    letm[choice_typeMonad.result_bind_code int8] plain := aead_decrypt (f_key kiv) iv_ctr cip ad in
    letb payload_len := ((impl__Bytes__len plain) .- (padlen plain (impl__Bytes__len plain))) .- (ret_both (1 : uint_size)) in
    letm[choice_typeMonad.result_bind_code int8] ct := impl__ContentType__try_from_u8 (f_declassify (plain.a[payload_len])) in
    Result_Ok (letb payload := impl__Bytes__slice_range plain (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := payload_len)) in
    Result_Ok (prod_b (ct,payload)))
    else Result_Ok (Result_Err v_PAYLOAD_TOO_LONG)) : both (t_Result (t_ContentType × t_Bytes) int8).
Fail Next Obligation.

Equations encrypt_record_payload (key_iv : both t_AeadKeyIV) (n : both int64) (ct : both t_ContentType) (payload : both t_Bytes) (pad : both uint_size) : both (t_Result t_Bytes int8) :=
  encrypt_record_payload key_iv n ct payload pad  :=
    run (letb iv_ctr := derive_iv_ctr (f_iv key_iv) n in
    letb inner_plaintext := impl__Bytes__concat (impl__Bytes__concat payload (bytes1 (t_ContentType_cast_to_repr ct))) (impl__Bytes__zeroes pad) in
    letb clen := (impl__Bytes__len inner_plaintext) .+ (ret_both (16 : uint_size)) in
    ifb clen <=.? (ret_both (65536 : uint_size))
    then letb clenb := impl__u16__to_be_bytes (cast_int (WS2 := _) clen) in
    letb ad := f_into (array_from_list [ret_both (23 : int8);
      ret_both (3 : int8);
      ret_both (3 : int8);
      clenb.a[(ret_both (0 : uint_size))];
      clenb.a[(ret_both (1 : uint_size))]]) in
    letm[choice_typeMonad.result_bind_code int8] cip := aead_encrypt (f_key key_iv) iv_ctr inner_plaintext ad in
    Result_Ok (letb rec := impl__Bytes__concat ad cip in
    Result_Ok rec)
    else Result_Ok (Result_Err v_PAYLOAD_TOO_LONG)) : both (t_Result t_Bytes int8).
Fail Next Obligation.

Definition t_ClientCipherState0 : choice_type :=
  (t_AeadAlgorithm × t_AeadKeyIV × int64 × t_TagKey).
Equations 0 (s : both t_ClientCipherState0) : both t_AeadAlgorithm :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst x)) : t_AeadAlgorithm)) : both t_AeadAlgorithm.
Fail Next Obligation.
Equations 1 (s : both t_ClientCipherState0) : both t_AeadKeyIV :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations 2 (s : both t_ClientCipherState0) : both int64 :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : int64)) : both int64.
Fail Next Obligation.
Equations 3 (s : both t_ClientCipherState0) : both t_TagKey :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations Build_t_ClientCipherState0 {0 : both t_AeadAlgorithm} {1 : both t_AeadKeyIV} {2 : both int64} {3 : both t_TagKey} : both (t_ClientCipherState0) :=
  Build_t_ClientCipherState0  :=
    bind_both 3 (fun 3 =>
      bind_both 2 (fun 2 =>
        bind_both 1 (fun 1 =>
          bind_both 0 (fun 0 =>
            ret_both ((0,1,2,3) : (t_ClientCipherState0)))))) : both (t_ClientCipherState0).
Fail Next Obligation.
Notation "'Build_t_ClientCipherState0' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_ClientCipherState0 (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x)).
Notation "'Build_t_ClientCipherState0' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_ClientCipherState0 (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x)).
Notation "'Build_t_ClientCipherState0' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_ClientCipherState0 (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x)).
Notation "'Build_t_ClientCipherState0' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_ClientCipherState0 (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y)).

Definition t_DuplexCipherState1 : choice_type :=
  (t_AeadAlgorithm × t_AeadKeyIV × int64 × t_AeadKeyIV × int64 × t_TagKey).
Equations 0 (s : both t_DuplexCipherState1) : both t_AeadAlgorithm :=
  0 s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst (fst (fst x)))) : t_AeadAlgorithm)) : both t_AeadAlgorithm.
Fail Next Obligation.
Equations 1 (s : both t_DuplexCipherState1) : both t_AeadKeyIV :=
  1 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst (fst x)))) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations 2 (s : both t_DuplexCipherState1) : both int64 :=
  2 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst (fst x))) : int64)) : both int64.
Fail Next Obligation.
Equations 3 (s : both t_DuplexCipherState1) : both t_AeadKeyIV :=
  3 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations 4 (s : both t_DuplexCipherState1) : both int64 :=
  4 s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : int64)) : both int64.
Fail Next Obligation.
Equations 5 (s : both t_DuplexCipherState1) : both t_TagKey :=
  5 s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations Build_t_DuplexCipherState1 {0 : both t_AeadAlgorithm} {1 : both t_AeadKeyIV} {2 : both int64} {3 : both t_AeadKeyIV} {4 : both int64} {5 : both t_TagKey} : both (t_DuplexCipherState1) :=
  Build_t_DuplexCipherState1  :=
    bind_both 5 (fun 5 =>
      bind_both 4 (fun 4 =>
        bind_both 3 (fun 3 =>
          bind_both 2 (fun 2 =>
            bind_both 1 (fun 1 =>
              bind_both 0 (fun 0 =>
                ret_both ((0,1,2,3,4,5) : (t_DuplexCipherState1)))))))) : both (t_DuplexCipherState1).
Fail Next Obligation.
Notation "'Build_t_DuplexCipherState1' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_DuplexCipherState1 (0 := y) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_DuplexCipherState1' '[' x ']' '(' '1' ':=' y ')'" := (Build_t_DuplexCipherState1 (0 := 0 x) (1 := y) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_DuplexCipherState1' '[' x ']' '(' '2' ':=' y ')'" := (Build_t_DuplexCipherState1 (0 := 0 x) (1 := 1 x) (2 := y) (3 := 3 x) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_DuplexCipherState1' '[' x ']' '(' '3' ':=' y ')'" := (Build_t_DuplexCipherState1 (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := y) (4 := 4 x) (5 := 5 x)).
Notation "'Build_t_DuplexCipherState1' '[' x ']' '(' '4' ':=' y ')'" := (Build_t_DuplexCipherState1 (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := y) (5 := 5 x)).
Notation "'Build_t_DuplexCipherState1' '[' x ']' '(' '5' ':=' y ')'" := (Build_t_DuplexCipherState1 (0 := 0 x) (1 := 1 x) (2 := 2 x) (3 := 3 x) (4 := 4 x) (5 := y)).

Definition t_DuplexCipherStateH : choice_type :=
  (t_AeadKeyIV × int64 × t_AeadKeyIV × int64).
Equations f_sender_key_iv (s : both t_DuplexCipherStateH) : both t_AeadKeyIV :=
  f_sender_key_iv s  :=
    bind_both s (fun x =>
      ret_both (fst (fst (fst x)) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations f_sender_counter (s : both t_DuplexCipherStateH) : both int64 :=
  f_sender_counter s  :=
    bind_both s (fun x =>
      ret_both (snd (fst (fst x)) : int64)) : both int64.
Fail Next Obligation.
Equations f_receiver_key_iv (s : both t_DuplexCipherStateH) : both t_AeadKeyIV :=
  f_receiver_key_iv s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations f_receiver_counter (s : both t_DuplexCipherStateH) : both int64 :=
  f_receiver_counter s  :=
    bind_both s (fun x =>
      ret_both (snd x : int64)) : both int64.
Fail Next Obligation.
Equations Build_t_DuplexCipherStateH {f_sender_key_iv : both t_AeadKeyIV} {f_sender_counter : both int64} {f_receiver_key_iv : both t_AeadKeyIV} {f_receiver_counter : both int64} : both (t_DuplexCipherStateH) :=
  Build_t_DuplexCipherStateH  :=
    bind_both f_receiver_counter (fun f_receiver_counter =>
      bind_both f_receiver_key_iv (fun f_receiver_key_iv =>
        bind_both f_sender_counter (fun f_sender_counter =>
          bind_both f_sender_key_iv (fun f_sender_key_iv =>
            ret_both ((f_sender_key_iv,f_sender_counter,f_receiver_key_iv,f_receiver_counter) : (t_DuplexCipherStateH)))))) : both (t_DuplexCipherStateH).
Fail Next Obligation.
Notation "'Build_t_DuplexCipherStateH' '[' x ']' '(' 'f_sender_key_iv' ':=' y ')'" := (Build_t_DuplexCipherStateH (f_sender_key_iv := y) (f_sender_counter := f_sender_counter x) (f_receiver_key_iv := f_receiver_key_iv x) (f_receiver_counter := f_receiver_counter x)).
Notation "'Build_t_DuplexCipherStateH' '[' x ']' '(' 'f_sender_counter' ':=' y ')'" := (Build_t_DuplexCipherStateH (f_sender_key_iv := f_sender_key_iv x) (f_sender_counter := y) (f_receiver_key_iv := f_receiver_key_iv x) (f_receiver_counter := f_receiver_counter x)).
Notation "'Build_t_DuplexCipherStateH' '[' x ']' '(' 'f_receiver_key_iv' ':=' y ')'" := (Build_t_DuplexCipherStateH (f_sender_key_iv := f_sender_key_iv x) (f_sender_counter := f_sender_counter x) (f_receiver_key_iv := y) (f_receiver_counter := f_receiver_counter x)).
Notation "'Build_t_DuplexCipherStateH' '[' x ']' '(' 'f_receiver_counter' ':=' y ')'" := (Build_t_DuplexCipherStateH (f_sender_key_iv := f_sender_key_iv x) (f_sender_counter := f_sender_counter x) (f_receiver_key_iv := f_receiver_key_iv x) (f_receiver_counter := y)).

Equations impl__DuplexCipherStateH__new (sender_key_iv : both t_AeadKeyIV) (sender_counter : both int64) (receiver_key_iv : both t_AeadKeyIV) (receiver_counter : both int64) : both t_DuplexCipherStateH :=
  impl__DuplexCipherStateH__new sender_key_iv sender_counter receiver_key_iv receiver_counter  :=
    Build_t_DuplexCipherStateH (f_sender_key_iv := sender_key_iv) (f_sender_counter := sender_counter) (f_receiver_key_iv := receiver_key_iv) (f_receiver_counter := receiver_counter) : both t_DuplexCipherStateH.
Fail Next Obligation.

Definition t_ServerCipherState0 : choice_type :=
  (t_AeadKeyIV × int64 × t_TagKey).
Equations f_key_iv (s : both t_ServerCipherState0) : both t_AeadKeyIV :=
  f_key_iv s  :=
    bind_both s (fun x =>
      ret_both (fst (fst x) : t_AeadKeyIV)) : both t_AeadKeyIV.
Fail Next Obligation.
Equations f_counter (s : both t_ServerCipherState0) : both int64 :=
  f_counter s  :=
    bind_both s (fun x =>
      ret_both (snd (fst x) : int64)) : both int64.
Fail Next Obligation.
Equations f_early_exporter_ms (s : both t_ServerCipherState0) : both t_TagKey :=
  f_early_exporter_ms s  :=
    bind_both s (fun x =>
      ret_both (snd x : t_TagKey)) : both t_TagKey.
Fail Next Obligation.
Equations Build_t_ServerCipherState0 {f_key_iv : both t_AeadKeyIV} {f_counter : both int64} {f_early_exporter_ms : both t_TagKey} : both (t_ServerCipherState0) :=
  Build_t_ServerCipherState0  :=
    bind_both f_early_exporter_ms (fun f_early_exporter_ms =>
      bind_both f_counter (fun f_counter =>
        bind_both f_key_iv (fun f_key_iv =>
          ret_both ((f_key_iv,f_counter,f_early_exporter_ms) : (t_ServerCipherState0))))) : both (t_ServerCipherState0).
Fail Next Obligation.
Notation "'Build_t_ServerCipherState0' '[' x ']' '(' 'f_key_iv' ':=' y ')'" := (Build_t_ServerCipherState0 (f_key_iv := y) (f_counter := f_counter x) (f_early_exporter_ms := f_early_exporter_ms x)).
Notation "'Build_t_ServerCipherState0' '[' x ']' '(' 'f_counter' ':=' y ')'" := (Build_t_ServerCipherState0 (f_key_iv := f_key_iv x) (f_counter := y) (f_early_exporter_ms := f_early_exporter_ms x)).
Notation "'Build_t_ServerCipherState0' '[' x ']' '(' 'f_early_exporter_ms' ':=' y ')'" := (Build_t_ServerCipherState0 (f_key_iv := f_key_iv x) (f_counter := f_counter x) (f_early_exporter_ms := y)).

Equations client_cipher_state0 (ae : both t_AeadAlgorithm) (kiv : both t_AeadKeyIV) (c : both int64) (k : both t_TagKey) : both t_ClientCipherState0 :=
  client_cipher_state0 ae kiv c k  :=
    ClientCipherState0 ae kiv c k : both t_ClientCipherState0.
Fail Next Obligation.

Equations decrypt_data (ciphertext : both t_Bytes) (st : both t_DuplexCipherState1) : both (t_Result (t_AppData × t_DuplexCipherState1) int8) :=
  decrypt_data ciphertext st  :=
    run (letb DuplexCipherState1 (ae,x,y,kiv,n,exp) := st in
    letm[choice_typeMonad.result_bind_code int8] '(ct,payload) := decrypt_record_payload kiv n ciphertext in
    letm[choice_typeMonad.result_bind_code int8] _ := check (ct =.? ContentType_ApplicationData) in
    Result_Ok (Result_Ok (prod_b (impl__AppData__new payload,DuplexCipherState1 ae x y kiv (n .+ (ret_both (1 : int64))) exp)))) : both (t_Result (t_AppData × t_DuplexCipherState1) int8).
Fail Next Obligation.

Equations decrypt_data_or_hs (ciphertext : both t_Bytes) (st : both t_DuplexCipherState1) : both (t_Result (t_ContentType × t_Bytes × t_DuplexCipherState1) int8) :=
  decrypt_data_or_hs ciphertext st  :=
    run (letb DuplexCipherState1 (ae,x,y,kiv,n,exp) := st in
    letm[choice_typeMonad.result_bind_code int8] '(ct,payload) := decrypt_record_payload kiv n ciphertext in
    Result_Ok (Result_Ok (prod_b (ct,payload,DuplexCipherState1 ae x y kiv (n .+ (ret_both (1 : int64))) exp)))) : both (t_Result (t_ContentType × t_Bytes × t_DuplexCipherState1) int8).
Fail Next Obligation.

Equations decrypt_handshake (ciphertext : both t_Bytes) (state : both t_DuplexCipherStateH) : both (t_Result (t_HandshakeData × t_DuplexCipherStateH) int8) :=
  decrypt_handshake ciphertext state  :=
    run (letm[choice_typeMonad.result_bind_code int8] '(ct,payload) := decrypt_record_payload (f_receiver_key_iv state) (f_receiver_counter state) ciphertext in
    ifb ct =.? ContentType_Alert
    then Result_Ok (Result_Err v_GOT_HANDSHAKE_FAILURE_ALERT)
    else letm[choice_typeMonad.result_bind_code int8] _ := check (ct =.? ContentType_Handshake) in
    Result_Ok (letb state := Build_t_DuplexCipherStateH[state] (f_receiver_counter := (f_receiver_counter state) .+ (ret_both (1 : int64))) in
    Result_Ok (prod_b (f_from payload,state)))) : both (t_Result (t_HandshakeData × t_DuplexCipherStateH) int8).
Fail Next Obligation.

Equations decrypt_zerortt (ciphertext : both t_Bytes) (state : both t_ServerCipherState0) : both (t_Result (t_AppData × t_ServerCipherState0) int8) :=
  decrypt_zerortt ciphertext state  :=
    run (letm[choice_typeMonad.result_bind_code int8] '(ct,payload) := decrypt_record_payload (f_key_iv state) (f_counter state) ciphertext in
    letm[choice_typeMonad.result_bind_code int8] _ := check (ct =.? ContentType_ApplicationData) in
    Result_Ok (Result_Ok (prod_b (impl__AppData__new payload,Build_t_ServerCipherState0 (f_key_iv := f_key_iv state) (f_counter := (f_counter state) .+ (ret_both (1 : int64))) (f_early_exporter_ms := f_early_exporter_ms state))))) : both (t_Result (t_AppData × t_ServerCipherState0) int8).
Fail Next Obligation.

Equations duplex_cipher_state1 (ae : both t_AeadAlgorithm) (kiv1 : both t_AeadKeyIV) (c1 : both int64) (kiv2 : both t_AeadKeyIV) (c2 : both int64) (k : both t_TagKey) : both t_DuplexCipherState1 :=
  duplex_cipher_state1 ae kiv1 c1 kiv2 c2 k  :=
    DuplexCipherState1 ae kiv1 c1 kiv2 c2 k : both t_DuplexCipherState1.
Fail Next Obligation.

Equations encrypt_data (payload : both t_AppData) (pad : both uint_size) (st : both t_DuplexCipherState1) : both (t_Result (t_Bytes × t_DuplexCipherState1) int8) :=
  encrypt_data payload pad st  :=
    run (letb DuplexCipherState1 (ae,kiv,n,x,y,exp) := st in
    letm[choice_typeMonad.result_bind_code int8] rec := encrypt_record_payload kiv n ContentType_ApplicationData (impl__AppData__into_raw payload) pad in
    Result_Ok (Result_Ok (prod_b (rec,DuplexCipherState1 ae kiv (n .+ (ret_both (1 : int64))) x y exp)))) : both (t_Result (t_Bytes × t_DuplexCipherState1) int8).
Fail Next Obligation.

Equations encrypt_handshake (payload : both t_HandshakeData) (pad : both uint_size) (state : both t_DuplexCipherStateH) : both (t_Result (t_Bytes × t_DuplexCipherStateH) int8) :=
  encrypt_handshake payload pad state  :=
    run (letb payload := impl__HandshakeData__to_bytes payload in
    letm[choice_typeMonad.result_bind_code int8] rec := encrypt_record_payload (f_sender_key_iv state) (f_sender_counter state) ContentType_Handshake payload pad in
    Result_Ok (letb state := Build_t_DuplexCipherStateH[state] (f_sender_counter := (f_sender_counter state) .+ (ret_both (1 : int64))) in
    Result_Ok (prod_b (rec,state)))) : both (t_Result (t_Bytes × t_DuplexCipherStateH) int8).
Fail Next Obligation.

Equations encrypt_zerortt (payload : both t_AppData) (pad : both uint_size) (st : both t_ClientCipherState0) : both (t_Result (t_Bytes × t_ClientCipherState0) int8) :=
  encrypt_zerortt payload pad st  :=
    run (letb ClientCipherState0 (ae,kiv,n,exp) := st in
    letm[choice_typeMonad.result_bind_code int8] rec := encrypt_record_payload kiv n ContentType_ApplicationData (impl__AppData__into_raw payload) pad in
    Result_Ok (Result_Ok (prod_b (rec,ClientCipherState0 ae kiv (n .+ (ret_both (1 : int64))) exp)))) : both (t_Result (t_Bytes × t_ClientCipherState0) int8).
Fail Next Obligation.

Equations server_cipher_state0 (key_iv : both t_AeadKeyIV) (counter : both int64) (early_exporter_ms : both t_TagKey) : both t_ServerCipherState0 :=
  server_cipher_state0 key_iv counter early_exporter_ms  :=
    Build_t_ServerCipherState0 (f_key_iv := key_iv) (f_counter := counter) (f_early_exporter_ms := early_exporter_ms) : both t_ServerCipherState0.
Fail Next Obligation.
