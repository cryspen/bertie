(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
(* From Jasmin Require Import word. *)

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

(* Require Import Range. *)
(* Export Range. *)

(* Require Import bytes_concat. *)
(* Export bytes_concat. *)

From BertieExtraction Require Import Fixes.

Definition t_Error : choice_type :=
  (t_String).
Notation "'Error_UnknownCiphersuite_case' x" := x (at level 100).
Equations Error_UnknownCiphersuite (x : both t_String) : both t_Error :=
  Error_UnknownCiphersuite x  :=
    bind_both x (fun x =>
      ret_both (x : t_Error)) : both t_Error.
Fail Next Obligation.

(*Not implemented yet? todo(item)*)

Equations v_APPLICATION_DATA_INSTEAD_OF_HANDSHAKE : both int8 :=
  v_APPLICATION_DATA_INSTEAD_OF_HANDSHAKE  :=
    ret_both (138 : int8) : both int8.
Fail Next Obligation.

Equations v_CRYPTO_ERROR : both int8 :=
  v_CRYPTO_ERROR  :=
    ret_both (2 : int8) : both int8.
Fail Next Obligation.

Equations v_DECODE_ERROR : both int8 :=
  v_DECODE_ERROR  :=
    ret_both (142 : int8) : both int8.
Fail Next Obligation.

Equations v_GOT_HANDSHAKE_FAILURE_ALERT : both int8 :=
  v_GOT_HANDSHAKE_FAILURE_ALERT  :=
    ret_both (141 : int8) : both int8.
Fail Next Obligation.

Equations v_INCORRECT_ARRAY_LENGTH : both int8 :=
  v_INCORRECT_ARRAY_LENGTH  :=
    ret_both (4 : int8) : both int8.
Fail Next Obligation.

Equations v_INCORRECT_STATE : both int8 :=
  v_INCORRECT_STATE  :=
    ret_both (128 : int8) : both int8.
Fail Next Obligation.

Equations v_INSUFFICIENT_DATA : both int8 :=
  v_INSUFFICIENT_DATA  :=
    ret_both (134 : int8) : both int8.
Fail Next Obligation.

Equations v_INSUFFICIENT_ENTROPY : both int8 :=
  v_INSUFFICIENT_ENTROPY  :=
    ret_both (3 : int8) : both int8.
Fail Next Obligation.

Equations v_INVALID_COMPRESSION_LIST : both int8 :=
  v_INVALID_COMPRESSION_LIST  :=
    ret_both (136 : int8) : both int8.
Fail Next Obligation.

Equations v_INVALID_SIGNATURE : both int8 :=
  v_INVALID_SIGNATURE  :=
    ret_both (140 : int8) : both int8.
Fail Next Obligation.

Equations v_MISSING_KEY_SHARE : both int8 :=
  v_MISSING_KEY_SHARE  :=
    ret_both (139 : int8) : both int8.
Fail Next Obligation.

Equations v_NEGOTIATION_MISMATCH : both int8 :=
  v_NEGOTIATION_MISMATCH  :=
    ret_both (132 : int8) : both int8.
Fail Next Obligation.

Equations v_PARSE_FAILED : both int8 :=
  v_PARSE_FAILED  :=
    ret_both (133 : int8) : both int8.
Fail Next Obligation.

Equations v_PAYLOAD_TOO_LONG : both int8 :=
  v_PAYLOAD_TOO_LONG  :=
    ret_both (130 : int8) : both int8.
Fail Next Obligation.

Equations v_PROTOCOL_VERSION_ALERT : both int8 :=
  v_PROTOCOL_VERSION_ALERT  :=
    ret_both (137 : int8) : both int8.
Fail Next Obligation.

Equations v_PSK_MODE_MISMATCH : both int8 :=
  v_PSK_MODE_MISMATCH  :=
    ret_both (131 : int8) : both int8.
Fail Next Obligation.

Equations v_U16 (x : both int16) : both int16 :=
  v_U16 x  :=
    x : both int16.
Fail Next Obligation.

Equations v_U32 (x : both int32) : both int32 :=
  v_U32 x  :=
    x : both int32.
Fail Next Obligation.

Equations v_U8 (x : both int8) : both int8 :=
  v_U8 x  :=
    x : both int8.
Fail Next Obligation.

Equations v_UNSUPPORTED : both int8 :=
  v_UNSUPPORTED  :=
    ret_both (135 : int8) : both int8.
Fail Next Obligation.

Equations v_UNSUPPORTED_ALGORITHM : both int8 :=
  v_UNSUPPORTED_ALGORITHM  :=
    ret_both (1 : int8) : both int8.
Fail Next Obligation.

Equations v_ZERO_RTT_DISABLED : both int8 :=
  v_ZERO_RTT_DISABLED  :=
    ret_both (129 : int8) : both int8.
Fail Next Obligation.

Equations parse_failed (_ : both 'unit) : both int8 :=
  parse_failed _  :=
    v_PARSE_FAILED : both int8.
Fail Next Obligation.

(*Not implemented yet? todo(item)*)

Class t_Declassify (v_Self : _) {v_T : _} `{ t_Sized v_T} := {
  f_declassify : (both v_Self -> both v_T) ;
}.

#[global] Program Instance int8_t_Declassify : @t_Declassify int8 int8 _ :=
  let f_declassify := fun  (self : both int8) => self : both int8 in
  {| f_declassify := (@f_declassify)|}.
Fail Next Obligation.
Hint Unfold int8_t_Declassify.

#[global] Program Instance int32_t_Declassify : @t_Declassify int32 int32 _ :=
  let f_declassify := fun  (self : both int32) => self : both int32 in
  {| f_declassify := (@f_declassify)|}.
Fail Next Obligation.
Hint Unfold int32_t_Declassify.

Equations eq1 (b1 : both int8) (b2 : both int8) : both 'bool :=
  eq1 b1 b2  :=
    (f_declassify b1) =.? (f_declassify b2) : both 'bool.
Fail Next Obligation.

(* Axiom format :  *)

Equations error_string (c : both int8) : both t_String :=
  error_string c  :=
    (* letb res := (* format *) ((* impl_2__new_v1 *) (array_from_list [ret_both (make_string _ : chString)]) (array_from_list [impl_1__new_display c])) in *)
    (* must_use *) (* res *) string_from_int c : both t_String.
Fail Next Obligation.

Equations u32_from_be_bytes (val : both (nseq int8 4)) : both int32 :=
  u32_from_be_bytes val  :=
    letb val := impl__u32__from_be_bytes val in
    v_U32 val : both int32.
Fail Next Obligation.

Equations u16_as_be_bytes (val : both int16) : both (nseq int8 2) :=
  u16_as_be_bytes val  :=
    letb val := impl__u16__to_be_bytes val in
    array_from_list [v_U8 (val.a[(ret_both (0 : uint_size))]);
      v_U8 (val.a[(ret_both (1 : uint_size))])] : both (nseq int8 2).
Fail Next Obligation.

Equations u32_as_be_bytes (val : both int32) : both (nseq int8 4) :=
  u32_as_be_bytes val  :=
    letb val := impl__u32__to_be_bytes val in
    array_from_list [v_U8 (val.a[(ret_both (0 : uint_size))]);
      v_U8 (val.a[(ret_both (1 : uint_size))]);
      v_U8 (val.a[(ret_both (2 : uint_size))]);
      v_U8 (val.a[(ret_both (3 : uint_size))])] : both (nseq int8 4).
Fail Next Obligation.

Equations check (b : both 'bool) : both (t_Result 'unit int8) :=
  check b  :=
    ifb b
    then Result_Ok (ret_both (tt : 'unit))
    else Result_Err (parse_failed (ret_both (tt : 'unit))) : both (t_Result 'unit int8).
Fail Next Obligation.

Equations check_eq1 (b1 : both int8) (b2 : both int8) : both (t_Result 'unit int8) :=
  check_eq1 b1 b2  :=
    ifb eq1 b1 b2
    then Result_Ok (ret_both (tt : 'unit))
    else Result_Err (parse_failed (ret_both (tt : 'unit))) : both (t_Result 'unit int8).
Fail Next Obligation.

Equations length_u16_encoded_slice (bytes : both (seq int8)) : both (t_Result uint_size int8) :=
  length_u16_encoded_slice bytes  :=
    ifb (len (seq_to_list bytes)) <.? (ret_both (2 : uint_size))
    then Result_Err (parse_failed (ret_both (tt : 'unit)))
    else letb l0 := cast_int (WS2 := _) (f_declassify (bytes.a[(ret_both (0 : uint_size))])) in
    letb l1 := cast_int (WS2 := _) (f_declassify (bytes.a[(ret_both (1 : uint_size))])) in
    letb l := (l0 .* (ret_both (256 : uint_size))) .+ l1 in
    ifb ((len (seq_to_list bytes)) .- (ret_both (2 : uint_size))) <.? l
    then Result_Err (parse_failed (ret_both (tt : 'unit)))
    else Result_Ok l : both (t_Result uint_size int8).
Admit Obligations.
Fail Next Obligation.

Equations length_u16_encoded (bytes : both (seq int8)) : both (t_Result uint_size int8) :=
  length_u16_encoded bytes  :=
    length_u16_encoded_slice bytes : both (t_Result uint_size int8).
Fail Next Obligation.

Equations length_u24_encoded (bytes : both (seq int8)) : both (t_Result uint_size int8) :=
  length_u24_encoded bytes  :=
    ifb (len (seq_to_list bytes)) <.? (ret_both (3 : uint_size))
    then Result_Err (parse_failed (ret_both (tt : 'unit)))
    else letb l0 := cast_int (WS2 := _) (f_declassify (bytes.a[(ret_both (0 : uint_size))])) in
    letb l1 := cast_int (WS2 := _) (f_declassify (bytes.a[(ret_both (1 : uint_size))])) in
    letb l2 := cast_int (WS2 := _) (f_declassify (bytes.a[(ret_both (2 : uint_size))])) in
    letb l := ((l0 .* (ret_both (65536 : uint_size))) .+ (l1 .* (ret_both (256 : uint_size)))) .+ l2 in
    ifb ((len (seq_to_list bytes)) .- (ret_both (3 : uint_size))) <.? l
    then Result_Err (parse_failed (ret_both (tt : 'unit)))
else Result_Ok l : both (t_Result uint_size int8).
Admit Obligations.
Fail Next Obligation.

Definition impl__is_empty {A l} (x : array_or_seq A l) := ret_both ((l =? 0) : 'bool).
Equations length_u8_encoded (bytes : both (seq int8)) : both (t_Result uint_size int8) :=
  length_u8_encoded bytes  :=
    ifb impl__is_empty (n_seq_array_or_seq bytes _)
    then Result_Err (parse_failed (ret_both (tt : 'unit)))
    else letb l := cast_int (WS2 := _) (f_declassify (bytes.a[(ret_both (0 : uint_size))])) in
    ifb ((len (seq_to_list bytes)) .- (ret_both (1 : uint_size))) <.? l
    then Result_Err (parse_failed (ret_both (tt : 'unit)))
else Result_Ok l : both (t_Result uint_size int8).
Admit Obligations.
Fail Next Obligation.

(* TODO *)
(* Equations check_length_encoding_u16_slice (bytes : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_length_encoding_u16_slice bytes  := *)
(*     run (letm[choice_typeMonad.result_bind_code _ (* int8 *)] hoist1 := length_u16_encoded bytes in *)
(*     Result_Ok (letb hoist2 := hoist1 .+ (ret_both (2 : uint_size)) in *)
(*     letb hoist3 := negb (hoist2 =.? (len (n_seq_array_or_seq bytes _)))  in *)
(*     ifb hoist3 *)
(*     then Result_Err (parse_failed (ret_both (tt : 'unit))) *)
(*     else Result_Ok (ret_both (tt : 'unit)))) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_length_encoding_u24 (bytes : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_length_encoding_u24 bytes  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist4 := length_u24_encoded bytes in *)
(*     Result_Ok (letb hoist5 := hoist4 .+ (ret_both (3 : uint_size)) in *)
(*     letb hoist6 := hoist5 <> (len bytes) in *)
(*     ifb hoist6 *)
(*     then Result_Err parse_failed *)
(*     else Result_Ok (ret_both (tt : 'unit)))) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_length_encoding_u8_slice (bytes : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_length_encoding_u8_slice bytes  := *)
(*     run (letm[choice_typeMonad.result_bind_code int8] hoist7 := length_u8_encoded bytes in *)
(*     Result_Ok (letb hoist8 := hoist7 .+ (ret_both (1 : uint_size)) in *)
(*     letb hoist9 := hoist8 <> (impl__len bytes) in *)
(*     ifb hoist9 *)
(*     then Result_Err parse_failed *)
(*     else Result_Ok (ret_both (tt : 'unit)))) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

Equations eq_slice (b1 : both (seq int8)) (b2 : both (seq int8)) : both 'bool :=
  eq_slice b1 b2  :=
    ifb negb ((len (seq_to_list b1)) =.? (len (seq_to_list b2)))
    then ret_both (false : 'bool)
    else letb (b : both 'bool) := ret_both (true : 'bool) in
    letb b := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := len (seq_to_list b1)))) (fun i =>
      ssp (fun b =>
        ifb negb (eq1 (b1.a[i]) (b2.a[i]))
        then letb b := ret_both (false : 'bool) in
        b
        else b : (both 'bool))) b in
  b : both 'bool.
Admit Obligations.
Fail Next Obligation.

Equations check_eq_slice (b1 : both (seq int8)) (b2 : both (seq int8)) : both (t_Result 'unit int8) :=
  check_eq_slice b1 b2  :=
    letb b := eq_slice b1 b2 in
    ifb b
    then Result_Ok (ret_both (tt : 'unit))
    else Result_Err (parse_failed (ret_both (tt : 'unit))) : both (t_Result 'unit int8).
Fail Next Obligation.

(* Equations check_eq_with_slice (b1 : both (seq int8)) (b2 : both (seq int8)) (start : both uint_size) (end_ : both uint_size) : both (t_Result 'unit int8) := *)
(*   check_eq_with_slice b1 b2 start end_  := *)
(*     ifb orb (orb (start >.? (len (n_seq_array_or_seq b2 _))) (end_ >.? (len (n_seq_array_or_seq b2 _)))) (end_ <.? start) *)
(*     then Result_Err (parse_failed (ret_both (tt : 'unit))) *)
(*     else letb b := eq_slice b1 (b2.a[(Build_t_Range (f_start := start) (f_end := end_))]) in *)
(*     ifb b *)
(*     then Result_Ok (ret_both (tt : 'unit)) *)
(*     else Result_Err parse_failed : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_mem (b1 : both (seq int8)) (b2 : both (seq int8)) : both (t_Result 'unit int8) := *)
(*   check_mem b1 b2  := *)
(*     ifb negb (((len (n_seq_array_or_seq b2 _)) .% (len (n_seq_array_or_seq b1 _))) =.? (ret_both (0 : uint_size))) *)
(*     then Result_Err (parse_failed (ret_both (tt : 'unit))) *)
(*     else letb b := ret_both (false : 'bool) in *)
(*     letb b := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := (len (n_seq_array_or_seq b2 _)) ./ (len (n_seq_array_or_seq b1 _))))) (fun i => *)
(*       ssp (fun b => *)
(*         ifb eq_slice b1 (b2.a[(Build_t_Range (f_start := i .* (len (n_seq_array_or_seq b1 _))) (f_end := (i .+ (ret_both (1 : uint_size))) .* (len (n_seq_array_or_seq b2 _))))]) *)
(*         then letb b := ret_both (true : 'bool) in *)
(*         b *)
(*         else b : (both 'bool))) b in *)
(*     ifb b *)
(*     then Result_Ok (ret_both (tt : 'unit)) *)
(*     else Result_Err (parse_failed (ret_both (tt : 'unit))) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

Equations tlserr {v_T : _} `{ t_Sized v_T} (err : both int8) : both (t_Result v_T int8) :=
  tlserr err  :=
 (*    letb bt := impl__Backtrace__new in *)
 (*    letb _ := v__print (impl_2__new_v1 (array_from_list [ret_both ( : chString); *)
 (*      ret_both ( *)
 (* : chString)]) (array_from_list [impl_1__new_debug bt])) in *)
 (*    letb _ := ret_both (tt : 'unit) in *)
    Result_Err err : both (t_Result v_T int8).
Fail Next Obligation.

Definition t_Bytes : choice_type :=
  (t_Vec int8 t_Global).
Equations t_Bytes_0 (s : both t_Bytes) : both (t_Vec int8 t_Global) :=
  t_Bytes_0 s  :=
    bind_both s (fun x =>
      ret_both (x : (t_Vec int8 t_Global))) : both (t_Vec int8 t_Global).
Fail Next Obligation.
Equations Build_t_Bytes {t_Bytes_0 : both (t_Vec int8 t_Global)} : both (t_Bytes) :=
  Build_t_Bytes  :=
    bind_both t_Bytes_0 (fun t_Bytes_0 =>
      ret_both ((t_Bytes_0) : (t_Bytes))) : both (t_Bytes).
Fail Next Obligation.
Notation "'Build_t_Bytes' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_Bytes (t_Bytes_0 := y)).

(* #[global] Program Instance t_Bytes_t_From : t_From t_Bytes (t_Vec int8 t_Global) := *)
(*   let f_from := fun  (x : both (t_Vec int8 t_Global)) => Bytes x : both t_Bytes in *)
(*   {| f_from := (@f_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Bytes_t_From. *)

Equations impl__Bytes__as_raw (self : both t_Bytes) : both (seq int8) :=
  impl__Bytes__as_raw self  :=
    seq_from_list (f_deref (t_Bytes_0 self)) : both (seq int8).
Fail Next Obligation.

(* Equations impl__Bytes__declassify (self : both t_Bytes) : both (t_Vec int8 t_Global) := *)
(*   impl__Bytes__declassify self  := *)
(*     f_collect (f_map (impl__iter (f_deref (0 self))) (fun x => *)
(*       f_declassify x)) : both (t_Vec int8 t_Global). *)
(* Fail Next Obligation. *)

(* Equations impl__Bytes__into_raw (self : both t_Bytes) : both (t_Vec int8 t_Global) := *)
(*   impl__Bytes__into_raw self  := *)
(*     0 self : both (t_Vec int8 t_Global). *)
(* Fail Next Obligation. *)

(* Equations impl__Bytes__declassify_array {v_C : both uint_size} (self : both t_Bytes) : both (t_Result (nseq int8 (is_pure (v_C))) int8) := *)
(*   impl__Bytes__declassify_array self  := *)
(*     impl__map_err (f_try_into (impl__Bytes__declassify self)) (fun _ => *)
(*       v_INCORRECT_ARRAY_LENGTH) : both (t_Result (nseq int8 (is_pure (v_C))) int8). *)
(* Fail Next Obligation. *)

(* #[global] Program Instance t_Bytes_t_From : t_From t_Bytes (seq int8) := *)
(*   let f_from := fun  (x : both (seq int8)) => f_into (impl__to_vec x) : both t_Bytes in *)
(*   {| f_from := (@f_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Bytes_t_From. *)

(* #[global] Program Instance t_Bytes_t_From {v_C : both uint_size} : t_From t_Bytes (nseq int8 (is_pure (v_C))) := *)
(*   let f_from := fun  (x : both (nseq int8 (is_pure (v_C)))) => f_into (impl__to_vec (unsize x)) : both t_Bytes in *)
(*   {| f_from := (@f_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Bytes_t_From. *)

(* #[global] Program Instance t_Bytes_t_From {v_C : both uint_size} : t_From t_Bytes (nseq int8 (is_pure (v_C))) := *)
(*   let f_from := fun  (x : both (nseq int8 (is_pure (v_C)))) => f_into (impl__to_vec (unsize x)) : both t_Bytes in *)
(*   {| f_from := (@f_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Bytes_t_From. *)

(* #[global] Program Instance t_Bytes_t_Index : t_Index t_Bytes uint_size := *)
(*   let f_Output := int8 : choice_type in *)
(*   let f_index := fun  (self : both t_Bytes) (x : both uint_size) => (0 self).a[x] : both int8 in *)
(*   {| f_Output := (@f_Output); *)
(*   f_index := (@f_index)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Bytes_t_Index. *)

(* #[global] Program Instance t_Bytes_t_Index : t_Index t_Bytes (t_Range uint_size) := *)
(*   let f_Output := (seq int8) : choice_type in *)
(*   let f_index := fun  (self : both t_Bytes) (x : both (t_Range uint_size)) => (0 self).a[x] : both (seq int8) in *)
(*   {| f_Output := (@f_Output); *)
(*   f_index := (@f_index)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_Bytes_t_Index. *)

(* Equations impl__Bytes__append (self : both t_Bytes) (x : both t_Bytes) : both t_Bytes := *)
(*   impl__Bytes__append self x  := *)
(*     letb '(tmp0,tmp1) := impl_1__append (t_Bytes_0 self) (t_Bytes_0 x) in *)
(*     letb self := Build_t_Bytes[self] (t_Bytes_0 := tmp0) in *)
(*     letb x := Build_t_Bytes[x] (t_Bytes_0 := tmp1) in *)
(*     letb hax_temp_output := ret_both (tt : 'unit) in *)
(*     self : both t_Bytes. *)
(* Fail Next Obligation. *)

Equations impl__Bytes__concat (self : both t_Bytes) (other : both t_Bytes) : both t_Bytes :=
  impl__Bytes__concat self other  :=
    letb '(tmp0,tmp1) := impl_1__append (t_Bytes_0 self) (t_Bytes_0 other) in
    letb self := Build_t_Bytes[self] (0 := tmp0) in
    letb other := Build_t_Bytes[other] (0 := tmp1) in
    letb _ := ret_both (tt : 'unit) in
    self : both t_Bytes.
Fail Next Obligation.

(* Equations impl__Bytes__concat_array {v_N : both uint_size} (self : both t_Bytes) (other : both (nseq int8 (is_pure (v_N)))) : both t_Bytes := *)
(*   impl__Bytes__concat_array self other  := *)
(*     letb self := Build_t_Bytes[self] (0 := impl_2__extend_from_slice (0 self) (unsize other)) in *)
(*     self : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations impl__Bytes__extend_from_slice (self : both t_Bytes) (x : both t_Bytes) : both t_Bytes := *)
(*   impl__Bytes__extend_from_slice self x  := *)
(*     letb '(hax_temp_output,self) := prod_b (ret_both (tt : 'unit),Build_t_Bytes[self] (0 := impl_2__extend_from_slice (0 self) (f_deref (0 x)))) in *)
(*     self : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations impl__Bytes__from_hex (s : both chString) : both t_Bytes := *)
(*   impl__Bytes__from_hex s  := *)
(*     letb (s : t_String) := f_collect (impl__str__split_whitespace s) in *)
(*     ifb ((impl__String__len s) .% (ret_both (2 : uint_size))) =.? (ret_both (0 : uint_size)) *)
(*     then Bytes (impl__expect (f_collect (f_map (f_step_by (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := impl__String__len s)) (ret_both (2 : uint_size))) (fun i => *)
(*       impl__and_then (impl__str__get (f_deref s) (Build_t_Range (f_start := i) (f_end := i .+ (ret_both (2 : uint_size))))) (fun sub => *)
(*         impl__map (impl__ok (impl__u8__from_str_radix sub (ret_both (16 : int32)))) v_U8)))) (ret_both (Not a hex string1 : chString))) *)
(*     else never_to_any (panic_fmt (impl_2__new_v1 (array_from_list [ret_both (internal error: entered unreachable code: Not a hex string2 : chString)]) impl_1__none)) : both t_Bytes. *)
(* Fail Next Obligation. *)

Equations impl__Bytes__from_slice (s : both (seq int8)) : both t_Bytes :=
  impl__Bytes__from_slice s  :=
    f_into s : both t_Bytes.
Fail Next Obligation.

Equations impl__Bytes__len (self : both t_Bytes) : both uint_size :=
  impl__Bytes__len self  :=
    len (t_Bytes_0 self) : both uint_size.
Fail Next Obligation.

Equations impl__Bytes__prefix (self : both t_Bytes) (prefix : both (seq int8)) : both t_Bytes :=
  impl__Bytes__prefix self prefix  :=
    letb out := impl__with_capacity ((len (seq_to_list prefix)) .+ (impl__Bytes__len self)) in
    letb out := impl_2__extend_from_slice out prefix in
    letb '(tmp0,tmp1) := impl_1__append out (t_Bytes_0 self) in
    letb out := tmp0 in
    letb self := Build_t_Bytes[self] (0 := tmp1) in
    letb _ := ret_both (tt : 'unit) in
    (* Build_t_Bytes *) out : both t_Bytes.
Fail Next Obligation.

Equations impl__Bytes__new (_ : both 'unit) : both t_Bytes :=
  impl__Bytes__new _  :=
    Build_t_Bytes (t_Bytes_0 := impl__new) : both t_Bytes.
Fail Next Obligation.

Equations impl__Bytes__new_alloc (len : both uint_size) : both t_Bytes :=
  impl__Bytes__new_alloc len  :=
    Build_t_Bytes (t_Bytes_0 := impl__with_capacity len) : both t_Bytes.
Fail Next Obligation.

Equations impl__Bytes__push (self : both t_Bytes) (x : both int8) : both t_Bytes :=
  impl__Bytes__push self x  :=
    letb '(hax_temp_output,self) := prod_b (ret_both (tt : 'unit),Build_t_Bytes[self] (0 := impl_1__push (t_Bytes_0 self) x)) in
    self : both t_Bytes.
Fail Next Obligation.

(* Equations impl__Bytes__raw_slice (self : both t_Bytes) (range : both (t_Range uint_size)) : both (seq int8) := *)
(*   impl__Bytes__raw_slice self range  := *)
(*     (0 self).a[range] : both (seq int8). *)
(* Fail Next Obligation. *)

(* Equations impl__Bytes__slice (self : both t_Bytes) (start : both uint_size) (len : both uint_size) : both t_Bytes := *)
(*   impl__Bytes__slice self start len  := *)
(*     f_into ((0 self).a[(Build_t_Range (f_start := start) (f_end := start .+ len))]) : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations impl__Bytes__slice_range (self : both t_Bytes) (range : both (t_Range uint_size)) : both t_Bytes := *)
(*   impl__Bytes__slice_range self range  := *)
(*     f_into ((0 self).a[range]) : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations impl__Bytes__update_slice (self : both t_Bytes) (start : both uint_size) (other : both t_Bytes) (beg : both uint_size) (len : both uint_size) : both t_Bytes := *)
(*   impl__Bytes__update_slice self start other beg len  := *)
(*     letb res := f_clone self in *)
(*     letb res := foldi_both_list (f_into_iter (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := len))) (fun i => *)
(*       ssp (fun res => *)
(*         update_at res (start .+ i) (other.a[(beg .+ i)]) : (both t_Bytes))) res in *)
(*     res : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations impl__Bytes__zeroes (len : both uint_size) : both t_Bytes := *)
(*   impl__Bytes__zeroes len  := *)
(*     Bytes (from_elem (v_U8 (ret_both (0 : int8))) len) : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations bytes (x : both (seq int8)) : both t_Bytes := *)
(*   bytes x  := *)
(*     f_into x : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations bytes1 (x : both int8) : both t_Bytes := *)
(*   bytes1 x  := *)
(*     f_into (array_from_list [x]) : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations bytes2 (x : both int8) (y : both int8) : both t_Bytes := *)
(*   bytes2 x y  := *)
(*     f_into (array_from_list [x; *)
(*       y]) : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations check_eq (b1 : both t_Bytes) (b2 : both t_Bytes) : both (t_Result 'unit int8) := *)
(*   check_eq b1 b2  := *)
(*     check_eq_slice (impl__Bytes__as_raw b1) (impl__Bytes__as_raw b2) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_length_encoding_u16 (bytes : both t_Bytes) : both (t_Result 'unit int8) := *)
(*   check_length_encoding_u16 bytes  := *)
(*     check_length_encoding_u16_slice (impl__Bytes__as_raw bytes) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations check_length_encoding_u8 (bytes : both t_Bytes) : both (t_Result 'unit int8) := *)
(*   check_length_encoding_u8 bytes  := *)
(*     check_length_encoding_u8_slice (impl__Bytes__as_raw bytes) : both (t_Result 'unit int8). *)
(* Fail Next Obligation. *)

(* Equations encode_length_u16 (bytes : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   encode_length_u16 bytes  := *)
(*     letb len := impl__Bytes__len bytes in *)
(*     ifb len >=.? (ret_both (65536 : uint_size)) *)
(*     then Result_Err v_PAYLOAD_TOO_LONG *)
(*     else letb len := u16_as_be_bytes (v_U16 (cast_int (WS2 := _) len)) in *)
(*     letb lenb := impl__Bytes__new_alloc ((ret_both (2 : uint_size)) .+ (impl__Bytes__len bytes)) in *)
(*     letb lenb := impl__Bytes__push lenb (len.a[(ret_both (0 : uint_size))]) in *)
(*     letb lenb := impl__Bytes__push lenb (len.a[(ret_both (1 : uint_size))]) in *)
(*     letb '(tmp0,tmp1) := impl_1__append (0 lenb) (0 bytes) in *)
(*     letb lenb := Build_t_Bytes[lenb] (0 := tmp0) in *)
(*     letb bytes := Build_t_Bytes[bytes] (0 := tmp1) in *)
(*     letb _ := ret_both (tt : 'unit) in *)
(*     Result_Ok lenb : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

(* Equations encode_length_u24 (bytes : both t_Bytes) : both (t_Result t_Bytes int8) := *)
(*   encode_length_u24 bytes  := *)
(*     letb len := impl__Bytes__len bytes in *)
(*     ifb len >=.? (ret_both (16777216 : uint_size)) *)
(*     then Result_Err v_PAYLOAD_TOO_LONG *)
(*     else letb len := u32_as_be_bytes (v_U32 (cast_int (WS2 := _) len)) in *)
(*     letb lenb := impl__Bytes__new_alloc ((ret_both (3 : uint_size)) .+ (impl__Bytes__len bytes)) in *)
(*     letb lenb := impl__Bytes__push lenb (len.a[(ret_both (1 : uint_size))]) in *)
(*     letb lenb := impl__Bytes__push lenb (len.a[(ret_both (2 : uint_size))]) in *)
(*     letb lenb := impl__Bytes__push lenb (len.a[(ret_both (3 : uint_size))]) in *)
(*     letb lenb := impl__Bytes__extend_from_slice lenb bytes in *)
(*     Result_Ok lenb : both (t_Result t_Bytes int8). *)
(* Fail Next Obligation. *)

Equations encode_length_u8 (bytes : both (seq int8)) : both (t_Result t_Bytes int8) :=
  encode_length_u8 bytes  :=
    letb len := len (seq_to_list bytes) in
    ifb len >=.? (ret_both (256 : uint_size))
    then Result_Err v_PAYLOAD_TOO_LONG
    else letb lenb := impl__Bytes__new_alloc ((ret_both (1 : uint_size)) .+ (Hacspec.Hacspec_Lib_TODO.len (seq_to_list bytes))) in
    letb lenb := impl__Bytes__push lenb (v_U8 (cast_int (WS2 := _) len)) in
    letb lenb := Build_t_Bytes[lenb] (0 := impl_2__extend_from_slice (t_Bytes_0 lenb) bytes) in
    Result_Ok lenb : both (t_Result t_Bytes int8).
Fail Next Obligation.

(* Equations eq (b1 : both t_Bytes) (b2 : both t_Bytes) : both 'bool := *)
(*   eq b1 b2  := *)
(*     eq_slice (f_deref (0 b1)) (f_deref (0 b2)) : both 'bool. *)
(* Fail Next Obligation. *)

(* Equations random_bytes (len : both uint_size) : both t_Bytes := *)
(*   random_bytes len  := *)
(*     f_into (f_collect (f_map (Build_t_Range (f_start := ret_both (0 : uint_size)) (f_end := len)) (fun _ => *)
(*       random))) : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Definition t_AppData : choice_type := *)
(*   (t_Bytes). *)
(* Equations 0 (s : both t_AppData) : both t_Bytes := *)
(*   0 s  := *)
(*     bind_both s (fun x => *)
(*       ret_both (x : t_Bytes)) : both t_Bytes. *)
(* Fail Next Obligation. *)
(* Equations Build_t_AppData {0 : both t_Bytes} : both (t_AppData) := *)
(*   Build_t_AppData  := *)
(*     bind_both 0 (fun 0 => *)
(*       ret_both ((0) : (t_AppData))) : both (t_AppData). *)
(* Fail Next Obligation. *)
(* Notation "'Build_t_AppData' '[' x ']' '(' '0' ':=' y ')'" := (Build_t_AppData (0 := y)). *)

(* Equations impl__AppData__as_raw (self : both t_AppData) : both t_Bytes := *)
(*   impl__AppData__as_raw self  := *)
(*     0 self : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations impl__AppData__into_raw (self : both t_AppData) : both t_Bytes := *)
(*   impl__AppData__into_raw self  := *)
(*     0 self : both t_Bytes. *)
(* Fail Next Obligation. *)

(* Equations impl__AppData__new (b : both t_Bytes) : both t_AppData := *)
(*   impl__AppData__new b  := *)
(*     AppData b : both t_AppData. *)
(* Fail Next Obligation. *)

(* #[global] Program Instance t_AppData_t_From : t_From t_AppData (seq int8) := *)
(*   let f_from := fun  (value : both (seq int8)) => AppData (f_into value) : both t_AppData in *)
(*   {| f_from := (@f_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_AppData_t_From. *)

(* #[global] Program Instance t_AppData_t_From {v_N : both uint_size} : t_From t_AppData (nseq int8 (is_pure (v_N))) := *)
(*   let f_from := fun  (value : both (nseq int8 (is_pure (v_N)))) => AppData (f_into value) : both t_AppData in *)
(*   {| f_from := (@f_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_AppData_t_From. *)

(* #[global] Program Instance t_AppData_t_From : t_From t_AppData (t_Vec int8 t_Global) := *)
(*   let f_from := fun  (value : both (t_Vec int8 t_Global)) => AppData (f_into value) : both t_AppData in *)
(*   {| f_from := (@f_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_AppData_t_From. *)

(* #[global] Program Instance t_AppData_t_From : t_From t_AppData t_Bytes := *)
(*   let f_from := fun  (value : both t_Bytes) => AppData value : both t_AppData in *)
(*   {| f_from := (@f_from)|}. *)
(* Fail Next Obligation. *)
(* Hint Unfold t_AppData_t_From. *)
